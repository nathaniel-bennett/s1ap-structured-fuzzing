pub const ID_ADDITIONAL_GUTI: u16 = 224;

pub const ID_ADDITIONAL_CS_FALLBACK_INDICATOR: u16 = 187;

pub const ID_ADDITIONAL_RRM_PRIORITY_INDEX: u16 = 299;

pub const ID_AERIAL_U_ESUBSCRIPTION_INFORMATION: u16 = 277;

pub const ID_ASSISTANCE_DATA_FOR_PAGING: u16 = 211;

pub const ID_BEARER_TYPE: u16 = 233;

pub const ID_BEARERS_SUBJECT_TO_EARLY_STATUS_TRANSFER_ITEM: u16 = 322;

pub const ID_BEARERS_SUBJECT_TO_STATUS_TRANSFER_ITEM: u16 = 89;

pub const ID_BLUETOOTH_MEASUREMENT_CONFIGURATION: u16 = 284;

pub const ID_BROADCAST_CANCELLED_AREA_LIST: u16 = 141;

pub const ID_BROADCAST_COMPLETED_AREA_LIST: u16 = 120;

pub const ID_CE_MODE_B_RESTRICTED: u16 = 271;

pub const ID_CE_MODE_B_SUPPORT_INDICATOR: u16 = 242;

pub const ID_CN_DOMAIN: u16 = 109;

pub const ID_CN_TYPE_RESTRICTIONS: u16 = 282;

pub const ID_CS_FALLBACK_INDICATOR: u16 = 108;

pub const ID_CSG_ID: u16 = 127;

pub const ID_CSG_ID_LIST: u16 = 128;

pub const ID_CSG_MEMBERSHIP_INFO: u16 = 226;

pub const ID_CSG_MEMBERSHIP_STATUS: u16 = 146;

pub const ID_CAUSE: u16 = 2;

pub const ID_CELL_ACCESS_MODE: u16 = 145;

pub const ID_CELL_IDENTIFIER_AND_CE_LEVEL_FOR_CE_CAPABLE_U_ES: u16 = 212;

pub const ID_CELL_TRAFFIC_TRACE: u8 = 42;

pub const ID_CONCURRENT_WARNING_MESSAGE_INDICATOR: u16 = 142;

pub const ID_CONNECTEDENG_NB_LIST: u16 = 291;

pub const ID_CONNECTEDENG_NB_TO_ADD_LIST: u16 = 292;

pub const ID_CONNECTEDENG_NB_TO_REMOVE_LIST: u16 = 293;

pub const ID_CONNECTION_ESTABLISHMENT_INDICATION: u8 = 54;

pub const ID_CONTEXTAT_SOURCE: u16 = 300;

pub const ID_CORRELATION_ID: u16 = 156;

pub const ID_COVERAGE_LEVEL: u16 = 250;

pub const ID_CRITICALITY_DIAGNOSTICS: u16 = 58;

pub const ID_DAPS_REQUEST_INFO: u16 = 317;

pub const ID_DAPS_RESPONSE_INFO_ITEM: u16 = 319;

pub const ID_DAPS_RESPONSE_INFO_LIST: u16 = 318;

pub const ID_DCN_ID: u16 = 246;

pub const ID_DL_CP_SECURITY_INFORMATION: u16 = 253;

pub const ID_DLCOUNT_VALUE_EXTENDED: u16 = 180;

pub const ID_DLCOUNT_VALUE_PDCP_S_NLENGTH18: u16 = 218;

pub const ID_DLNASPDU_DELIVERY_ACK_REQUEST: u16 = 249;

pub const ID_DATA_FORWARDING_NOT_POSSIBLE: u16 = 143;

pub const ID_DATA_CODING_SCHEME: u16 = 118;

pub const ID_DATA_SIZE: u16 = 304;

pub const ID_DEACTIVATE_TRACE: u8 = 26;

pub const ID_DEFAULT_PAGING_DRX: u16 = 137;

pub const ID_DIRECT_FORWARDING_PATH_AVAILABILITY: u16 = 79;

pub const ID_DOWNLINK_PACKET_LOSS_RATE: u16 = 273;

pub const ID_DOWNLINK_S1CDMA2000TUNNELLING: u8 = 19;

pub const ID_E_RAB_ADMITTED_ITEM: u16 = 20;

pub const ID_E_RAB_ADMITTED_LIST: u16 = 18;

pub const ID_E_RAB_DATA_FORWARDING_ITEM: u16 = 14;

pub const ID_E_RAB_FAILED_TO_BE_RELEASED_LIST: u16 = 103;

pub const ID_E_RAB_FAILED_TO_MODIFY_LIST: u16 = 32;

pub const ID_E_RAB_FAILED_TO_MODIFY_LIST_BEARER_MOD_CONF: u16 = 205;

pub const ID_E_RAB_FAILED_TO_RELEASE_LIST: u16 = 34;

pub const ID_E_RAB_FAILED_TO_RESUME_ITEM_RESUME_REQ: u16 = 236;

pub const ID_E_RAB_FAILED_TO_RESUME_ITEM_RESUME_RES: u16 = 238;

pub const ID_E_RAB_FAILED_TO_RESUME_LIST_RESUME_REQ: u16 = 235;

pub const ID_E_RAB_FAILED_TO_RESUME_LIST_RESUME_RES: u16 = 237;

pub const ID_E_RAB_FAILED_TO_SETUP_LIST_BEARER_SU_RES: u16 = 29;

pub const ID_E_RAB_FAILED_TO_SETUP_LIST_CTXT_SU_RES: u16 = 48;

pub const ID_E_RAB_FAILED_TO_SETUP_LIST_HO_REQ_ACK: u16 = 19;

pub const ID_E_RAB_FAILEDTO_SETUP_ITEM_HO_REQ_ACK: u16 = 21;

pub const ID_E_RAB_INFORMATION_LIST_ITEM: u16 = 78;

pub const ID_E_RAB_ITEM: u16 = 35;

pub const ID_E_RAB_MODIFICATION_INDICATION: u8 = 50;

pub const ID_E_RAB_MODIFY: u8 = 6;

pub const ID_E_RAB_MODIFY_ITEM_BEARER_MOD_CONF: u16 = 204;

pub const ID_E_RAB_MODIFY_ITEM_BEARER_MOD_RES: u16 = 37;

pub const ID_E_RAB_MODIFY_LIST_BEARER_MOD_CONF: u16 = 203;

pub const ID_E_RAB_MODIFY_LIST_BEARER_MOD_RES: u16 = 31;

pub const ID_E_RAB_NOT_TO_BE_MODIFIED_ITEM_BEARER_MOD_IND: u16 = 202;

pub const ID_E_RAB_NOT_TO_BE_MODIFIED_LIST_BEARER_MOD_IND: u16 = 201;

pub const ID_E_RAB_RELEASE: u8 = 7;

pub const ID_E_RAB_RELEASE_INDICATION: u8 = 8;

pub const ID_E_RAB_RELEASE_ITEM: u16 = 38;

pub const ID_E_RAB_RELEASE_ITEM_BEARER_REL_COMP: u16 = 15;

pub const ID_E_RAB_RELEASE_ITEM_HO_CMD: u16 = 49;

pub const ID_E_RAB_RELEASE_LIST_BEARER_REL_COMP: u16 = 69;

pub const ID_E_RAB_RELEASED_LIST: u16 = 110;

pub const ID_E_RAB_SETUP: u8 = 5;

pub const ID_E_RAB_SETUP_ITEM_BEARER_SU_RES: u16 = 39;

pub const ID_E_RAB_SETUP_ITEM_CTXT_SU_RES: u16 = 50;

pub const ID_E_RAB_SETUP_LIST_BEARER_SU_RES: u16 = 28;

pub const ID_E_RAB_SETUP_LIST_CTXT_SU_RES: u16 = 51;

pub const ID_E_RAB_SUBJECTTO_DATA_FORWARDING_LIST: u16 = 12;

pub const ID_E_RAB_TO_BE_MODIFIED_ITEM_BEARER_MOD_IND: u16 = 200;

pub const ID_E_RAB_TO_BE_MODIFIED_ITEM_BEARER_MOD_REQ: u16 = 36;

pub const ID_E_RAB_TO_BE_MODIFIED_LIST_BEARER_MOD_IND: u16 = 199;

pub const ID_E_RAB_TO_BE_MODIFIED_LIST_BEARER_MOD_REQ: u16 = 30;

pub const ID_E_RAB_TO_BE_RELEASED_LIST: u16 = 33;

pub const ID_E_RAB_TO_BE_RELEASED_LIST_BEARER_MOD_CONF: u16 = 210;

pub const ID_E_RAB_TO_BE_SETUP_ITEM_BEARER_SU_REQ: u16 = 17;

pub const ID_E_RAB_TO_BE_SETUP_ITEM_CTXT_SU_REQ: u16 = 52;

pub const ID_E_RAB_TO_BE_SETUP_ITEM_HO_REQ: u16 = 27;

pub const ID_E_RAB_TO_BE_SETUP_LIST_BEARER_SU_REQ: u16 = 16;

pub const ID_E_RAB_TO_BE_SETUP_LIST_CTXT_SU_REQ: u16 = 24;

pub const ID_E_RAB_TO_BE_SETUP_LIST_HO_REQ: u16 = 53;

pub const ID_E_RAB_TO_BE_SWITCHED_DL_ITEM: u16 = 23;

pub const ID_E_RAB_TO_BE_SWITCHED_DL_LIST: u16 = 22;

pub const ID_E_RAB_TO_BE_SWITCHED_UL_ITEM: u16 = 94;

pub const ID_E_RAB_TO_BE_SWITCHED_UL_LIST: u16 = 95;

pub const ID_E_RAB_USAGE_REPORT_ITEM: u16 = 267;

pub const ID_E_RA_BTO_RELEASE_LIST_HO_CMD: u16 = 13;

pub const ID_E_UTRAN_TRACE_ID: u16 = 86;

pub const ID_ECGI_LIST_FOR_RESTART: u16 = 182;

pub const ID_EDT_SESSION: u16 = 281;

pub const ID_EN_DCSON_CONFIGURATION_TRANSFER_ECT: u16 = 294;

pub const ID_EN_DCSON_CONFIGURATION_TRANSFER_MCT: u16 = 295;

pub const ID_ENB_CONFIGURATION_UPDATE: u8 = 29;

pub const ID_EUTRAN_CGI: u16 = 100;

pub const ID_EUTRAN_ROUND_TRIP_DELAY_ESTIMATION_INFO: u16 = 140;

pub const ID_EMERGENCY_AREA_ID_LIST_FOR_RESTART: u16 = 190;

pub const ID_EMERGENCY_INDICATOR: u16 = 326;

pub const ID_END_INDICATION: u16 = 280;

pub const ID_ENHANCED_COVERAGE_RESTRICTED: u16 = 251;

pub const ID_ERROR_INDICATION: u8 = 15;

pub const ID_ETHERNET_TYPE: u16 = 305;

pub const ID_EXPECTED_UE_BEHAVIOUR: u16 = 196;

pub const ID_EXTENDED_REPETITION_PERIOD: u16 = 144;

pub const ID_GERA_NTO_LTEHO_INFORMATION_RES: u16 = 55;

pub const ID_GUMMEI_ID: u16 = 75;

pub const ID_GUMMEI_LIST: u16 = 154;

pub const ID_GUMMEI_TYPE: u16 = 170;

pub const ID_GW_TRANSPORT_LAYER_ADDRESS: u16 = 155;

pub const ID_GW_CONTEXT_RELEASE_INDICATION: u16 = 164;

pub const ID_GLOBAL_ENB_ID: u16 = 59;

pub const ID_HO_CAUSE: u16 = 168;

pub const ID_HANDOVER_CANCEL: u8 = 4;

pub const ID_HANDOVER_FLAG: u16 = 266;

pub const ID_HANDOVER_NOTIFICATION: u8 = 2;

pub const ID_HANDOVER_PREPARATION: u8 = 0;

pub const ID_HANDOVER_RESOURCE_ALLOCATION: u8 = 1;

pub const ID_HANDOVER_RESTRICTION_LIST: u16 = 41;

pub const ID_HANDOVER_SUCCESS: u8 = 64;

pub const ID_HANDOVER_TYPE: u16 = 1;

pub const ID_IAB_AUTHORIZED: u16 = 301;

pub const ID_IAB_NODE_INDICATION: u16 = 302;

pub const ID_IAB_SUPPORTED: u16 = 303;

pub const ID_IM_SVOICE_EP_SFALLBACKFROM5_G: u16 = 296;

pub const ID_INFORMATION_ON_RECOMMENDED_CELLS_AND_EN_BS_FOR_PAGING: u16 = 213;

pub const ID_INITIAL_CONTEXT_SETUP: u8 = 9;

pub const ID_INTER_SYSTEM_INFORMATION_TRANSFER_TYPE_EDT: u16 = 121;

pub const ID_INTER_SYSTEM_INFORMATION_TRANSFER_TYPE_MDT: u16 = 122;

pub const ID_INTERSYSTEM_MEASUREMENT_CONFIGURATION: u16 = 311;

pub const ID_INTERSYSTEM_SON_CONFIGURATION_TRANSFER_ECT: u16 = 310;

pub const ID_INTERSYSTEM_SON_CONFIGURATION_TRANSFER_MCT: u16 = 309;

pub const ID_KILL: u8 = 43;

pub const ID_KILL_ALL_WARNING_MESSAGES: u16 = 191;

pub const ID_LHN_ID: u16 = 186;

pub const ID_LP_PA_PDU: u16 = 147;

pub const ID_LTE_M_INDICATION: u16 = 272;

pub const ID_LAST_NG_RANPLMN_IDENTITY: u16 = 290;

pub const ID_LOCATION_REPORT: u8 = 33;

pub const ID_LOCATION_REPORTING_CONTROL: u8 = 31;

pub const ID_LOCATION_REPORTING_FAILURE_INDICATION: u8 = 32;

pub const ID_LOGGED_MBSFNMDT: u16 = 197;

pub const ID_M3_CONFIGURATION: u16 = 171;

pub const ID_M4_CONFIGURATION: u16 = 172;

pub const ID_M5_CONFIGURATION: u16 = 173;

pub const ID_M6_CONFIGURATION: u16 = 220;

pub const ID_M7_CONFIGURATION: u16 = 221;

pub const ID_MDT_LOCATION_INFO: u16 = 174;

pub const ID_MDT_CONFIGURATION: u16 = 162;

pub const ID_MDT_CONFIGURATION_NR: u16 = 316;

pub const ID_MME_GROUP_ID: u16 = 223;

pub const ID_MME_UE_S1AP_ID: u16 = 0;

pub const ID_MME_UE_S1AP_ID_2: u16 = 158;

pub const ID_MMECP_RELOCATION_INDICATION: u8 = 61;

pub const ID_MME_CONFIGURATION_TRANSFER: u8 = 41;

pub const ID_MME_CONFIGURATION_UPDATE: u8 = 30;

pub const ID_MME_DIRECT_INFORMATION_TRANSFER: u8 = 38;

pub const ID_MME_EARLY_STATUS_TRANSFER: u8 = 66;

pub const ID_MME_RELAY_SUPPORT_INDICATOR: u16 = 163;

pub const ID_MME_STATUS_TRANSFER: u8 = 25;

pub const ID_MM_ENAME: u16 = 61;

pub const ID_MS_CLASSMARK2: u16 = 132;

pub const ID_MS_CLASSMARK3: u16 = 133;

pub const ID_MANAGEMENT_BASED_MDT_ALLOWED: u16 = 165;

pub const ID_MANAGEMENT_BASED_MDTPLMN_LIST: u16 = 177;

pub const ID_MASKED_IMEISV: u16 = 192;

pub const ID_MESSAGE_IDENTIFIER: u16 = 111;

pub const ID_MOBILITY_INFORMATION: u16 = 175;

pub const ID_MUTING_AVAILABILITY_INDICATION: u16 = 207;

pub const ID_MUTING_PATTERN_INFORMATION: u16 = 208;

pub const ID_NAS_DOWNLINK_COUNT: u16 = 126;

pub const ID_NAS_PDU: u16 = 26;

pub const ID_NAS_DELIVERY_INDICATION: u8 = 57;

pub const ID_NAS_NON_DELIVERY_INDICATION: u8 = 16;

pub const ID_NAS_SECURITY_PARAMETERSFROM_E_UTRAN: u16 = 135;

pub const ID_NAS_SECURITY_PARAMETERSTO_E_UTRAN: u16 = 136;

pub const ID_NB_IO_T_DEFAULT_PAGING_DRX: u16 = 234;

pub const ID_NB_IO_T_PAGING_E_DRX_INFORMATION: u16 = 239;

pub const ID_NB_IO_T_PAGING_DRX: u16 = 324;

pub const ID_NB_IO_T_RLF_REPORT_CONTAINER: u16 = 313;

pub const ID_NB_IO_T_UE_IDENTITY_INDEX_VALUE: u16 = 244;

pub const ID_NRUE_SECURITY_CAPABILITIES: u16 = 269;

pub const ID_NRUE_SIDELINK_AGGREGATE_MAXIMUM_BITRATE: u16 = 307;

pub const ID_NRV2X_SERVICES_AUTHORIZED: u16 = 306;

pub const ID_N_RRESTRICTIONIN5_GS: u16 = 287;

pub const ID_N_RRESTRICTIONIN_EP_SAS_SECONDARY_RAT: u16 = 261;

pub const ID_NOTIFY_SOURCEE_NB: u16 = 320;

pub const ID_NUMBEROF_BROADCAST_REQUEST: u16 = 115;

pub const ID_OVERLOAD_RESPONSE: u16 = 101;

pub const ID_OVERLOAD_START: u8 = 34;

pub const ID_OVERLOAD_STOP: u8 = 35;

pub const ID_PC5_QO_S_PARAMETERS: u16 = 308;

pub const ID_PS_SERVICE_NOT_AVAILABLE: u16 = 150;

pub const ID_PS_CELL_INFORMATION: u16 = 288;

pub const ID_PWS_FAILURE_INDICATION: u8 = 51;

pub const ID_PWS_RESTART_INDICATION: u8 = 49;

pub const ID_PW_SFAILED_ECGI_LIST: u16 = 222;

pub const ID_PAGING: u8 = 10;

pub const ID_PAGING_E_DRX_INFORMATION: u16 = 227;

pub const ID_PAGING_PRIORITY: u16 = 151;

pub const ID_PATH_SWITCH_REQUEST: u8 = 3;

pub const ID_PENDING_DATA_INDICATION: u16 = 283;

pub const ID_PRIVACY_INDICATOR: u16 = 166;

pub const ID_PRIVATE_MESSAGE: u8 = 39;

pub const ID_PRO_SE_AUTHORIZED: u16 = 195;

pub const ID_PRO_SE_U_ETO_NETWORK_RELAYING: u16 = 216;

pub const ID_RAT_TYPE: u16 = 232;

pub const ID_RRC_ESTABLISHMENT_CAUSE: u16 = 134;

pub const ID_RRC_RESUME_CAUSE: u16 = 245;

pub const ID_RECEIVE_STATUS_OF_ULPDCPSD_US_EXTENDED: u16 = 181;

pub const ID_RECEIVE_STATUS_OF_ULPDCPSD_US_PDCP_S_NLENGTH18: u16 = 219;

pub const ID_RECOMMENDED_CELL_ITEM: u16 = 214;

pub const ID_RECOMMENDED_ENB_ITEM: u16 = 215;

pub const ID_REGISTERED_LAI: u16 = 159;

pub const ID_RELATIVE_MME_CAPACITY: u16 = 87;

pub const ID_RELAY_NODE_INDICATOR: u16 = 160;

pub const ID_REPETITION_PERIOD: u16 = 114;

pub const ID_REQUEST_TYPE: u16 = 98;

pub const ID_REQUEST_TYPE_ADDITIONAL_INFO: u16 = 298;

pub const ID_REROUTE_NAS_REQUEST: u8 = 52;

pub const ID_RESET: u8 = 14;

pub const ID_RESET_TYPE: u16 = 92;

pub const ID_RETRIEVE_UE_INFORMATION: u8 = 58;

pub const ID_ROUTING_ID: u16 = 148;

pub const ID_S_TMSI: u16 = 96;

pub const ID_S1_MESSAGE: u16 = 225;

pub const ID_S1_SETUP: u8 = 17;

pub const ID_SIPTO_CORRELATION_ID: u16 = 183;

pub const ID_SIPTO_L_GW_TRANSPORT_LAYER_ADDRESS: u16 = 184;

pub const ID_SON_INFORMATION_REPORT: u16 = 206;

pub const ID_SON_CONFIGURATION_TRANSFER_ECT: u16 = 129;

pub const ID_SON_CONFIGURATION_TRANSFER_MCT: u16 = 130;

pub const ID_SRVCCHO_INDICATION: u16 = 125;

pub const ID_SRVCC_OPERATION_NOT_POSSIBLE: u16 = 243;

pub const ID_SRVCC_OPERATION_POSSIBLE: u16 = 124;

pub const ID_SECONDARY_RAT_DATA_USAGE_REPORT: u8 = 62;

pub const ID_SECONDARY_RAT_DATA_USAGE_REPORT_ITEM: u16 = 265;

pub const ID_SECONDARY_RAT_DATA_USAGE_REPORT_LIST: u16 = 264;

pub const ID_SECONDARY_RAT_DATA_USAGE_REQUEST: u16 = 268;

pub const ID_SECURITY_CONTEXT: u16 = 40;

pub const ID_SECURITY_KEY: u16 = 73;

pub const ID_SERIAL_NUMBER: u16 = 112;

pub const ID_SERVED_DC_NS: u16 = 247;

pub const ID_SERVED_GUMME_IS: u16 = 105;

pub const ID_SERVED_PLM_NS: u16 = 63;

pub const ID_SIGNALLING_BASED_MDTPLMN_LIST: u16 = 178;

pub const ID_SOURCE_TO_TARGET_TRANSPARENT_CONTAINER: u16 = 104;

pub const ID_SOURCE_TO_TARGET_TRANSPARENT_CONTAINER_SECONDARY: u16 = 138;

pub const ID_SOURCE_ID: u16 = 3;

pub const ID_SOURCE_MME_GUMMEI: u16 = 157;

pub const ID_SOURCE_MME_UE_S1AP_ID: u16 = 88;

pub const ID_SOURCE_NODE_ID: u16 = 312;

pub const ID_SUBSCRIBER_PROFILE_I_DFOR_RFP: u16 = 106;

pub const ID_SUBSCRIPTION_BASED_UE_DIFFERENTIATION_INFO: u16 = 278;

pub const ID_SUPPORTED_T_AS: u16 = 64;

pub const ID_SYNCHRONISATION_INFORMATION: u16 = 209;

pub const ID_TAI: u16 = 67;

pub const ID_TAI_ITEM: u16 = 47;

pub const ID_TAI_LIST: u16 = 46;

pub const ID_TAI_LIST_FOR_RESTART: u16 = 188;

pub const ID_TARGET_TO_SOURCE_TRANSPARENT_CONTAINER: u16 = 123;

pub const ID_TARGET_TO_SOURCE_TRANSPARENT_CONTAINER_SECONDARY: u16 = 139;

pub const ID_TARGET_ID: u16 = 4;

pub const ID_TIME_SYNCHRONISATION_INFO: u16 = 149;

pub const ID_TIME_UE_STAYED_IN_CELL_ENHANCED_GRANULARITY: u16 = 167;

pub const ID_TIME_SINCE_SECONDARY_NODE_RELEASE: u16 = 297;

pub const ID_TIME_TO_WAIT: u16 = 65;

pub const ID_TRACE_ACTIVATION: u16 = 25;

pub const ID_TRACE_COLLECTION_ENTITY_IP_ADDRESS: u16 = 131;

pub const ID_TRACE_COLLECTION_ENTITY_URI: u16 = 325;

pub const ID_TRACE_FAILURE_INDICATION: u8 = 28;

pub const ID_TRACE_START: u8 = 27;

pub const ID_TRAFFIC_LOAD_REDUCTION_INDICATION: u16 = 161;

pub const ID_TRANSPORT_INFORMATION: u16 = 185;

pub const ID_TUNNEL_INFORMATION_FOR_BBF: u16 = 176;

pub const ID_UE_APPLICATION_LAYER_MEASUREMENT_CAPABILITY: u16 = 263;

pub const ID_UE_LEVEL_QO_S_PARAMETERS: u16 = 252;

pub const ID_UE_RETENTION_INFORMATION: u16 = 228;

pub const ID_UE_S1AP_I_DS: u16 = 99;

pub const ID_UE_USAGE_TYPE: u16 = 230;

pub const ID_UE_ASSOCIATED_LOGICAL_S1_CONNECTION_ITEM: u16 = 91;

pub const ID_UE_ASSOCIATED_LOGICAL_S1_CONNECTION_LIST_RES_ACK: u16 = 93;

pub const ID_UE_APP_LAYER_MEAS_CONFIG: u16 = 262;

pub const ID_UE_CAPABILITY_INFO_INDICATION: u8 = 22;

pub const ID_UE_CAPABILITY_INFO_REQUEST: u16 = 275;

pub const ID_UE_CONTEXT_MODIFICATION: u8 = 21;

pub const ID_UE_CONTEXT_MODIFICATION_INDICATION: u8 = 53;

pub const ID_UE_CONTEXT_RELEASE: u8 = 23;

pub const ID_UE_CONTEXT_RELEASE_REQUEST: u8 = 18;

pub const ID_UE_CONTEXT_RESUME: u8 = 56;

pub const ID_UE_CONTEXT_SUSPEND: u8 = 55;

pub const ID_UE_IDENTITY_INDEX_VALUE: u16 = 80;

pub const ID_UE_INFORMATION_TRANSFER: u8 = 59;

pub const ID_UE_PAGING_ID: u16 = 43;

pub const ID_UE_RADIO_CAPABILITY: u16 = 74;

pub const ID_UE_RADIO_CAPABILITY_NR_FORMAT: u16 = 315;

pub const ID_UE_RADIO_CAPABILITY_FOR_PAGING: u16 = 198;

pub const ID_UE_RADIO_CAPABILITY_ID: u16 = 314;

pub const ID_UE_RADIO_CAPABILITY_ID_MAPPING: u8 = 63;

pub const ID_UE_RADIO_CAPABILITY_MATCH: u8 = 48;

pub const ID_UE_SECURITY_CAPABILITIES: u16 = 107;

pub const ID_UE_SIDELINK_AGGREGATE_MAXIMUM_BITRATE: u16 = 248;

pub const ID_UE_USER_PLANE_C_IO_T_SUPPORT_INDICATOR: u16 = 241;

pub const ID_UL_CP_SECURITY_INFORMATION: u16 = 254;

pub const ID_ULCOUNT_VALUE_EXTENDED: u16 = 179;

pub const ID_ULCOUNT_VALUE_PDCP_S_NLENGTH18: u16 = 217;

pub const ID_UTRA_NTO_LTEHO_INFORMATION_RES: u16 = 57;

pub const ID_UNLICENSED_SPECTRUM_RESTRICTION: u16 = 270;

pub const ID_UPLINK_PACKET_LOSS_RATE: u16 = 274;

pub const ID_UPLINK_S1CDMA2000TUNNELLING: u8 = 20;

pub const ID_USER_LOCATION_INFORMATION: u16 = 189;

pub const ID_V2X_SERVICES_AUTHORIZED: u16 = 240;

pub const ID_VOICE_SUPPORT_MATCH_INDICATOR: u16 = 169;

pub const ID_WLAN_MEASUREMENT_CONFIGURATION: u16 = 285;

pub const ID_WUS_ASSISTANCE_INFORMATION: u16 = 323;

pub const ID_WARNING_AREA_COORDINATES: u16 = 286;

pub const ID_WARNING_AREA_LIST: u16 = 113;

pub const ID_WARNING_MESSAGE_CONTENTS: u16 = 119;

pub const ID_WARNING_SECURITY_INFO: u16 = 117;

pub const ID_WARNING_TYPE: u16 = 116;

pub const ID_WRITE_REPLACE_WARNING: u8 = 36;

pub const ID_CDMA2000_HO_REQUIRED_INDICATION: u16 = 84;

pub const ID_CDMA2000_HO_STATUS: u16 = 83;

pub const ID_CDMA2000_ONE_XRAND: u16 = 97;

pub const ID_CDMA2000_ONE_XSRVCC_INFO: u16 = 102;

pub const ID_CDMA2000_PDU: u16 = 70;

pub const ID_CDMA2000_RAT_TYPE: u16 = 71;

pub const ID_CDMA2000_SECTOR_ID: u16 = 72;

pub const ID_DOWNLINK_NAS_TRANSPORT: u8 = 11;

pub const ID_DOWNLINK_NON_UE_ASSOCIATED_LP_PA_TRANSPORT: u8 = 46;

pub const ID_DOWNLINK_UE_ASSOCIATED_LP_PA_TRANSPORT: u8 = 44;

pub const ID_E_NB_EARLY_STATUS_TRANSFER_TRANSPARENT_CONTAINER: u16 = 321;

pub const ID_E_NB_STATUS_TRANSFER_TRANSPARENT_CONTAINER: u16 = 90;

pub const ID_E_NB_UE_S1AP_ID: u16 = 8;

pub const ID_E_NBCP_RELOCATION_INDICATION: u8 = 60;

pub const ID_E_NB_CONFIGURATION_TRANSFER: u8 = 40;

pub const ID_E_NB_DIRECT_INFORMATION_TRANSFER: u8 = 37;

pub const ID_E_NB_EARLY_STATUS_TRANSFER: u8 = 65;

pub const ID_E_NB_INDIRECT_X2_TRANSPORT_LAYER_ADDRESSES: u16 = 193;

pub const ID_E_NB_STATUS_TRANSFER: u8 = 24;

pub const ID_E_NBX2_EXTENDED_TRANSPORT_LAYER_ADDRESSES: u16 = 153;

pub const ID_E_N_BNAME: u16 = 60;

pub const ID_EXTENDED_UE_IDENTITY_INDEX_VALUE: u16 = 231;

pub const ID_EXTENDED_E_RAB_GUARANTEED_BITRATE_DL: u16 = 257;

pub const ID_EXTENDED_E_RAB_GUARANTEED_BITRATE_UL: u16 = 258;

pub const ID_EXTENDED_E_RAB_MAXIMUM_BITRATE_DL: u16 = 255;

pub const ID_EXTENDED_E_RAB_MAXIMUM_BITRATE_UL: u16 = 256;

pub const ID_EXTENDED_U_EAGGREGATE_MAXIMUM_BIT_RATE_DL: u16 = 259;

pub const ID_EXTENDED_U_EAGGREGATE_MAXIMUM_BIT_RATE_UL: u16 = 260;

pub const ID_INITIAL_UE_MESSAGE: u8 = 12;

pub const ID_PAGING_DRX: u16 = 44;

pub const ID_SERVICE_TYPE: u16 = 276;

pub const ID_U_E_HISTORY_INFORMATION_FROM_THE_UE: u16 = 194;

pub const ID_U_EAGGREGATE_MAXIMUM_BITRATE: u16 = 66;

pub const ID_UPLINK_NAS_TRANSPORT: u8 = 13;

pub const ID_UPLINK_NON_UE_ASSOCIATED_LP_PA_TRANSPORT: u8 = 47;

pub const ID_UPLINK_UE_ASSOCIATED_LP_PA_TRANSPORT: u8 = 45;

pub const ID_X2_TNL_CONFIGURATION_INFO: u16 = 152;

pub const MAX_EARFCN: i64 = 262143;

pub const MAX_NARFCN: i64 = 32;

pub const MAX_PRIVATE_I_ES: i64 = 65535;

pub const MAX_PROTOCOL_EXTENSIONS: i64 = 65535;

pub const MAX_PROTOCOL_I_ES: i64 = 65535;

pub const MAX_RS_INDEX_CELL_QUAL: i64 = 16;

pub const MAXNOOF_BPLM_NS: i64 = 6;

pub const MAXNOOF_BLUETOOTH_NAME: i64 = 4;

pub const MAXNOOF_CS_GS: i64 = 256;

pub const MAXNOOF_CELL_ID: i64 = 65535;

pub const MAXNOOF_CELL_I_DFOR_MDT: i64 = 32;

pub const MAXNOOF_CELL_I_DFOR_QMC: i64 = 32;

pub const MAXNOOF_CELLIN_EAI: i64 = 65535;

pub const MAXNOOF_CELLIN_TAI: i64 = 65535;

pub const MAXNOOF_CELLINE_NB: i64 = 256;

pub const MAXNOOF_CELLSFOR_RESTART: i64 = 256;

pub const MAXNOOF_CELLSIN_UE_HISTORY_INFO: i64 = 16;

pub const MAXNOOF_CELLSINE_NB: i64 = 256;

pub const MAXNOOF_CONNECTEDENG_N_BS: i64 = 256;

pub const MAXNOOF_DC_NS: i64 = 32;

pub const MAXNOOF_E_RA_BS: i64 = 256;

pub const MAXNOOF_EPLM_NS: i64 = 15;

pub const MAXNOOF_EPLM_NS_PLUS_ONE: i64 = 16;

pub const MAXNOOF_EMERGENCY_AREA_ID: i64 = 65535;

pub const MAXNOOF_ERRORS: i64 = 256;

pub const MAXNOOF_FORB_LA_CS: i64 = 4096;

pub const MAXNOOF_FORB_TA_CS: i64 = 4096;

pub const MAXNOOF_GROUP_I_DS: i64 = 65535;

pub const MAXNOOF_IRAT_REPORTING_CELLS: i64 = 128;

pub const MAXNOOF_INDIVIDUAL_S1_CONNECTIONS_TO_RESET: i64 = 256;

pub const MAXNOOF_MBSFN_AREA_MDT: i64 = 8;

pub const MAXNOOF_MDTPLM_NS: i64 = 16;

pub const MAXNOOF_MME_CS: i64 = 256;

pub const MAXNOOF_PC5_QO_S_FLOWS: i64 = 2048;

pub const MAXNOOF_PLM_NFOR_QMC: i64 = 16;

pub const MAXNOOF_PLM_NS_PER_MME: i64 = 32;

pub const MAXNOOF_RA_TS: i64 = 8;

pub const MAXNOOF_RECOMMENDED_CELLS: i64 = 16;

pub const MAXNOOF_RECOMMENDED_EN_BS: i64 = 16;

pub const MAXNOOF_RESTART_EMERGENCY_AREA_I_DS: i64 = 256;

pub const MAXNOOF_RESTART_TA_IS: i64 = 2048;

pub const MAXNOOF_TA_CS: i64 = 256;

pub const MAXNOOF_TA_IFOR_WARNING: i64 = 65535;

pub const MAXNOOF_TA_IS: i64 = 256;

pub const MAXNOOF_T_AFOR_MDT: i64 = 8;

pub const MAXNOOF_T_AFOR_QMC: i64 = 8;

pub const MAXNOOF_WLAN_NAME: i64 = 4;

pub const MAXNOOFCANDIDATE_CELLS: i64 = 16;

pub const MAXNOOFE_NBX2_EXT_TL_AS: i64 = 16;

pub const MAXNOOFE_NBX2GTPTL_AS: i64 = 16;

pub const MAXNOOFE_NBX2TL_AS: i64 = 2;

pub const MAXNOOFFREQUENCIES: i64 = 64;

pub const MAXNOOFTIMEPERIODS: i64 = 2;







#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    Eq,
    PartialEq,
    Debug,
    serde :: Serialize,
    Clone,
    serde :: Deserialize,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEPagingCoverageInformation {
    pub critical_extensions: UEPagingCoverageInformationCriticalExtensions,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    Eq,
    PartialEq,
    Debug,
    serde :: Serialize,
    Clone,
    serde :: Deserialize,
)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 2)]
pub struct UEPagingCoverageInformation_r13_IEs {
    #[asn(optional_idx = 0)]
    pub mpdcch_num_repetition_r13:
        Option<UEPagingCoverageInformation_r13_IEsMpdcch_NumRepetition_r13>,
    #[asn(optional_idx = 1)]
    pub non_critical_extension: Option<UEPagingCoverageInformation_r13_IEsNonCriticalExtension>,
}

impl<'a> arbitrary::Arbitrary<'a> for UEPagingCoverageInformation_r13_IEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(UEPagingCoverageInformation_r13_IEs {
            mpdcch_num_repetition_r13: u.arbitrary()?,
            non_critical_extension: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    Eq,
    PartialEq,
    Debug,
    serde :: Serialize,
    Clone,
    serde :: Deserialize,
)]
#[asn(type = "NULL")]
pub struct UEPagingCoverageInformationCriticalExtensions_c1_spare7;

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    Eq,
    PartialEq,
    Debug,
    serde :: Serialize,
    Clone,
    serde :: Deserialize,
)]
#[asn(type = "NULL")]
pub struct UEPagingCoverageInformationCriticalExtensions_c1_spare6;

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    Eq,
    PartialEq,
    Debug,
    serde :: Serialize,
    Clone,
    serde :: Deserialize,
)]
#[asn(type = "NULL")]
pub struct UEPagingCoverageInformationCriticalExtensions_c1_spare5;

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    Eq,
    PartialEq,
    Debug,
    serde :: Serialize,
    Clone,
    serde :: Deserialize,
)]
#[asn(type = "NULL")]
pub struct UEPagingCoverageInformationCriticalExtensions_c1_spare4;

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    Eq,
    PartialEq,
    Debug,
    serde :: Serialize,
    Clone,
    serde :: Deserialize,
)]
#[asn(type = "NULL")]
pub struct UEPagingCoverageInformationCriticalExtensions_c1_spare3;

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    Eq,
    PartialEq,
    Debug,
    serde :: Serialize,
    Clone,
    serde :: Deserialize,
)]
#[asn(type = "NULL")]
pub struct UEPagingCoverageInformationCriticalExtensions_c1_spare2;

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    Eq,
    PartialEq,
    Debug,
    serde :: Serialize,
    Clone,
    serde :: Deserialize,
)]
#[asn(type = "NULL")]
pub struct UEPagingCoverageInformationCriticalExtensions_c1_spare1;

#[derive(
    asn1_codecs_derive :: AperCodec,
    Eq,
    PartialEq,
    Debug,
    serde :: Serialize,
    Clone,
    serde :: Deserialize,
)]
#[asn(type = "CHOICE", lb = "0", ub = "7", extensible = false)]
pub enum UEPagingCoverageInformationCriticalExtensions_c1 {
    #[asn(key = 0, extended = false)]
    UePagingCoverageInformation_r13(UEPagingCoverageInformation_r13_IEs),
    #[asn(key = 1, extended = false)]
    Spare7(UEPagingCoverageInformationCriticalExtensions_c1_spare7),
    #[asn(key = 2, extended = false)]
    Spare6(UEPagingCoverageInformationCriticalExtensions_c1_spare6),
    #[asn(key = 3, extended = false)]
    Spare5(UEPagingCoverageInformationCriticalExtensions_c1_spare5),
    #[asn(key = 4, extended = false)]
    Spare4(UEPagingCoverageInformationCriticalExtensions_c1_spare4),
    #[asn(key = 5, extended = false)]
    Spare3(UEPagingCoverageInformationCriticalExtensions_c1_spare3),
    #[asn(key = 6, extended = false)]
    Spare2(UEPagingCoverageInformationCriticalExtensions_c1_spare2),
    #[asn(key = 7, extended = false)]
    Spare1(UEPagingCoverageInformationCriticalExtensions_c1_spare1),
}

impl<'a> arbitrary::Arbitrary<'a> for UEPagingCoverageInformationCriticalExtensions_c1 {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(UEPagingCoverageInformationCriticalExtensions_c1::UePagingCoverageInformation_r13(
            u.arbitrary()?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    Eq,
    PartialEq,
    Debug,
    serde :: Serialize,
    Clone,
    serde :: Deserialize,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEPagingCoverageInformationCriticalExtensions_criticalExtensionsFuture {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    Eq,
    PartialEq,
    Debug,
    serde :: Serialize,
    Clone,
    serde :: Deserialize,
)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum UEPagingCoverageInformationCriticalExtensions {
    #[asn(key = 0, extended = false)]
    C1(UEPagingCoverageInformationCriticalExtensions_c1),
    #[asn(key = 1, extended = false)]
    CriticalExtensionsFuture(
        UEPagingCoverageInformationCriticalExtensions_criticalExtensionsFuture,
    ),
}

impl<'a> arbitrary::Arbitrary<'a> for UEPagingCoverageInformationCriticalExtensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(UEPagingCoverageInformationCriticalExtensions::C1(
            u.arbitrary()?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    Eq,
    PartialEq,
    Debug,
    serde :: Serialize,
    Clone,
    serde :: Deserialize,
)]
#[asn(type = "INTEGER", lb = "1", ub = "256")]
pub struct UEPagingCoverageInformation_r13_IEsMpdcch_NumRepetition_r13(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for UEPagingCoverageInformation_r13_IEsMpdcch_NumRepetition_r13 {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(UEPagingCoverageInformation_r13_IEsMpdcch_NumRepetition_r13(
            u.int_in_range(1..=256)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    Eq,
    PartialEq,
    Debug,
    serde :: Serialize,
    Clone,
    serde :: Deserialize,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEPagingCoverageInformation_r13_IEsNonCriticalExtension {}











#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "256"
)]
pub struct ActivatedCellsList(pub Vec<ActivatedCellsList_Item>);
impl<'a> arbitrary::Arbitrary<'a> for ActivatedCellsList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ActivatedCellsList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ActivatedCellsList_Item {
    pub cell_id: ActivatedCellsList_ItemCell_ID,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Additional_GUTI {
    pub gummei: GUMMEI,
    pub m_tmsi: M_TMSI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Additional_GUTIIE_Extensions>,
}
impl<'a> arbitrary::Arbitrary<'a> for Additional_GUTI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Additional_GUTI {
            gummei: u.arbitrary()?,
            m_tmsi: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct AdditionalCSFallbackIndicator(pub u8);
impl AdditionalCSFallbackIndicator {
    pub const NO_RESTRICTION: u8 = 0u8;
    pub const RESTRICTION: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for AdditionalCSFallbackIndicator {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(AdditionalCSFallbackIndicator(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct AdditionalRRMPriorityIndex(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for AdditionalRRMPriorityIndex {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..32 {
            bv.push(u.arbitrary()?);
        }
        if 32 > 32 {
            for _ in 0..u.int_in_range(0..=32 - 32 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(AdditionalRRMPriorityIndex(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct AerialUEsubscriptionInformation(pub u8);
impl AerialUEsubscriptionInformation {
    pub const ALLOWED: u8 = 0u8;
    pub const NOT_ALLOWED: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for AerialUEsubscriptionInformation {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(AerialUEsubscriptionInformation(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AllocationAndRetentionPriority {
    pub priority_level: PriorityLevel,
    pub pre_emption_capability: Pre_emptionCapability,
    pub pre_emption_vulnerability: Pre_emptionVulnerability,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AllocationAndRetentionPriorityIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for AllocationAndRetentionPriority {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(AllocationAndRetentionPriority {
            priority_level: u.arbitrary()?,
            pre_emption_capability: u.arbitrary()?,
            pre_emption_vulnerability: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum AreaScopeOfMDT {
    #[asn(key = 0, extended = false)]
    CellBased(CellBasedMDT),
    #[asn(key = 1, extended = false)]
    TABased(TABasedMDT),
    #[asn(key = 2, extended = false)]
    PLMNWide(AreaScopeOfMDT_pLMNWide),
    // Encode of extended choice not yet implemented
    //#[asn(key = 0, extended = true)]
    //TAIBased(TAIBasedMDT),
    
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "3", extensible = true)]
pub enum AreaScopeOfQMC {
    #[asn(key = 0, extended = false)]
    CellBased(CellBasedQMC),
    #[asn(key = 1, extended = false)]
    TABased(TABasedQMC),
    #[asn(key = 2, extended = false)]
    TAIBased(TAIBasedQMC),
    #[asn(key = 3, extended = false)]
    PLMNAreaBased(PLMNAreaBasedQMC),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AssistanceDataForCECapableUEs {
    pub cell_identifier_and_ce_level_for_ce_capable_u_es: CellIdentifierAndCELevelForCECapableUEs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AssistanceDataForCECapableUEsIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for AssistanceDataForCECapableUEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(AssistanceDataForCECapableUEs {
            cell_identifier_and_ce_level_for_ce_capable_u_es: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct AssistanceDataForPaging {
    #[asn(optional_idx = 0)]
    pub assistance_data_for_recommended_cells: Option<AssistanceDataForRecommendedCells>,
    #[asn(optional_idx = 1)]
    pub assistance_data_for_ce_capable_u_es: Option<AssistanceDataForCECapableUEs>,
    #[asn(optional_idx = 2)]
    pub paging_attempt_information: Option<PagingAttemptInformation>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<AssistanceDataForPagingIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for AssistanceDataForPaging {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(AssistanceDataForPaging {
            assistance_data_for_recommended_cells: u.arbitrary()?,
            assistance_data_for_ce_capable_u_es: u.arbitrary()?,
            paging_attempt_information: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct AssistanceDataForRecommendedCells {
    pub recommended_cells_for_paging: RecommendedCellsForPaging,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<AssistanceDataForRecommendedCellsIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for AssistanceDataForRecommendedCells {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(AssistanceDataForRecommendedCells {
            recommended_cells_for_paging: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "6")]
pub struct BPLMNs(pub Vec<PLMNidentity>);
impl<'a> arbitrary::Arbitrary<'a> for BPLMNs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=6)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(BPLMNs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct BearerType(pub u8);
impl BearerType {
    pub const NON_IP: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for BearerType {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(BearerType(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Bearers_SubjectToEarlyStatusTransfer_Item {
    pub e_rab_id: E_RAB_ID,
    pub dlcount_pdcp_s_nlength: DLCOUNT_PDCP_SNlength,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Bearers_SubjectToEarlyStatusTransfer_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for Bearers_SubjectToEarlyStatusTransfer_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Bearers_SubjectToEarlyStatusTransfer_Item {
            e_rab_id: u.arbitrary()?,
            dlcount_pdcp_s_nlength: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct Bearers_SubjectToEarlyStatusTransferList(
    pub Vec<Bearers_SubjectToEarlyStatusTransferList_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for Bearers_SubjectToEarlyStatusTransferList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(Bearers_SubjectToEarlyStatusTransferList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct Bearers_SubjectToStatusTransfer_Item {
    pub e_rab_id: E_RAB_ID,
    pub ul_coun_tvalue: COUNTvalue,
    pub dl_coun_tvalue: COUNTvalue,
    #[asn(optional_idx = 0)]
    pub receive_statusof_ulpdcpsd_us: Option<ReceiveStatusofULPDCPSDUs>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<Bearers_SubjectToStatusTransfer_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for Bearers_SubjectToStatusTransfer_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Bearers_SubjectToStatusTransfer_Item {
            e_rab_id: u.arbitrary()?,
            ul_coun_tvalue: u.arbitrary()?,
            dl_coun_tvalue: u.arbitrary()?,
            receive_statusof_ulpdcpsd_us: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct Bearers_SubjectToStatusTransferList(pub Vec<Bearers_SubjectToStatusTransferList_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for Bearers_SubjectToStatusTransferList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(Bearers_SubjectToStatusTransferList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "10000000000")]
pub struct BitRate(pub u64);
impl<'a> arbitrary::Arbitrary<'a> for BitRate {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(BitRate(u.int_in_range(0..=10000000000)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct BluetoothMeasConfig(pub u8);
impl BluetoothMeasConfig {
    pub const SETUP: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for BluetoothMeasConfig {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(BluetoothMeasConfig(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct BluetoothMeasConfigNameList(pub Vec<BluetoothName>);
impl<'a> arbitrary::Arbitrary<'a> for BluetoothMeasConfigNameList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=4)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(BluetoothMeasConfigNameList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct BluetoothMeasurementConfiguration {
    pub bluetooth_meas_config: BluetoothMeasConfig,
    #[asn(optional_idx = 0)]
    pub bluetooth_meas_config_name_list: Option<BluetoothMeasConfigNameList>,
    #[asn(optional_idx = 1)]
    pub bt_rssi: Option<BluetoothMeasurementConfigurationBt_rssi>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<BluetoothMeasurementConfigurationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for BluetoothMeasurementConfiguration {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(BluetoothMeasurementConfiguration {
            bluetooth_meas_config: u.arbitrary()?,
            bluetooth_meas_config_name_list: u.arbitrary()?,
            bt_rssi: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}




#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "248"
)]
pub struct BluetoothName(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for BluetoothName {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=1)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(BluetoothName(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum BroadcastCancelledAreaList {
    #[asn(key = 0, extended = false)]
    CellID_Cancelled(CellID_Cancelled),
    #[asn(key = 1, extended = false)]
    TAI_Cancelled(TAI_Cancelled),
    #[asn(key = 2, extended = false)]
    EmergencyAreaID_Cancelled(EmergencyAreaID_Cancelled),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum BroadcastCompletedAreaList {
    #[asn(key = 0, extended = false)]
    CellID_Broadcast(CellID_Broadcast),
    #[asn(key = 1, extended = false)]
    TAI_Broadcast(TAI_Broadcast),
    #[asn(key = 2, extended = false)]
    EmergencyAreaID_Broadcast(EmergencyAreaID_Broadcast),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CE_ModeBRestricted(pub u8);
impl CE_ModeBRestricted {
    pub const RESTRICTED: u8 = 0u8;
    pub const NOT_RESTRICTED: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for CE_ModeBRestricted {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CE_ModeBRestricted(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CE_mode_B_SupportIndicator(pub u8);
impl CE_mode_B_SupportIndicator {
    pub const SUPPORTED: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for CE_mode_B_SupportIndicator {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CE_mode_B_SupportIndicator(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]

#[asn(type = "OCTET-STRING")]
pub struct CELevel(Vec<u8>);

use asn1_codecs::aper::AperCodec;

impl<'a> arbitrary::Arbitrary<'a> for CELevel {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let i: UEPagingCoverageInformation = u.arbitrary()?;
        let mut encoded = asn1_codecs::PerCodecData::new_aper();
        i.aper_encode(&mut encoded).unwrap();
        Ok(CELevel(encoded.into_bytes()))
    }
}



#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct CGI {
    pub plm_nidentity: PLMNidentity,
    pub lac: LAC,
    pub ci: CI,
    #[asn(optional_idx = 0)]
    pub rac: Option<RAC>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<CGIIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CGI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CGI {
            plm_nidentity: u.arbitrary()?,
            lac: u.arbitrary()?,
            ci: u.arbitrary()?,
            rac: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct CI(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for CI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(2, std::cmp::min(10, u.int_in_range(2..=2)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(CI(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CNDomain(pub u8);
impl CNDomain {
    pub const PS: u8 = 0u8;
    pub const CS: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for CNDomain {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CNDomain(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CNType(pub u8);
impl CNType {
    pub const FIVE_GC_FORBIDDEN: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for CNType {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CNType(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CNTypeRestrictions(pub Vec<CNTypeRestrictions_Item>);
impl<'a> arbitrary::Arbitrary<'a> for CNTypeRestrictions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=16)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CNTypeRestrictions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CNTypeRestrictions_Item {
    pub plmn_identity: PLMNidentity,
    pub cn_type: CNType,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CNTypeRestrictions_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CNTypeRestrictions_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CNTypeRestrictions_Item {
            plmn_identity: u.arbitrary()?,
            cn_type: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct COUNTValueExtended {
    pub pdcp_sn_extended: PDCP_SNExtended,
    pub hfn_modified: HFNModified,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<COUNTValueExtendedIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for COUNTValueExtended {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(COUNTValueExtended {
            pdcp_sn_extended: u.arbitrary()?,
            hfn_modified: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct COUNTvalue {
    pub pdcp_sn: PDCP_SN,
    pub hfn: HFN,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<COUNTvalueIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for COUNTvalue {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(COUNTvalue {
            pdcp_sn: u.arbitrary()?,
            hfn: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct COUNTvaluePDCP_SNlength18 {
    pub pdcp_s_nlength18: PDCP_SNlength18,
    pub hf_nfor_pdcp_s_nlength18: HFNforPDCP_SNlength18,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<COUNTvaluePDCP_SNlength18IE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for COUNTvaluePDCP_SNlength18 {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(COUNTvaluePDCP_SNlength18 {
            pdcp_s_nlength18: u.arbitrary()?,
            hf_nfor_pdcp_s_nlength18: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CSFallbackIndicator(pub u8);
impl CSFallbackIndicator {
    pub const CS_FALLBACK_REQUIRED: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for CSFallbackIndicator {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CSFallbackIndicator(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "27", sz_ub = "27")]
pub struct CSG_Id(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for CSG_Id {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..27 {
            bv.push(u.arbitrary()?);
        }
        if 27 > 27 {
            for _ in 0..u.int_in_range(0..=27 - 27 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(CSG_Id(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CSG_IdList(pub Vec<CSG_IdList_Item>);
impl<'a> arbitrary::Arbitrary<'a> for CSG_IdList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CSG_IdList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CSG_IdList_Item {
    pub csg_id: CSG_Id,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CSG_IdList_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CSG_IdList_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CSG_IdList_Item {
            csg_id: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct CSGMembershipInfo {
    pub csg_membership_status: CSGMembershipStatus,
    pub csg_id: CSG_Id,
    #[asn(optional_idx = 0)]
    pub cell_access_mode: Option<CellAccessMode>,
    #[asn(optional_idx = 1)]
    pub plm_nidentity: Option<PLMNidentity>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<CSGMembershipInfoIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CSGMembershipInfo {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CSGMembershipInfo {
            csg_membership_status: u.arbitrary()?,
            csg_id: u.arbitrary()?,
            cell_access_mode: u.arbitrary()?,
            plm_nidentity: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct CSGMembershipStatus(pub u8);
impl CSGMembershipStatus {
    pub const MEMBER: u8 = 0u8;
    pub const NOT_MEMBER: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for CSGMembershipStatus {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CSGMembershipStatus(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellinEAI(pub Vec<CancelledCellinEAI_Item>);
impl<'a> arbitrary::Arbitrary<'a> for CancelledCellinEAI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CancelledCellinEAI(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CancelledCellinEAI_Item {
    pub ecgi: EUTRAN_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CancelledCellinEAI_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CancelledCellinEAI_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CancelledCellinEAI_Item {
            ecgi: u.arbitrary()?,
            number_of_broadcasts: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellinTAI(pub Vec<CancelledCellinTAI_Item>);
impl<'a> arbitrary::Arbitrary<'a> for CancelledCellinTAI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CancelledCellinTAI(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CancelledCellinTAI_Item {
    pub ecgi: EUTRAN_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CancelledCellinTAI_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CancelledCellinTAI_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CancelledCellinTAI_Item {
            ecgi: u.arbitrary()?,
            number_of_broadcasts: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CandidateCellList(pub Vec<IRAT_Cell_ID>);
impl<'a> arbitrary::Arbitrary<'a> for CandidateCellList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=16)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CandidateCellList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CandidatePCI {
    pub pci: CandidatePCIPCI,
    pub earfcn: CandidatePCIEARFCN,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct CandidatePCIList(pub Vec<CandidatePCI>);
impl<'a> arbitrary::Arbitrary<'a> for CandidatePCIList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=16)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CandidatePCIList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "4", extensible = true)]
pub enum Cause {
    #[asn(key = 0, extended = false)]
    RadioNetwork(CauseRadioNetwork),
    #[asn(key = 1, extended = false)]
    Transport(CauseTransport),
    #[asn(key = 2, extended = false)]
    Nas(CauseNas),
    #[asn(key = 3, extended = false)]
    Protocol(CauseProtocol),
    #[asn(key = 4, extended = false)]
    Misc(CauseMisc),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct CauseMisc(pub u8);
impl CauseMisc {
    pub const CONTROL_PROCESSING_OVERLOAD: u8 = 0u8;
    pub const NOT_ENOUGH_USER_PLANE_PROCESSING_RESOURCES: u8 = 1u8;
    pub const HARDWARE_FAILURE: u8 = 2u8;
    pub const OM_INTERVENTION: u8 = 3u8;
    pub const UNSPECIFIED: u8 = 4u8;
    pub const UNKNOWN_PLMN: u8 = 5u8;
}
impl<'a> arbitrary::Arbitrary<'a> for CauseMisc {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CauseMisc(u.int_in_range(0..=5)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct CauseNas(pub u8);
impl CauseNas {
    pub const NORMAL_RELEASE: u8 = 0u8;
    pub const AUTHENTICATION_FAILURE: u8 = 1u8;
    pub const DETACH: u8 = 2u8;
    pub const UNSPECIFIED: u8 = 3u8;
}
impl<'a> arbitrary::Arbitrary<'a> for CauseNas {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CauseNas(u.int_in_range(0..=3)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "6")]
pub struct CauseProtocol(pub u8);
impl CauseProtocol {
    pub const TRANSFER_SYNTAX_ERROR: u8 = 0u8;
    pub const ABSTRACT_SYNTAX_ERROR_REJECT: u8 = 1u8;
    pub const ABSTRACT_SYNTAX_ERROR_IGNORE_AND_NOTIFY: u8 = 2u8;
    pub const MESSAGE_NOT_COMPATIBLE_WITH_RECEIVER_STATE: u8 = 3u8;
    pub const SEMANTIC_ERROR: u8 = 4u8;
    pub const ABSTRACT_SYNTAX_ERROR_FALSELY_CONSTRUCTED_MESSAGE: u8 = 5u8;
    pub const UNSPECIFIED: u8 = 6u8;
}
impl<'a> arbitrary::Arbitrary<'a> for CauseProtocol {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CauseProtocol(u.int_in_range(0..=6)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "35")]
pub struct CauseRadioNetwork(pub u8);
impl CauseRadioNetwork {
    pub const UNSPECIFIED: u8 = 0u8;
    pub const TX2RELOCOVERALL_EXPIRY: u8 = 1u8;
    pub const SUCCESSFUL_HANDOVER: u8 = 2u8;
    pub const RELEASE_DUE_TO_EUTRAN_GENERATED_REASON: u8 = 3u8;
    pub const HANDOVER_CANCELLED: u8 = 4u8;
    pub const PARTIAL_HANDOVER: u8 = 5u8;
    pub const HO_FAILURE_IN_TARGET_EPC_E_NB_OR_TARGET_SYSTEM: u8 = 6u8;
    pub const HO_TARGET_NOT_ALLOWED: u8 = 7u8;
    pub const T_S1RELOCOVERALL_EXPIRY: u8 = 8u8;
    pub const T_S1RELOCPREP_EXPIRY: u8 = 9u8;
    pub const CELL_NOT_AVAILABLE: u8 = 10u8;
    pub const UNKNOWN_TARGET_ID: u8 = 11u8;
    pub const NO_RADIO_RESOURCES_AVAILABLE_IN_TARGET_CELL: u8 = 12u8;
    pub const UNKNOWN_MME_UE_S1AP_ID: u8 = 13u8;
    pub const UNKNOWN_ENB_UE_S1AP_ID: u8 = 14u8;
    pub const UNKNOWN_PAIR_UE_S1AP_ID: u8 = 15u8;
    pub const HANDOVER_DESIRABLE_FOR_RADIO_REASON: u8 = 16u8;
    pub const TIME_CRITICAL_HANDOVER: u8 = 17u8;
    pub const RESOURCE_OPTIMISATION_HANDOVER: u8 = 18u8;
    pub const REDUCE_LOAD_IN_SERVING_CELL: u8 = 19u8;
    pub const USER_INACTIVITY: u8 = 20u8;
    pub const RADIO_CONNECTION_WITH_UE_LOST: u8 = 21u8;
    pub const LOAD_BALANCING_TAU_REQUIRED: u8 = 22u8;
    pub const CS_FALLBACK_TRIGGERED: u8 = 23u8;
    pub const UE_NOT_AVAILABLE_FOR_PS_SERVICE: u8 = 24u8;
    pub const RADIO_RESOURCES_NOT_AVAILABLE: u8 = 25u8;
    pub const FAILURE_IN_RADIO_INTERFACE_PROCEDURE: u8 = 26u8;
    pub const INVALID_QOS_COMBINATION: u8 = 27u8;
    pub const INTERRAT_REDIRECTION: u8 = 28u8;
    pub const INTERACTION_WITH_OTHER_PROCEDURE: u8 = 29u8;
    pub const UNKNOWN_E_RAB_ID: u8 = 30u8;
    pub const MULTIPLE_E_RAB_ID_INSTANCES: u8 = 31u8;
    pub const ENCRYPTION_AND_OR_INTEGRITY_PROTECTION_ALGORITHMS_NOT_SUPPORTED: u8 = 32u8;
    pub const S1_INTRA_SYSTEM_HANDOVER_TRIGGERED: u8 = 33u8;
    pub const S1_INTER_SYSTEM_HANDOVER_TRIGGERED: u8 = 34u8;
    pub const X2_HANDOVER_TRIGGERED: u8 = 35u8;
}
impl<'a> arbitrary::Arbitrary<'a> for CauseRadioNetwork {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CauseRadioNetwork(u.int_in_range(0..=35)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct CauseTransport(pub u8);
impl CauseTransport {
    pub const TRANSPORT_RESOURCE_UNAVAILABLE: u8 = 0u8;
    pub const UNSPECIFIED: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for CauseTransport {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CauseTransport(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Cdma2000HORequiredIndication(pub u8);
impl Cdma2000HORequiredIndication {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Cdma2000HORequiredIndication {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Cdma2000HORequiredIndication(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Cdma2000HOStatus(pub u8);
impl Cdma2000HOStatus {
    pub const H_O_SUCCESS: u8 = 0u8;
    pub const H_O_FAILURE: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Cdma2000HOStatus {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Cdma2000HOStatus(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct Cdma2000OneXMEID(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct Cdma2000OneXMSI(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct Cdma2000OneXPilot(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct Cdma2000OneXRAND(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Cdma2000OneXSRVCCInfo {
    pub cdma2000_one_xmeid: Cdma2000OneXMEID,
    pub cdma2000_one_xmsi: Cdma2000OneXMSI,
    pub cdma2000_one_x_pilot: Cdma2000OneXPilot,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Cdma2000OneXSRVCCInfoIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for Cdma2000OneXSRVCCInfo {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Cdma2000OneXSRVCCInfo {
            cdma2000_one_xmeid: u.arbitrary()?,
            cdma2000_one_xmsi: u.arbitrary()?,
            cdma2000_one_x_pilot: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct Cdma2000PDU(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Cdma2000RATType(pub u8);
impl Cdma2000RATType {
    pub const H_RPD: u8 = 0u8;
    pub const ONEX_RTT: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Cdma2000RATType {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Cdma2000RATType(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct Cdma2000SectorID(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct Cell_Size(pub u8);
impl Cell_Size {
    pub const VERYSMALL: u8 = 0u8;
    pub const SMALL: u8 = 1u8;
    pub const MEDIUM: u8 = 2u8;
    pub const LARGE: u8 = 3u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Cell_Size {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Cell_Size(u.int_in_range(0..=3)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct CellAccessMode(pub u8);
impl CellAccessMode {
    pub const HYBRID: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for CellAccessMode {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CellAccessMode(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct CellActivationCause(pub u8);
impl CellActivationCause {
    pub const APPLICATION_CONTAINER_SYNTAX_ERROR: u8 = 0u8;
    pub const INCONSISTENT_REPORTING_CELL_IDENTIFIER: u8 = 1u8;
    pub const UNSPECIFIED: u8 = 2u8;
}
impl<'a> arbitrary::Arbitrary<'a> for CellActivationCause {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CellActivationCause(u.int_in_range(0..=2)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellActivationRequest {
    pub cells_to_activate_list: CellsToActivateList,
    #[asn(optional_idx = 0)]
    pub minimum_activation_time: Option<CellActivationRequestMinimumActivationTime>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CellActivationResponse {
    pub activated_cells_list: ActivatedCellsList,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellBasedMDT {
    pub cell_id_listfor_mdt: CellIdListforMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellBasedMDTIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CellBasedMDT {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CellBasedMDT {
            cell_id_listfor_mdt: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellBasedQMC {
    pub cell_id_listfor_qmc: CellIdListforQMC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellBasedQMCIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CellBasedQMC {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CellBasedQMC {
            cell_id_listfor_qmc: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellID_Broadcast(pub Vec<CellID_Broadcast_Item>);
impl<'a> arbitrary::Arbitrary<'a> for CellID_Broadcast {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CellID_Broadcast(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellID_Broadcast_Item {
    pub ecgi: EUTRAN_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellID_Broadcast_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CellID_Broadcast_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CellID_Broadcast_Item {
            ecgi: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellID_Cancelled(pub Vec<CellID_Cancelled_Item>);
impl<'a> arbitrary::Arbitrary<'a> for CellID_Cancelled {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CellID_Cancelled(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellID_Cancelled_Item {
    pub ecgi: EUTRAN_CGI,
    pub number_of_broadcasts: NumberOfBroadcasts,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellID_Cancelled_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CellID_Cancelled_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CellID_Cancelled_Item {
            ecgi: u.arbitrary()?,
            number_of_broadcasts: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellIdListforMDT(pub Vec<EUTRAN_CGI>);
impl<'a> arbitrary::Arbitrary<'a> for CellIdListforMDT {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=32)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CellIdListforMDT(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct CellIdListforQMC(pub Vec<EUTRAN_CGI>);
impl<'a> arbitrary::Arbitrary<'a> for CellIdListforQMC {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=32)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CellIdListforQMC(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellIdentifierAndCELevelForCECapableUEs {
    pub global_cell_id: EUTRAN_CGI,
    pub ce_level: CELevel,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellIdentifierAndCELevelForCECapableUEsIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CellIdentifierAndCELevelForCECapableUEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CellIdentifierAndCELevelForCECapableUEs {
            global_cell_id: u.arbitrary()?,
            ce_level: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "28", sz_ub = "28")]
pub struct CellIdentity(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for CellIdentity {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..28 {
            bv.push(u.arbitrary()?);
        }
        if 28 > 28 {
            for _ in 0..u.int_in_range(0..=28 - 28 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(CellIdentity(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct CellLoadReportingCause(pub u8);
impl CellLoadReportingCause {
    pub const APPLICATION_CONTAINER_SYNTAX_ERROR: u8 = 0u8;
    pub const INCONSISTENT_REPORTING_CELL_IDENTIFIER: u8 = 1u8;
    pub const UNSPECIFIED: u8 = 2u8;
}
impl<'a> arbitrary::Arbitrary<'a> for CellLoadReportingCause {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CellLoadReportingCause(u.int_in_range(0..=2)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum CellLoadReportingResponse {
    #[asn(key = 0, extended = false)]
    EUTRAN(EUTRANcellLoadReportingResponse),
    #[asn(key = 1, extended = false)]
    UTRAN(CellLoadReportingResponse_uTRAN),
    #[asn(key = 2, extended = false)]
    GERAN(CellLoadReportingResponse_gERAN),
    // Encode of extended choice not yet implemented
    //#[asn(key = 0, extended = true)]
    //EHRPD(EHRPDSectorLoadReportingResponse),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CellStateIndication {
    pub notification_cell_list: NotificationCellList,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct CellStateIndicationCause(pub u8);
impl CellStateIndicationCause {
    pub const APPLICATION_CONTAINER_SYNTAX_ERROR: u8 = 0u8;
    pub const INCONSISTENT_REPORTING_CELL_IDENTIFIER: u8 = 1u8;
    pub const UNSPECIFIED: u8 = 2u8;
}
impl<'a> arbitrary::Arbitrary<'a> for CellStateIndicationCause {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CellStateIndicationCause(u.int_in_range(0..=2)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CellTrafficTrace {
    pub protocol_i_es: CellTrafficTraceProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CellType {
    pub cell_size: Cell_Size,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CellTypeIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CellType {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CellType {
            cell_size: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CellsToActivateList(pub Vec<CellsToActivateList_Item>);
impl<'a> arbitrary::Arbitrary<'a> for CellsToActivateList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CellsToActivateList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct CellsToActivateList_Item {
    pub cell_id: CellsToActivateList_ItemCell_ID,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellinEAI(pub Vec<CompletedCellinEAI_Item>);
impl<'a> arbitrary::Arbitrary<'a> for CompletedCellinEAI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CompletedCellinEAI(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CompletedCellinEAI_Item {
    pub ecgi: EUTRAN_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CompletedCellinEAI_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CompletedCellinEAI_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CompletedCellinEAI_Item {
            ecgi: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellinTAI(pub Vec<CompletedCellinTAI_Item>);
impl<'a> arbitrary::Arbitrary<'a> for CompletedCellinTAI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CompletedCellinTAI(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CompletedCellinTAI_Item {
    pub ecgi: EUTRAN_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CompletedCellinTAI_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CompletedCellinTAI_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CompletedCellinTAI_Item {
            ecgi: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct CompositeAvailableCapacityGroup(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct ConcurrentWarningMessageIndicator(pub u8);
impl ConcurrentWarningMessageIndicator {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for ConcurrentWarningMessageIndicator {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ConcurrentWarningMessageIndicator(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ConnectedengNBItem {
    pub en_g_nb_id: En_gNB_ID,
    pub supported_t_as: SupportedTAs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ConnectedengNBItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for ConnectedengNBItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ConnectedengNBItem {
            en_g_nb_id: u.arbitrary()?,
            supported_t_as: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ConnectedengNBList(pub Vec<ConnectedengNBItem>);
impl<'a> arbitrary::Arbitrary<'a> for ConnectedengNBList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ConnectedengNBList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ConnectionEstablishmentIndication {
    pub protocol_i_es: ConnectionEstablishmentIndicationProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ContextatSource {
    pub source_ng_ran_node_id: Global_RAN_NODE_ID,
    pub ran_ue_ngap_id: RAN_UE_NGAP_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ContextatSourceIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for ContextatSource {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ContextatSource {
            source_ng_ran_node_id: u.arbitrary()?,
            ran_ue_ngap_id: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct Correlation_ID(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for Correlation_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(4, std::cmp::min(10, u.int_in_range(4..=4)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(Correlation_ID(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Coverage_Level(pub u8);
impl Coverage_Level {
    pub const EXTENDEDCOVERAGE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Coverage_Level {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Coverage_Level(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct Criticality(pub u8);
impl Criticality {
    pub const REJECT: u8 = 0u8;
    pub const IGNORE: u8 = 1u8;
    pub const NOTIFY: u8 = 2u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Criticality {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Criticality(u.int_in_range(0..=2)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct CriticalityDiagnostics {
    #[asn(optional_idx = 0)]
    pub procedure_code: Option<ProcedureCode>,
    #[asn(optional_idx = 1)]
    pub triggering_message: Option<TriggeringMessage>,
    #[asn(optional_idx = 2)]
    pub procedure_criticality: Option<Criticality>,
    #[asn(optional_idx = 3)]
    pub i_es_criticality_diagnostics: Option<CriticalityDiagnostics_IE_List>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<CriticalityDiagnosticsIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CriticalityDiagnostics {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CriticalityDiagnostics {
            procedure_code: u.arbitrary()?,
            triggering_message: u.arbitrary()?,
            procedure_criticality: u.arbitrary()?,
            i_es_criticality_diagnostics: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct CriticalityDiagnostics_IE_Item {
    pub ie_criticality: Criticality,
    pub ie_id: ProtocolIE_ID,
    pub type_of_error: TypeOfError,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<CriticalityDiagnostics_IE_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for CriticalityDiagnostics_IE_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CriticalityDiagnostics_IE_Item {
            ie_criticality: u.arbitrary()?,
            ie_id: u.arbitrary()?,
            type_of_error: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct CriticalityDiagnostics_IE_List(pub Vec<CriticalityDiagnostics_IE_Item>);
impl<'a> arbitrary::Arbitrary<'a> for CriticalityDiagnostics_IE_List {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CriticalityDiagnostics_IE_List(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DAPSRequestInfo {
    pub daps_indicator: DAPSRequestInfoDAPSIndicator,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DAPSRequestInfoIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for DAPSRequestInfo {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(DAPSRequestInfo {
            daps_indicator: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DAPSResponseInfo {
    pub dapsresponseindicator: DAPSResponseInfoDapsresponseindicator,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DAPSResponseInfoIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for DAPSResponseInfo {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(DAPSResponseInfo {
            dapsresponseindicator: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DAPSResponseInfoItem {
    pub e_rab_id: E_RAB_ID,
    pub daps_response_info: DAPSResponseInfo,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DAPSResponseInfoItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for DAPSResponseInfoItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(DAPSResponseInfoItem {
            e_rab_id: u.arbitrary()?,
            daps_response_info: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct DAPSResponseInfoList(pub Vec<DAPSResponseInfoList_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for DAPSResponseInfoList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(DAPSResponseInfoList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct DCN_ID(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for DCN_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(DCN_ID(u.int_in_range(0..=65535)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct DL_CP_SecurityInformation {
    pub dl_nas_mac: DL_NAS_MAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<DL_CP_SecurityInformationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for DL_CP_SecurityInformation {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(DL_CP_SecurityInformation {
            dl_nas_mac: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DL_Forwarding(pub u8);
impl DL_Forwarding {
    pub const D_L_FORWARDING_PROPOSED: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for DL_Forwarding {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(DL_Forwarding(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct DL_NAS_MAC(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for DL_NAS_MAC {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..16 {
            bv.push(u.arbitrary()?);
        }
        if 16 > 16 {
            for _ in 0..u.int_in_range(0..=16 - 16 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(DL_NAS_MAC(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum DLCOUNT_PDCP_SNlength {
    #[asn(key = 0, extended = false)]
    DLCOUNTValuePDCP_SNlength12(COUNTvalue),
    #[asn(key = 1, extended = false)]
    DLCOUNTValuePDCP_SNlength15(COUNTValueExtended),
    #[asn(key = 2, extended = false)]
    DLCOUNTValuePDCP_SNlength18(COUNTvaluePDCP_SNlength18),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DLNASPDUDeliveryAckRequest(pub u8);
impl DLNASPDUDeliveryAckRequest {
    pub const REQUESTED: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for DLNASPDUDeliveryAckRequest {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(DLNASPDUDeliveryAckRequest(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Data_Forwarding_Not_Possible(pub u8);
impl Data_Forwarding_Not_Possible {
    pub const DATA_FORWARDING_NOT_POSSIBLE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Data_Forwarding_Not_Possible {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Data_Forwarding_Not_Possible(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct DataCodingScheme(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for DataCodingScheme {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..8 {
            bv.push(u.arbitrary()?);
        }
        if 8 > 8 {
            for _ in 0..u.int_in_range(0..=8 - 8 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(DataCodingScheme(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "1", ub = "4095", extensible = true)]
pub struct DataSize(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for DataSize {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(DataSize(u.int_in_range(1..=4095)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DeactivateTrace {
    pub protocol_i_es: DeactivateTraceProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Direct_Forwarding_Path_Availability(pub u8);
impl Direct_Forwarding_Path_Availability {
    pub const DIRECT_PATH_AVAILABLE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Direct_Forwarding_Path_Availability {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Direct_Forwarding_Path_Availability(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkNASTransport {
    pub protocol_i_es: DownlinkNASTransportProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkNonUEAssociatedLPPaTransport {
    pub protocol_i_es: DownlinkNonUEAssociatedLPPaTransportProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkS1cdma2000tunnelling {
    pub protocol_i_es: DownlinkS1cdma2000tunnellingProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct DownlinkUEAssociatedLPPaTransport {
    pub protocol_i_es: DownlinkUEAssociatedLPPaTransportProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "15", extensible = true)]
pub struct E_RAB_ID(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for E_RAB_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RAB_ID(u.int_in_range(0..=15)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct E_RABAdmittedItem {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub dl_transport_layer_address: Option<TransportLayerAddress>,
    #[asn(optional_idx = 1)]
    pub dl_g_tp_teid: Option<GTP_TEID>,
    #[asn(optional_idx = 2)]
    pub ul_transport_layer_address: Option<TransportLayerAddress>,
    #[asn(optional_idx = 3)]
    pub ul_gtp_teid: Option<GTP_TEID>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<E_RABAdmittedItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABAdmittedItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABAdmittedItem {
            e_rab_id: u.arbitrary()?,
            transport_layer_address: u.arbitrary()?,
            gtp_teid: u.arbitrary()?,
            dl_transport_layer_address: u.arbitrary()?,
            dl_g_tp_teid: u.arbitrary()?,
            ul_transport_layer_address: u.arbitrary()?,
            ul_gtp_teid: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABAdmittedList(pub Vec<E_RABAdmittedList_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABAdmittedList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABAdmittedList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct E_RABDataForwardingItem {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub dl_transport_layer_address: Option<TransportLayerAddress>,
    #[asn(optional_idx = 1)]
    pub dl_g_tp_teid: Option<GTP_TEID>,
    #[asn(optional_idx = 2)]
    pub ul_transport_layer_address: Option<TransportLayerAddress>,
    #[asn(optional_idx = 3)]
    pub ul_gtp_teid: Option<GTP_TEID>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<E_RABDataForwardingItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABDataForwardingItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABDataForwardingItem {
            e_rab_id: u.arbitrary()?,
            dl_transport_layer_address: u.arbitrary()?,
            dl_g_tp_teid: u.arbitrary()?,
            ul_transport_layer_address: u.arbitrary()?,
            ul_gtp_teid: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABFailedToResumeItemResumeReq {
    pub e_rab_id: E_RAB_ID,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABFailedToResumeItemResumeReqIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABFailedToResumeItemResumeReq {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABFailedToResumeItemResumeReq {
            e_rab_id: u.arbitrary()?,
            cause: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABFailedToResumeItemResumeRes {
    pub e_rab_id: E_RAB_ID,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABFailedToResumeItemResumeResIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABFailedToResumeItemResumeRes {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABFailedToResumeItemResumeRes {
            e_rab_id: u.arbitrary()?,
            cause: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABFailedToResumeListResumeReq(pub Vec<E_RABFailedToResumeListResumeReq_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABFailedToResumeListResumeReq {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABFailedToResumeListResumeReq(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABFailedToResumeListResumeRes(pub Vec<E_RABFailedToResumeListResumeRes_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABFailedToResumeListResumeRes {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABFailedToResumeListResumeRes(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABFailedToSetupItemHOReqAck {
    pub e_rab_id: E_RAB_ID,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABFailedToSetupItemHOReqAckIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABFailedToSetupItemHOReqAck {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABFailedToSetupItemHOReqAck {
            e_rab_id: u.arbitrary()?,
            cause: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABFailedtoSetupListHOReqAck(pub Vec<E_RABFailedtoSetupListHOReqAck_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABFailedtoSetupListHOReqAck {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABFailedtoSetupListHOReqAck(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABInformationList(pub Vec<E_RABInformationList_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABInformationList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABInformationList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABInformationListItem {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub dl_forwarding: Option<DL_Forwarding>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABInformationListItemIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABItem {
    pub e_rab_id: E_RAB_ID,
    pub cause: Cause,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABItem {
            e_rab_id: u.arbitrary()?,
            cause: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABLevelQoSParameters {
    pub qci: QCI,
    pub allocation_retention_priority: AllocationAndRetentionPriority,
    #[asn(optional_idx = 0)]
    pub gbr_qos_information: Option<GBR_QosInformation>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABLevelQoSParametersIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABList(pub Vec<E_RABList_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABModificationConfirm {
    pub protocol_i_es: E_RABModificationConfirmProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABModificationIndication {
    pub protocol_i_es: E_RABModificationIndicationProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABModifyItemBearerModConf {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABModifyItemBearerModConfIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABModifyItemBearerModConf {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABModifyItemBearerModConf {
            e_rab_id: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABModifyItemBearerModRes {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABModifyItemBearerModResIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABModifyItemBearerModRes {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABModifyItemBearerModRes {
            e_rab_id: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABModifyListBearerModConf(pub Vec<E_RABModifyListBearerModConf_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABModifyListBearerModConf {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABModifyListBearerModConf(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABModifyListBearerModRes(pub Vec<E_RABModifyListBearerModRes_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABModifyListBearerModRes {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABModifyListBearerModRes(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABModifyRequest {
    pub protocol_i_es: E_RABModifyRequestProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABModifyResponse {
    pub protocol_i_es: E_RABModifyResponseProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABNotToBeModifiedItemBearerModInd {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub dl_gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABNotToBeModifiedItemBearerModIndIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABNotToBeModifiedItemBearerModInd {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABNotToBeModifiedItemBearerModInd {
            e_rab_id: u.arbitrary()?,
            transport_layer_address: u.arbitrary()?,
            dl_gtp_teid: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABNotToBeModifiedListBearerModInd(
    pub Vec<E_RABNotToBeModifiedListBearerModInd_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABNotToBeModifiedListBearerModInd {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABNotToBeModifiedListBearerModInd(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABReleaseCommand {
    pub protocol_i_es: E_RABReleaseCommandProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABReleaseIndication {
    pub protocol_i_es: E_RABReleaseIndicationProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABReleaseItemBearerRelComp {
    pub e_rab_id: E_RAB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABReleaseItemBearerRelCompIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABReleaseItemBearerRelComp {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABReleaseItemBearerRelComp {
            e_rab_id: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABReleaseListBearerRelComp(pub Vec<E_RABReleaseListBearerRelComp_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABReleaseListBearerRelComp {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABReleaseListBearerRelComp(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABReleaseResponse {
    pub protocol_i_es: E_RABReleaseResponseProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABSetupItemBearerSURes {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABSetupItemBearerSUResIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABSetupItemBearerSURes {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABSetupItemBearerSURes {
            e_rab_id: u.arbitrary()?,
            transport_layer_address: u.arbitrary()?,
            gtp_teid: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABSetupItemCtxtSURes {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABSetupItemCtxtSUResIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABSetupItemCtxtSURes {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABSetupItemCtxtSURes {
            e_rab_id: u.arbitrary()?,
            transport_layer_address: u.arbitrary()?,
            gtp_teid: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABSetupListBearerSURes(pub Vec<E_RABSetupListBearerSURes_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABSetupListBearerSURes {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABSetupListBearerSURes(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABSetupListCtxtSURes(pub Vec<E_RABSetupListCtxtSURes_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABSetupListCtxtSURes {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABSetupListCtxtSURes(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABSetupRequest {
    pub protocol_i_es: E_RABSetupRequestProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct E_RABSetupResponse {
    pub protocol_i_es: E_RABSetupResponseProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABSubjecttoDataForwardingList(pub Vec<E_RABSubjecttoDataForwardingList_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABSubjecttoDataForwardingList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABSubjecttoDataForwardingList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABToBeModifiedItemBearerModInd {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub dl_gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABToBeModifiedItemBearerModIndIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeModifiedItemBearerModInd {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABToBeModifiedItemBearerModInd {
            e_rab_id: u.arbitrary()?,
            transport_layer_address: u.arbitrary()?,
            dl_gtp_teid: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABToBeModifiedItemBearerModReq {
    pub e_rab_id: E_RAB_ID,
    pub e_rab_level_qo_s_parameters: E_RABLevelQoSParameters,
    pub nas_pdu: NAS_PDU,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABToBeModifiedItemBearerModReqIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABToBeModifiedListBearerModInd(pub Vec<E_RABToBeModifiedListBearerModInd_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeModifiedListBearerModInd {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABToBeModifiedListBearerModInd(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABToBeModifiedListBearerModReq(pub Vec<E_RABToBeModifiedListBearerModReq_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeModifiedListBearerModReq {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABToBeModifiedListBearerModReq(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABToBeSetupItemBearerSUReq {
    pub e_rab_id: E_RAB_ID,
    pub e_ra_blevel_qo_s_parameters: E_RABLevelQoSParameters,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    pub nas_pdu: NAS_PDU,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABToBeSetupItemBearerSUReqIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct E_RABToBeSetupItemCtxtSUReq {
    pub e_rab_id: E_RAB_ID,
    pub e_ra_blevel_qo_s_parameters: E_RABLevelQoSParameters,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub nas_pdu: Option<NAS_PDU>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<E_RABToBeSetupItemCtxtSUReqIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABToBeSetupItemHOReq {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    pub e_ra_blevel_qos_parameters: E_RABLevelQoSParameters,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABToBeSetupItemHOReqIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABToBeSetupListBearerSUReq(pub Vec<E_RABToBeSetupListBearerSUReq_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSetupListBearerSUReq {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABToBeSetupListBearerSUReq(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABToBeSetupListCtxtSUReq(pub Vec<E_RABToBeSetupListCtxtSUReq_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSetupListCtxtSUReq {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABToBeSetupListCtxtSUReq(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABToBeSetupListHOReq(pub Vec<E_RABToBeSetupListHOReq_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSetupListHOReq {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABToBeSetupListHOReq(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABToBeSwitchedDLItem {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABToBeSwitchedDLItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSwitchedDLItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABToBeSwitchedDLItem {
            e_rab_id: u.arbitrary()?,
            transport_layer_address: u.arbitrary()?,
            gtp_teid: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABToBeSwitchedDLList(pub Vec<E_RABToBeSwitchedDLList_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSwitchedDLList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABToBeSwitchedDLList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABToBeSwitchedULItem {
    pub e_rab_id: E_RAB_ID,
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GTP_TEID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABToBeSwitchedULItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSwitchedULItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABToBeSwitchedULItem {
            e_rab_id: u.arbitrary()?,
            transport_layer_address: u.arbitrary()?,
            gtp_teid: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct E_RABToBeSwitchedULList(pub Vec<E_RABToBeSwitchedULList_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSwitchedULList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABToBeSwitchedULList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct E_RABUsageReportItem {
    pub start_timestamp: E_RABUsageReportItemStartTimestamp,
    pub end_timestamp: E_RABUsageReportItemEndTimestamp,
    pub usage_count_ul: E_RABUsageReportItemUsageCountUL,
    pub usage_count_dl: E_RABUsageReportItemUsageCountDL,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<E_RABUsageReportItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABUsageReportItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABUsageReportItem {
            start_timestamp: u.arbitrary()?,
            end_timestamp: u.arbitrary()?,
            usage_count_dl: u.arbitrary()?,
            usage_count_ul: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct E_RABUsageReportList(pub Vec<E_RABUsageReportList_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABUsageReportList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=2)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABUsageReportList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct E_UTRAN_Trace_ID(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for E_UTRAN_Trace_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(8, std::cmp::min(10, u.int_in_range(8..=8)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(E_UTRAN_Trace_ID(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "262143", extensible = true)]
pub struct EARFCN(pub u32);
impl<'a> arbitrary::Arbitrary<'a> for EARFCN {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EARFCN(u.int_in_range(0..=262143)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ECGI_List(pub Vec<EUTRAN_CGI>);
impl<'a> arbitrary::Arbitrary<'a> for ECGI_List {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ECGI_List(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ECGIList(pub Vec<EUTRAN_CGI>);
impl<'a> arbitrary::Arbitrary<'a> for ECGIList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ECGIList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ECGIListForRestart(pub Vec<EUTRAN_CGI>);
impl<'a> arbitrary::Arbitrary<'a> for ECGIListForRestart {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ECGIListForRestart(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct EDT_Session(pub u8);
impl EDT_Session {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for EDT_Session {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EDT_Session(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "16",
    sz_ub = "16"
)]
pub struct EHRPD_Sector_ID(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for EHRPD_Sector_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(16, std::cmp::min(10, u.int_in_range(16..=16)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(EHRPD_Sector_ID(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "100")]
pub struct EHRPDCapacityValue(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for EHRPDCapacityValue {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EHRPDCapacityValue(u.int_in_range(0..=100)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct EHRPDCompositeAvailableCapacity {
    pub ehrpd_sector_capacity_class_value: EHRPDSectorCapacityClassValue,
    pub ehrpd_capacity_value: EHRPDCapacityValue,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct EHRPDMultiSectorLoadReportingResponseItem {
    pub ehrpd_sector_id: EHRPD_Sector_ID,
    pub ehrpd_sector_load_reporting_response: EHRPDSectorLoadReportingResponse,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "1", ub = "100", extensible = true)]
pub struct EHRPDSectorCapacityClassValue(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for EHRPDSectorCapacityClassValue {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EHRPDSectorCapacityClassValue(u.int_in_range(1..=100)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct EHRPDSectorLoadReportingResponse {
    pub dl_ehrpd_composite_available_capacity: EHRPDCompositeAvailableCapacity,
    pub ul_ehrpd_composite_available_capacity: EHRPDCompositeAvailableCapacity,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct EN_DCSONConfigurationTransfer {
    pub transfertype: EN_DCSONTransferType,
    pub son_information: SONInformation,
    #[asn(optional_idx = 0)]
    pub x2tnl_config_info: Option<X2TNLConfigurationInfo>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<EN_DCSONConfigurationTransferIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for EN_DCSONConfigurationTransfer {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EN_DCSONConfigurationTransfer {
            transfertype: u.arbitrary()?,
            son_information: u.arbitrary()?,
            x2tnl_config_info: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum EN_DCSONTransferType {
    #[asn(key = 0, extended = false)]
    Request(EN_DCTransferTypeRequest),
    #[asn(key = 1, extended = false)]
    Reply(EN_DCTransferTypeReply),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EN_DCSONeNBIdentification {
    pub globale_nbid: Global_ENB_ID,
    pub selected_tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EN_DCSONeNBIdentificationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for EN_DCSONeNBIdentification {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EN_DCSONeNBIdentification {
            globale_nbid: u.arbitrary()?,
            selected_tai: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EN_DCSONengNBIdentification {
    pub globaleng_nbid: Global_en_gNB_ID,
    pub selected_tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EN_DCSONengNBIdentificationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for EN_DCSONengNBIdentification {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EN_DCSONengNBIdentification {
            globaleng_nbid: u.arbitrary()?,
            selected_tai: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EN_DCTransferTypeReply {
    pub sourceeng_nb: EN_DCSONengNBIdentification,
    pub targete_nb: EN_DCSONeNBIdentification,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EN_DCTransferTypeReplyIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for EN_DCTransferTypeReply {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EN_DCTransferTypeReply {
            sourceeng_nb: u.arbitrary()?,
            targete_nb: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct EN_DCTransferTypeRequest {
    pub sourcee_nb: EN_DCSONeNBIdentification,
    pub targeteng_nb: EN_DCSONengNBIdentification,
    #[asn(optional_idx = 0)]
    pub targete_nb: Option<EN_DCSONeNBIdentification>,
    #[asn(optional_idx = 1)]
    pub associated_tai: Option<TAI>,
    #[asn(optional_idx = 2)]
    pub broadcast5_gstai: Option<FiveGSTAI>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<EN_DCTransferTypeRequestIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for EN_DCTransferTypeRequest {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EN_DCTransferTypeRequest {
            sourcee_nb: u.arbitrary()?,
            targeteng_nb: u.arbitrary()?,
            targete_nb: u.arbitrary()?,
            associated_tai: u.arbitrary()?,
            broadcast5_gstai: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ENB_EarlyStatusTransfer_TransparentContainer {
    pub bearers_subject_to_early_status_transfer_list: Bearers_SubjectToEarlyStatusTransferList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ENB_EarlyStatusTransfer_TransparentContainerIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for ENB_EarlyStatusTransfer_TransparentContainer {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ENB_EarlyStatusTransfer_TransparentContainer {
            bearers_subject_to_early_status_transfer_list: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum ENB_ID {
    #[asn(key = 0, extended = false)]
    MacroENB_ID(ENB_ID_macroENB_ID),
    #[asn(key = 1, extended = false)]
    HomeENB_ID(ENB_ID_homeENB_ID),
    // Encode of extended choice not yet implemented
    //#[asn(key = 0, extended = true)]
    //Short_macroENB_ID(ENB_ID_short_macroENB_ID),
    //#[asn(key = 1, extended = true)]
    //Long_macroENB_ID(ENB_ID_long_macroENB_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ENB_StatusTransfer_TransparentContainer {
    pub bearers_subject_to_status_transfer_list: Bearers_SubjectToStatusTransferList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ENB_StatusTransfer_TransparentContainerIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for ENB_StatusTransfer_TransparentContainer {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ENB_StatusTransfer_TransparentContainer {
            bearers_subject_to_status_transfer_list: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "16777215")]
pub struct ENB_UE_S1AP_ID(pub u32);
impl<'a> arbitrary::Arbitrary<'a> for ENB_UE_S1AP_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ENB_UE_S1AP_ID(u.int_in_range(0..=16777215)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBCPRelocationIndication {
    pub protocol_i_es: ENBCPRelocationIndicationProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBConfigurationTransfer {
    pub protocol_i_es: ENBConfigurationTransferProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBConfigurationUpdate {
    pub protocol_i_es: ENBConfigurationUpdateProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBConfigurationUpdateAcknowledge {
    pub protocol_i_es: ENBConfigurationUpdateAcknowledgeProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBConfigurationUpdateFailure {
    pub protocol_i_es: ENBConfigurationUpdateFailureProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBDirectInformationTransfer {
    pub protocol_i_es: ENBDirectInformationTransferProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBEarlyStatusTransfer {
    pub protocol_i_es: ENBEarlyStatusTransferProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct ENBIndirectX2TransportLayerAddresses(pub Vec<TransportLayerAddress>);
impl<'a> arbitrary::Arbitrary<'a> for ENBIndirectX2TransportLayerAddresses {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=2)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ENBIndirectX2TransportLayerAddresses(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ENBStatusTransfer {
    pub protocol_i_es: ENBStatusTransferProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ENBX2ExtTLA {
    #[asn(optional_idx = 0)]
    pub i_psec_tla: Option<TransportLayerAddress>,
    #[asn(optional_idx = 1)]
    pub gtptl_aa: Option<ENBX2GTPTLAs>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<ENBX2ExtTLAIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for ENBX2ExtTLA {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ENBX2ExtTLA {
            i_psec_tla: u.arbitrary()?,
            gtptl_aa: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ENBX2ExtTLAs(pub Vec<ENBX2ExtTLA>);
impl<'a> arbitrary::Arbitrary<'a> for ENBX2ExtTLAs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=16)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ENBX2ExtTLAs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ENBX2GTPTLAs(pub Vec<TransportLayerAddress>);
impl<'a> arbitrary::Arbitrary<'a> for ENBX2GTPTLAs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=16)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ENBX2GTPTLAs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "2")]
pub struct ENBX2TLAs(pub Vec<TransportLayerAddress>);
impl<'a> arbitrary::Arbitrary<'a> for ENBX2TLAs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=2)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ENBX2TLAs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "PrintableString",
    sz_extensible = true,
    sz_lb = "1",
    sz_ub = "150"
)]
pub struct ENBname(pub String);
impl<'a> arbitrary::Arbitrary<'a> for ENBname {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let str_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=150)?));
        let mut s = String::new();
        for _ in 0..str_length {
            s.push(u.arbitrary::<char>()?);
        }
        Ok(ENBname(s))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "15")]
pub struct EPLMNs(pub Vec<PLMNidentity>);
impl<'a> arbitrary::Arbitrary<'a> for EPLMNs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=15)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(EPLMNs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EUTRAN_CGI {
    pub plm_nidentity: PLMNidentity,
    pub cell_id: CellIdentity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EUTRAN_CGIIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for EUTRAN_CGI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EUTRAN_CGI {
            plm_nidentity: u.arbitrary()?,
            cell_id: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct EUTRANResponse {
    pub cell_id: EUTRANResponseCell_ID,
    pub eutra_ncell_load_reporting_response: EUTRANcellLoadReportingResponse,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "2047")]
pub struct EUTRANRoundTripDelayEstimationInfo(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for EUTRANRoundTripDelayEstimationInfo {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EUTRANRoundTripDelayEstimationInfo(
            u.int_in_range(0..=2047)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct EUTRANcellLoadReportingResponse {
    pub composite_available_capacity_group: CompositeAvailableCapacityGroup,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct EmergencyAreaID(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for EmergencyAreaID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(3, std::cmp::min(10, u.int_in_range(3..=3)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(EmergencyAreaID(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaID_Broadcast(pub Vec<EmergencyAreaID_Broadcast_Item>);
impl<'a> arbitrary::Arbitrary<'a> for EmergencyAreaID_Broadcast {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(EmergencyAreaID_Broadcast(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EmergencyAreaID_Broadcast_Item {
    pub emergency_area_id: EmergencyAreaID,
    pub completed_cellin_eai: CompletedCellinEAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EmergencyAreaID_Broadcast_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for EmergencyAreaID_Broadcast_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EmergencyAreaID_Broadcast_Item {
            emergency_area_id: u.arbitrary()?,
            completed_cellin_eai: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaID_Cancelled(pub Vec<EmergencyAreaID_Cancelled_Item>);
impl<'a> arbitrary::Arbitrary<'a> for EmergencyAreaID_Cancelled {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(EmergencyAreaID_Cancelled(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EmergencyAreaID_Cancelled_Item {
    pub emergency_area_id: EmergencyAreaID,
    pub cancelled_cellin_eai: CancelledCellinEAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<EmergencyAreaID_Cancelled_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for EmergencyAreaID_Cancelled_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EmergencyAreaID_Cancelled_Item {
            emergency_area_id: u.arbitrary()?,
            cancelled_cellin_eai: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaIDList(pub Vec<EmergencyAreaID>);
impl<'a> arbitrary::Arbitrary<'a> for EmergencyAreaIDList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(EmergencyAreaIDList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct EmergencyAreaIDListForRestart(pub Vec<EmergencyAreaID>);
impl<'a> arbitrary::Arbitrary<'a> for EmergencyAreaIDListForRestart {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(EmergencyAreaIDListForRestart(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct EmergencyIndicator(pub u8);
impl EmergencyIndicator {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for EmergencyIndicator {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EmergencyIndicator(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "22", sz_ub = "32")]
pub struct En_gNB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for En_gNB_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..22 {
            bv.push(u.arbitrary()?);
        }
        if 32 > 22 {
            for _ in 0..u.int_in_range(0..=32 - 22 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(En_gNB_ID(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct EncryptionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for EncryptionAlgorithms {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..16 {
            bv.push(u.arbitrary()?);
        }
        if 16 > 16 {
            for _ in 0..u.int_in_range(0..=16 - 16 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(EncryptionAlgorithms(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct EndIndication(pub u8);
impl EndIndication {
    pub const NO_FURTHER_DATA: u8 = 0u8;
    pub const FURTHER_DATA_EXISTS: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for EndIndication {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EndIndication(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct EnhancedCoverageRestricted(pub u8);
impl EnhancedCoverageRestricted {
    pub const RESTRICTED: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for EnhancedCoverageRestricted {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EnhancedCoverageRestricted(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ErrorIndication {
    pub protocol_i_es: ErrorIndicationProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct Ethernet_Type(pub u8);
impl Ethernet_Type {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Ethernet_Type {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Ethernet_Type(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct EventTriggeredCellLoadReportingRequest {
    pub number_of_measurement_reporting_levels: NumberOfMeasurementReportingLevels,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct EventTriggeredCellLoadReportingResponse {
    pub cell_load_reporting_response: CellLoadReportingResponse,
    #[asn(optional_idx = 0)]
    pub overload_flag: Option<OverloadFlag>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct EventType(pub u8);
impl EventType {
    pub const DIRECT: u8 = 0u8;
    pub const CHANGE_OF_SERVE_CELL: u8 = 1u8;
    pub const STOP_CHANGE_OF_SERVE_CELL: u8 = 2u8;
}
impl<'a> arbitrary::Arbitrary<'a> for EventType {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(EventType(u.int_in_range(0..=2)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "1", ub = "30", extensible = true)]
pub struct ExpectedActivityPeriod(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for ExpectedActivityPeriod {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ExpectedActivityPeriod(u.int_in_range(1..=30)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "6")]
pub struct ExpectedHOInterval(pub u8);
impl ExpectedHOInterval {
    pub const SEC15: u8 = 0u8;
    pub const SEC30: u8 = 1u8;
    pub const SEC60: u8 = 2u8;
    pub const SEC90: u8 = 3u8;
    pub const SEC120: u8 = 4u8;
    pub const SEC180: u8 = 5u8;
    pub const LONG_TIME: u8 = 6u8;
}
impl<'a> arbitrary::Arbitrary<'a> for ExpectedHOInterval {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ExpectedHOInterval(u.int_in_range(0..=6)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "1", ub = "30", extensible = true)]
pub struct ExpectedIdlePeriod(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for ExpectedIdlePeriod {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ExpectedIdlePeriod(u.int_in_range(1..=30)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct ExpectedUEActivityBehaviour {
    #[asn(optional_idx = 0)]
    pub expected_activity_period: Option<ExpectedActivityPeriod>,
    #[asn(optional_idx = 1)]
    pub expected_idle_period: Option<ExpectedIdlePeriod>,
    #[asn(optional_idx = 2)]
    pub sourceof_ue_activity_behaviour_information: Option<SourceOfUEActivityBehaviourInformation>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<ExpectedUEActivityBehaviourIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for ExpectedUEActivityBehaviour {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ExpectedUEActivityBehaviour {
            expected_activity_period: u.arbitrary()?,
            expected_idle_period: u.arbitrary()?,
            sourceof_ue_activity_behaviour_information: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ExpectedUEBehaviour {
    #[asn(optional_idx = 0)]
    pub expected_activity: Option<ExpectedUEActivityBehaviour>,
    #[asn(optional_idx = 1)]
    pub expected_ho_interval: Option<ExpectedHOInterval>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<ExpectedUEBehaviourIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for ExpectedUEBehaviour {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ExpectedUEBehaviour {
            expected_activity: u.arbitrary()?,
            expected_ho_interval: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "14", sz_ub = "14")]
pub struct Extended_UEIdentityIndexValue(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for Extended_UEIdentityIndexValue {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..14 {
            bv.push(u.arbitrary()?);
        }
        if 14 > 14 {
            for _ in 0..u.int_in_range(0..=14 - 14 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(Extended_UEIdentityIndexValue(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "INTEGER",
    lb = "10000000001",
    ub = "4000000000000",
    extensible = true
)]
pub struct ExtendedBitRate(pub u64);
impl<'a> arbitrary::Arbitrary<'a> for ExtendedBitRate {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ExtendedBitRate(
            u.int_in_range(10000000001..=4000000000000)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "4096", ub = "65535")]
pub struct ExtendedRNC_ID(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for ExtendedRNC_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ExtendedRNC_ID(u.int_in_range(4096..=65535)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "4096", ub = "131071")]
pub struct ExtendedRepetitionPeriod(pub u32);
impl<'a> arbitrary::Arbitrary<'a> for ExtendedRepetitionPeriod {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ExtendedRepetitionPeriod(u.int_in_range(4096..=131071)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum FailureEventReport {
    #[asn(key = 0, extended = false)]
    TooEarlyInterRATHOReportFromEUTRAN(TooEarlyInterRATHOReportReportFromEUTRAN),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct FailureEventReportingCause(pub u8);
impl FailureEventReportingCause {
    pub const APPLICATION_CONTAINER_SYNTAX_ERROR: u8 = 0u8;
    pub const INCONSISTENT_REPORTING_CELL_IDENTIFIER: u8 = 1u8;
    pub const UNSPECIFIED: u8 = 2u8;
}
impl<'a> arbitrary::Arbitrary<'a> for FailureEventReportingCause {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(FailureEventReportingCause(u.int_in_range(0..=2)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct FiveGSTAC(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for FiveGSTAC {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(3, std::cmp::min(10, u.int_in_range(3..=3)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(FiveGSTAC(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct FiveGSTAI {
    pub plm_nidentity: PLMNidentity,
    pub five_gstac: FiveGSTAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<FiveGSTAIIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for FiveGSTAI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(FiveGSTAI {
            plm_nidentity: u.arbitrary()?,
            five_gstac: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "255", extensible = true)]
pub struct FiveQI(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for FiveQI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(FiveQI(u.int_in_range(0..=255)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct ForbiddenInterRATs(pub u8);
impl ForbiddenInterRATs {
    pub const ALL: u8 = 0u8;
    pub const GERAN: u8 = 1u8;
    pub const UTRAN: u8 = 2u8;
    pub const CDMA2000: u8 = 3u8;
}
impl<'a> arbitrary::Arbitrary<'a> for ForbiddenInterRATs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ForbiddenInterRATs(u.int_in_range(0..=3)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "4096"
)]
pub struct ForbiddenLACs(pub Vec<LAC>);
impl<'a> arbitrary::Arbitrary<'a> for ForbiddenLACs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=4096)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ForbiddenLACs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ForbiddenLAs(pub Vec<ForbiddenLAs_Item>);
impl<'a> arbitrary::Arbitrary<'a> for ForbiddenLAs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=16)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ForbiddenLAs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ForbiddenLAs_Item {
    pub plmn_identity: PLMNidentity,
    pub forbidden_la_cs: ForbiddenLACs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ForbiddenLAs_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for ForbiddenLAs_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ForbiddenLAs_Item {
            plmn_identity: u.arbitrary()?,
            forbidden_la_cs: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "4096"
)]
pub struct ForbiddenTACs(pub Vec<TAC>);
impl<'a> arbitrary::Arbitrary<'a> for ForbiddenTACs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=4096)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ForbiddenTACs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct ForbiddenTAs(pub Vec<ForbiddenTAs_Item>);
impl<'a> arbitrary::Arbitrary<'a> for ForbiddenTAs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=16)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ForbiddenTAs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ForbiddenTAs_Item {
    pub plmn_identity: PLMNidentity,
    pub forbidden_ta_cs: ForbiddenTACs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ForbiddenTAs_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for ForbiddenTAs_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ForbiddenTAs_Item {
            plmn_identity: u.arbitrary()?,
            forbidden_ta_cs: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GBR_QosInformation {
    pub e_rab_maximum_bitrate_dl: BitRate,
    pub e_rab_maximum_bitrate_ul: BitRate,
    pub e_rab_guaranteed_bitrate_dl: BitRate,
    pub e_rab_guaranteed_bitrate_ul: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GBR_QosInformationIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GERAN_Cell_ID {
    pub lai: LAI,
    pub rac: RAC,
    pub ci: CI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GERAN_Cell_IDIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for GERAN_Cell_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(GERAN_Cell_ID {
            lai: u.arbitrary()?,
            rac: u.arbitrary()?,
            ci: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GNB {
    pub global_g_nb_id: Global_GNB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GNBIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for GNB {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(GNB {
            global_g_nb_id: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "22", sz_ub = "32")]
pub struct GNB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for GNB_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..22 {
            bv.push(u.arbitrary()?);
        }
        if 32 > 22 {
            for _ in 0..u.int_in_range(0..=32 - 22 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(GNB_ID(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum GNB_Identity {
    #[asn(key = 0, extended = false)]
    GNB_ID(GNB_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct GTP_TEID(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for GTP_TEID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(4, std::cmp::min(10, u.int_in_range(4..=4)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(GTP_TEID(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct GUMMEI {
    pub plmn_identity: PLMNidentity,
    pub mme_group_id: MME_Group_ID,
    pub mme_code: MME_Code,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<GUMMEIIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for GUMMEI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(GUMMEI {
            plmn_identity: u.arbitrary()?,
            mme_group_id: u.arbitrary()?,
            mme_code: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct GUMMEIList(pub Vec<GUMMEI>);
impl<'a> arbitrary::Arbitrary<'a> for GUMMEIList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(GUMMEIList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct GUMMEIType(pub u8);
impl GUMMEIType {
    pub const NATIVE: u8 = 0u8;
    pub const MAPPED: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for GUMMEIType {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(GUMMEIType(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct GWContextReleaseIndication(pub u8);
impl GWContextReleaseIndication {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for GWContextReleaseIndication {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(GWContextReleaseIndication(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Global_ENB_ID {
    pub plm_nidentity: PLMNidentity,
    pub enb_id: ENB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Global_ENB_IDIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for Global_ENB_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Global_ENB_ID {
            plm_nidentity: u.arbitrary()?,
            enb_id: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Global_GNB_ID {
    pub plmn_identity: PLMNidentity,
    pub gnb_id: GNB_Identity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Global_GNB_IDIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for Global_GNB_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Global_GNB_ID {
            plmn_identity: u.arbitrary()?,
            gnb_id: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum Global_RAN_NODE_ID {
    #[asn(key = 0, extended = false)]
    GNB(GNB),
    #[asn(key = 1, extended = false)]
    Ng_eNB(NG_eNB),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct Global_en_gNB_ID {
    pub plm_nidentity: PLMNidentity,
    pub en_g_nb_id: En_gNB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<Global_en_gNB_IDIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for Global_en_gNB_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Global_en_gNB_ID {
            plm_nidentity: u.arbitrary()?,
            en_g_nb_id: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "1048575")]
pub struct HFN(pub u32);
impl<'a> arbitrary::Arbitrary<'a> for HFN {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(HFN(u.int_in_range(0..=1048575)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "131071")]
pub struct HFNModified(pub u32);
impl<'a> arbitrary::Arbitrary<'a> for HFNModified {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(HFNModified(u.int_in_range(0..=131071)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "16383")]
pub struct HFNforPDCP_SNlength18(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for HFNforPDCP_SNlength18 {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(HFNforPDCP_SNlength18(u.int_in_range(0..=16383)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct HOReport {
    pub ho_type: HoType,
    pub ho_report_type: HoReportType,
    pub hosource_id: IRAT_Cell_ID,
    pub ho_target_id: IRAT_Cell_ID,
    pub candidate_cell_list: CandidateCellList,
    #[asn(optional_idx = 0)]
    pub candidate_pci_list: Option<CandidatePCIList>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct HOReportingCause(pub u8);
impl HOReportingCause {
    pub const APPLICATION_CONTAINER_SYNTAX_ERROR: u8 = 0u8;
    pub const INCONSISTENT_REPORTING_CELL_IDENTIFIER: u8 = 1u8;
    pub const UNSPECIFIED: u8 = 2u8;
}
impl<'a> arbitrary::Arbitrary<'a> for HOReportingCause {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(HOReportingCause(u.int_in_range(0..=2)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverCancel {
    pub protocol_i_es: HandoverCancelProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverCancelAcknowledge {
    pub protocol_i_es: HandoverCancelAcknowledgeProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverCommand {
    pub protocol_i_es: HandoverCommandProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverFailure {
    pub protocol_i_es: HandoverFailureProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct HandoverFlag(pub u8);
impl HandoverFlag {
    pub const HANDOVER_PREPARATION: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for HandoverFlag {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(HandoverFlag(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverNotify {
    pub protocol_i_es: HandoverNotifyProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverPreparationFailure {
    pub protocol_i_es: HandoverPreparationFailureProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverRequest {
    pub protocol_i_es: HandoverRequestProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverRequestAcknowledge {
    pub protocol_i_es: HandoverRequestAcknowledgeProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverRequired {
    pub protocol_i_es: HandoverRequiredProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 5)]
pub struct HandoverRestrictionList {
    pub serving_plmn: PLMNidentity,
    #[asn(optional_idx = 0)]
    pub equivalent_plm_ns: Option<EPLMNs>,
    #[asn(optional_idx = 1)]
    pub forbidden_t_as: Option<ForbiddenTAs>,
    #[asn(optional_idx = 2)]
    pub forbidden_l_as: Option<ForbiddenLAs>,
    #[asn(optional_idx = 3)]
    pub forbidden_inter_ra_ts: Option<ForbiddenInterRATs>,
    #[asn(optional_idx = 4)]
    pub ie_extensions: Option<HandoverRestrictionListIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct HandoverSuccess {
    pub protocol_i_es: HandoverSuccessProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct HandoverType(pub u8);
impl HandoverType {
    pub const INTRALTE: u8 = 0u8;
    pub const LTETOUTRAN: u8 = 1u8;
    pub const LTETOGERAN: u8 = 2u8;
    pub const UTRANTOLTE: u8 = 3u8;
    pub const GERANTOLTE: u8 = 4u8;
}
impl<'a> arbitrary::Arbitrary<'a> for HandoverType {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(HandoverType(u.int_in_range(0..=4)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct HoReportType(pub u8);
impl HoReportType {
    pub const UNNECESSARYHOTOANOTHERRAT: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for HoReportType {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(HoReportType(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct HoType(pub u8);
impl HoType {
    pub const LTETOUTRAN: u8 = 0u8;
    pub const LTETOGERAN: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for HoType {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(HoType(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct IAB_Authorized(pub u8);
impl IAB_Authorized {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for IAB_Authorized {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(IAB_Authorized(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct IAB_Node_Indication(pub u8);
impl IAB_Node_Indication {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for IAB_Node_Indication {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(IAB_Node_Indication(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct IAB_Supported(pub u8);
impl IAB_Supported {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for IAB_Supported {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(IAB_Supported(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "8")]
pub struct IMSI(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for IMSI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(3, std::cmp::min(10, u.int_in_range(3..=3)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(IMSI(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct IMSvoiceEPSfallbackfrom5G(pub u8);
impl IMSvoiceEPSfallbackfrom5G {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for IMSvoiceEPSfallbackfrom5G {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(IMSvoiceEPSfallbackfrom5G(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum IRAT_Cell_ID {
    #[asn(key = 0, extended = false)]
    EUTRAN(IRAT_Cell_ID_eUTRAN),
    #[asn(key = 1, extended = false)]
    UTRAN(IRAT_Cell_ID_uTRAN),
    #[asn(key = 2, extended = false)]
    GERAN(IRAT_Cell_ID_gERAN),
    // Encode of extended choice not yet implemented
    //#[asn(key = 0, extended = true)]
    //EHRPD(EHRPD_Sector_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ImmediateMDT {
    pub measurements_to_activate: MeasurementsToActivate,
    pub m1reporting_trigger: M1ReportingTrigger,
    #[asn(optional_idx = 0)]
    pub m1thresholdevent_a2: Option<M1ThresholdEventA2>,
    #[asn(optional_idx = 1)]
    pub m1periodic_reporting: Option<M1PeriodicReporting>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<ImmediateMDTIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct InformationOnRecommendedCellsAndENBsForPaging {
    pub recommended_cells_for_paging: RecommendedCellsForPaging,
    pub recommend_en_bs_for_paging: RecommendedENBsForPaging,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<InformationOnRecommendedCellsAndENBsForPagingIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for InformationOnRecommendedCellsAndENBsForPaging {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(InformationOnRecommendedCellsAndENBsForPaging {
            recommended_cells_for_paging: u.arbitrary()?,
            recommend_en_bs_for_paging: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialContextSetupFailure {
    pub protocol_i_es: InitialContextSetupFailureProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialContextSetupRequest {
    pub protocol_i_es: InitialContextSetupRequestProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialContextSetupResponse {
    pub protocol_i_es: InitialContextSetupResponseProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct InitialUEMessage {
    pub protocol_i_es: InitialUEMessageProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitiatingMessage {
    #[asn(key_field = true)]
    pub procedure_code: ProcedureCode,
    pub criticality: Criticality,
    pub value: InitiatingMessageValue,
}

impl<'a> arbitrary::Arbitrary<'a> for InitiatingMessage {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut value: InitiatingMessageValue = u.arbitrary()?;
        Ok(InitiatingMessage {
            procedure_code: ProcedureCode(match value {
                InitiatingMessageValue::Id_CellTrafficTrace(_) => 42,
                InitiatingMessageValue::Id_ConnectionEstablishmentIndication(_) => 54,
                InitiatingMessageValue::Id_DeactivateTrace(_) => 26,
                InitiatingMessageValue::Id_DownlinkS1cdma2000tunnelling(_) => 19,
                InitiatingMessageValue::Id_E_RABModificationIndication(_) => 50,
                InitiatingMessageValue::Id_E_RABModify(_) => 6,
                InitiatingMessageValue::Id_E_RABRelease(_) => 7,
                InitiatingMessageValue::Id_E_RABReleaseIndication(_) => 8,
                InitiatingMessageValue::Id_E_RABSetup(_) => 5,
                InitiatingMessageValue::Id_ENBConfigurationUpdate(_) => 29,
                InitiatingMessageValue::Id_ErrorIndication(_) => 15,
                InitiatingMessageValue::Id_HandoverCancel(_) => 4,
                InitiatingMessageValue::Id_HandoverNotification(_) => 2,
                InitiatingMessageValue::Id_HandoverPreparation(_) => 0,
                InitiatingMessageValue::Id_HandoverResourceAllocation(_) => 1,
                InitiatingMessageValue::Id_HandoverSuccess(_) => 64,
                InitiatingMessageValue::Id_InitialContextSetup(_) => 9,
                InitiatingMessageValue::Id_Kill(_) => 43,
                InitiatingMessageValue::Id_LocationReport(_) => 33,
                InitiatingMessageValue::Id_LocationReportingControl(_) => 31,
                InitiatingMessageValue::Id_LocationReportingFailureIndication(_) => 32,
                InitiatingMessageValue::Id_MMECPRelocationIndication(_) => 61,
                InitiatingMessageValue::Id_MMEConfigurationTransfer(_) => 41,
                InitiatingMessageValue::Id_MMEConfigurationUpdate(_) => 30,
                InitiatingMessageValue::Id_MMEDirectInformationTransfer(_) => 38,
                InitiatingMessageValue::Id_MMEEarlyStatusTransfer(_) => 66,
                InitiatingMessageValue::Id_MMEStatusTransfer(_) => 25,
                InitiatingMessageValue::Id_NASDeliveryIndication(_) => 57,
                InitiatingMessageValue::Id_NASNonDeliveryIndication(_) => 16,
                InitiatingMessageValue::Id_OverloadStart(_) => 34,
                InitiatingMessageValue::Id_OverloadStop(_) => 35,
                InitiatingMessageValue::Id_PWSFailureIndication(_) => 51,
                InitiatingMessageValue::Id_PWSRestartIndication(_) => 49,
                InitiatingMessageValue::Id_Paging(_) => 10,
                InitiatingMessageValue::Id_PathSwitchRequest(_) => 3,
                InitiatingMessageValue::Id_RerouteNASRequest(_) => 52,
                InitiatingMessageValue::Id_Reset(_) => 14,
                InitiatingMessageValue::Id_RetrieveUEInformation(_) => 58,
                InitiatingMessageValue::Id_S1Setup(_) => 17,
                InitiatingMessageValue::Id_SecondaryRATDataUsageReport(_) => 62,
                InitiatingMessageValue::Id_TraceFailureIndication(_) => 28,
                InitiatingMessageValue::Id_TraceStart(_) => 27,
                InitiatingMessageValue::Id_UECapabilityInfoIndication(_) => 22,
                InitiatingMessageValue::Id_UEContextModification(_) => 21,
                InitiatingMessageValue::Id_UEContextModificationIndication(_) => 53,
                InitiatingMessageValue::Id_UEContextRelease(_) => 23,
                InitiatingMessageValue::Id_UEContextReleaseRequest(_) => 18,
                InitiatingMessageValue::Id_UEContextResume(_) => 56,
                InitiatingMessageValue::Id_UEContextSuspend(_) => 55,
                InitiatingMessageValue::Id_UEInformationTransfer(_) => 59,
                InitiatingMessageValue::Id_UERadioCapabilityIDMapping(_) => 63,
                InitiatingMessageValue::Id_UERadioCapabilityMatch(_) => 48,
                InitiatingMessageValue::Id_UplinkS1cdma2000tunnelling(_) => 20,
                InitiatingMessageValue::Id_WriteReplaceWarning(_) => 36,
                InitiatingMessageValue::Id_downlinkNASTransport(_) => 11,
                InitiatingMessageValue::Id_downlinkNonUEAssociatedLPPaTransport(_) => 46,
                InitiatingMessageValue::Id_downlinkUEAssociatedLPPaTransport(_) => 44,
                InitiatingMessageValue::Id_eNBCPRelocationIndication(_) => 60,
                InitiatingMessageValue::Id_eNBConfigurationTransfer(_) => 40,
                InitiatingMessageValue::Id_eNBDirectInformationTransfer(_) => 37,
                InitiatingMessageValue::Id_eNBEarlyStatusTransfer(_) => 65,
                InitiatingMessageValue::Id_eNBStatusTransfer(_) => 24,
                InitiatingMessageValue::Id_initialUEMessage(_) => 12,
                InitiatingMessageValue::Id_uplinkNASTransport(_) => 13,
                InitiatingMessageValue::Id_uplinkNonUEAssociatedLPPaTransport(_) => 47,
                InitiatingMessageValue::Id_uplinkUEAssociatedLPPaTransport(_) => 45,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct IntegrityProtectionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for IntegrityProtectionAlgorithms {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..16 {
            bv.push(u.arbitrary()?);
        }
        if 16 > 16 {
            for _ in 0..u.int_in_range(0..=16 - 16 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(IntegrityProtectionAlgorithms(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "1", ub = "16", extensible = true)]
pub struct IntendedNumberOfPagingAttempts(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for IntendedNumberOfPagingAttempts {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(IntendedNumberOfPagingAttempts(u.int_in_range(1..=16)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum Inter_SystemInformationTransferType {
    #[asn(key = 0, extended = false)]
    RIMTransfer(RIMTransfer),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 8)]
pub struct InterSystemMeasurementItem {
    pub freq_band_indicator_nr: InterSystemMeasurementItemFreqBandIndicatorNR,
    pub ss_bfrequencies: InterSystemMeasurementItemSSBfrequencies,
    pub subcarrier_spacing_ssb: InterSystemMeasurementItemSubcarrierSpacingSSB,
    #[asn(optional_idx = 0)]
    pub max_rs_index_cell_qual: Option<InterSystemMeasurementItemMaxRSIndexCellQual>,
    #[asn(optional_idx = 1)]
    pub smtc: Option<InterSystemMeasurementItemSMTC>,
    #[asn(optional_idx = 2)]
    pub thresh_rs_index_r15: Option<InterSystemMeasurementItemThreshRS_Index_r15>,
    #[asn(optional_idx = 3)]
    pub ssb_to_measure: Option<InterSystemMeasurementItemSSBToMeasure>,
    #[asn(optional_idx = 4)]
    pub ssrssi_measurement: Option<InterSystemMeasurementItemSSRSSIMeasurement>,
    #[asn(optional_idx = 5)]
    pub quantity_config_nr_r15: Option<InterSystemMeasurementItemQuantityConfigNR_R15>,
    #[asn(optional_idx = 6)]
    pub black_cells_to_add_mod_list: Option<InterSystemMeasurementItemBlackCellsToAddModList>,
    #[asn(optional_idx = 7)]
    pub ie_extensions: Option<InterSystemMeasurementItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for InterSystemMeasurementItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(InterSystemMeasurementItem {
            freq_band_indicator_nr: u.arbitrary()?,
            ss_bfrequencies: u.arbitrary()?,
            subcarrier_spacing_ssb: u.arbitrary()?,
            max_rs_index_cell_qual: u.arbitrary()?,
            smtc: u.arbitrary()?,
            thresh_rs_index_r15: u.arbitrary()?,
            ssb_to_measure: u.arbitrary()?,
            ssrssi_measurement: u.arbitrary()?,
            quantity_config_nr_r15: u.arbitrary()?,
            black_cells_to_add_mod_list: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "64")]
pub struct InterSystemMeasurementList(pub Vec<InterSystemMeasurementItem>);
impl<'a> arbitrary::Arbitrary<'a> for InterSystemMeasurementList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=64)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(InterSystemMeasurementList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct InterSystemMeasurementParameters {
    pub measurement_duration: InterSystemMeasurementParametersMeasurementDuration,
    #[asn(optional_idx = 0)]
    pub inter_system_measurement_list: Option<InterSystemMeasurementList>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<InterSystemMeasurementParametersIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for InterSystemMeasurementParameters {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(InterSystemMeasurementParameters {
            measurement_duration: u.arbitrary()?,
            inter_system_measurement_list: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct InterfacesToTrace(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for InterfacesToTrace {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..8 {
            bv.push(u.arbitrary()?);
        }
        if 8 > 8 {
            for _ in 0..u.int_in_range(0..=8 - 8 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(InterfacesToTrace(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct IntersystemMeasurementConfiguration {
    #[asn(optional_idx = 0)]
    pub rsrp: Option<IntersystemMeasurementConfigurationRSRP>,
    #[asn(optional_idx = 1)]
    pub rsrq: Option<IntersystemMeasurementConfigurationRSRQ>,
    #[asn(optional_idx = 2)]
    pub sinr: Option<IntersystemMeasurementConfigurationSINR>,
    pub inter_system_measurement_parameters: InterSystemMeasurementParameters,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<IntersystemMeasurementConfigurationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for IntersystemMeasurementConfiguration {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(IntersystemMeasurementConfiguration {
            rsrp: u.arbitrary()?,
            rsrq: u.arbitrary()?,
            sinr: u.arbitrary()?,
            inter_system_measurement_parameters: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}



#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct IntersystemSONConfigurationTransfer(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", lb = "0", ub = "0")]
pub struct KillAllWarningMessages(pub u8);
impl KillAllWarningMessages {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for KillAllWarningMessages {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(KillAllWarningMessages(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct KillRequest {
    pub protocol_i_es: KillRequestProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct KillResponse {
    pub protocol_i_es: KillResponseProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct L3_Information(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct LAC(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for LAC {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(2, std::cmp::min(10, u.int_in_range(2..=2)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(LAC(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LAI {
    pub plm_nidentity: PLMNidentity,
    pub lac: LAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<LAIIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for LAI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(LAI {
            plm_nidentity: u.arbitrary()?,
            lac: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "32",
    sz_ub = "256"
)]
pub struct LHN_ID(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for LHN_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(32, std::cmp::min(10, u.int_in_range(32..=32)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(LHN_ID(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct LPPa_PDU(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct LTE_M_Indication(pub u8);
impl LTE_M_Indication {
    pub const LTE_M: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for LTE_M_Indication {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(LTE_M_Indication(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum LastVisitedCell_Item {
    #[asn(key = 0, extended = false)]
    E_UTRAN_Cell(LastVisitedEUTRANCellInformation),
    #[asn(key = 1, extended = false)]
    UTRAN_Cell(LastVisitedUTRANCellInformation),
    #[asn(key = 2, extended = false)]
    GERAN_Cell(LastVisitedGERANCellInformation),
    // Encode of extended choice not yet implemented
    //#[asn(key = 0, extended = true)]
    //NG_RAN_Cell(LastVisitedNGRANCellInformation),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LastVisitedEUTRANCellInformation {
    pub global_cell_id: EUTRAN_CGI,
    pub cell_type: CellType,
    pub time_ue_stayed_in_cell: Time_UE_StayedInCell,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<LastVisitedEUTRANCellInformationIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum LastVisitedGERANCellInformation {
    #[asn(key = 0, extended = false)]
    Undefined(LastVisitedGERANCellInformation_undefined),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct LastVisitedNGRANCellInformation(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct LastVisitedUTRANCellInformation(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct Links_to_log(pub u8);
impl Links_to_log {
    pub const UPLINK: u8 = 0u8;
    pub const DOWNLINK: u8 = 1u8;
    pub const BOTH_UPLINK_AND_DOWNLINK: u8 = 2u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Links_to_log {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Links_to_log(u.int_in_range(0..=2)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ListeningSubframePattern {
    pub pattern_period: ListeningSubframePatternPattern_period,
    pub pattern_offset: ListeningSubframePatternPattern_offset,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ListeningSubframePatternIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for ListeningSubframePattern {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ListeningSubframePattern {
            pattern_period: u.arbitrary()?,
            pattern_offset: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct LocationReport {
    pub protocol_i_es: LocationReportProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct LocationReportingControl {
    pub protocol_i_es: LocationReportingControlProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct LocationReportingFailureIndication {
    pub protocol_i_es: LocationReportingFailureIndicationProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct LoggedMBSFNMDT {
    pub logging_interval: LoggingInterval,
    pub logging_duration: LoggingDuration,
    #[asn(optional_idx = 0)]
    pub mbsfn_result_to_log: Option<MBSFN_ResultToLog>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<LoggedMBSFNMDTIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for LoggedMBSFNMDT {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(LoggedMBSFNMDT {
            logging_interval: u.arbitrary()?,
            logging_duration: u.arbitrary()?,
            mbsfn_result_to_log: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct LoggedMDT {
    pub logging_interval: LoggingInterval,
    pub logging_duration: LoggingDuration,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<LoggedMDTIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", lb = "0", ub = "5")]
pub struct LoggingDuration(pub u8);
impl LoggingDuration {
    pub const M10: u8 = 0u8;
    pub const M20: u8 = 1u8;
    pub const M40: u8 = 2u8;
    pub const M60: u8 = 3u8;
    pub const M90: u8 = 4u8;
    pub const M120: u8 = 5u8;
}
impl<'a> arbitrary::Arbitrary<'a> for LoggingDuration {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(LoggingDuration(u.int_in_range(0..=5)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct LoggingInterval(pub u8);
impl LoggingInterval {
    pub const MS128: u8 = 0u8;
    pub const MS256: u8 = 1u8;
    pub const MS512: u8 = 2u8;
    pub const MS1024: u8 = 3u8;
    pub const MS2048: u8 = 4u8;
    pub const MS3072: u8 = 5u8;
    pub const MS4096: u8 = 6u8;
    pub const MS6144: u8 = 7u8;
}
impl<'a> arbitrary::Arbitrary<'a> for LoggingInterval {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(LoggingInterval(u.int_in_range(0..=7)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct M_TMSI(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for M_TMSI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(4, std::cmp::min(10, u.int_in_range(4..=4)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(M_TMSI(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M1PeriodicReporting {
    pub report_interval: ReportIntervalMDT,
    pub report_amount: ReportAmountMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M1PeriodicReportingIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for M1PeriodicReporting {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(M1PeriodicReporting {
            report_interval: u.arbitrary()?,
            report_amount: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct M1ReportingTrigger(pub u8);
impl M1ReportingTrigger {
    pub const PERIODIC: u8 = 0u8;
    pub const A2EVENTTRIGGERED: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for M1ReportingTrigger {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(M1ReportingTrigger(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M1ThresholdEventA2 {
    pub measurement_threshold: MeasurementThresholdA2,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M1ThresholdEventA2IE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for M1ThresholdEventA2 {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(M1ThresholdEventA2 {
            measurement_threshold: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M3Configuration {
    pub m3period: M3period,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M3ConfigurationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for M3Configuration {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(M3Configuration {
            m3period: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct M3period(pub u8);
impl M3period {
    pub const MS100: u8 = 0u8;
    pub const MS1000: u8 = 1u8;
    pub const MS10000: u8 = 2u8;
}
impl<'a> arbitrary::Arbitrary<'a> for M3period {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(M3period(u.int_in_range(0..=2)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M4Configuration {
    pub m4period: M4period,
    pub m4_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M4ConfigurationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for M4Configuration {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(M4Configuration {
            m4period: u.arbitrary()?,
            m4_links_to_log: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct M4period(pub u8);
impl M4period {
    pub const MS1024: u8 = 0u8;
    pub const MS2048: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
    pub const MIN1: u8 = 4u8;
}
impl<'a> arbitrary::Arbitrary<'a> for M4period {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(M4period(u.int_in_range(0..=4)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M5Configuration {
    pub m5period: M5period,
    pub m5_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M5ConfigurationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for M5Configuration {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(M5Configuration {
            m5period: u.arbitrary()?,
            m5_links_to_log: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct M5period(pub u8);
impl M5period {
    pub const MS1024: u8 = 0u8;
    pub const MS2048: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
    pub const MIN1: u8 = 4u8;
}
impl<'a> arbitrary::Arbitrary<'a> for M5period {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(M5period(u.int_in_range(0..=4)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct M6Configuration {
    pub m6report_interval: M6report_Interval,
    #[asn(optional_idx = 0)]
    pub m6delay_threshold: Option<M6delay_threshold>,
    pub m6_links_to_log: Links_to_log,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<M6ConfigurationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for M6Configuration {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(M6Configuration {
            m6report_interval: u.arbitrary()?,
            m6delay_threshold: u.arbitrary()?,
            m6_links_to_log: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "11")]
pub struct M6delay_threshold(pub u8);
impl M6delay_threshold {
    pub const MS30: u8 = 0u8;
    pub const MS40: u8 = 1u8;
    pub const MS50: u8 = 2u8;
    pub const MS60: u8 = 3u8;
    pub const MS70: u8 = 4u8;
    pub const MS80: u8 = 5u8;
    pub const MS90: u8 = 6u8;
    pub const MS100: u8 = 7u8;
    pub const MS150: u8 = 8u8;
    pub const MS300: u8 = 9u8;
    pub const MS500: u8 = 10u8;
    pub const MS750: u8 = 11u8;
}
impl<'a> arbitrary::Arbitrary<'a> for M6delay_threshold {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(M6delay_threshold(u.int_in_range(0..=11)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct M6report_Interval(pub u8);
impl M6report_Interval {
    pub const MS1024: u8 = 0u8;
    pub const MS2048: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
}
impl<'a> arbitrary::Arbitrary<'a> for M6report_Interval {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(M6report_Interval(u.int_in_range(0..=3)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct M7Configuration {
    pub m7period: M7period,
    pub m7_links_to_log: Links_to_log,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<M7ConfigurationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for M7Configuration {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(M7Configuration {
            m7period: u.arbitrary()?,
            m7_links_to_log: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "1", ub = "60", extensible = true)]
pub struct M7period(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for M7period {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(M7period(u.int_in_range(1..=60)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct MBSFN_ResultToLog(pub Vec<MBSFN_ResultToLogInfo>);
impl<'a> arbitrary::Arbitrary<'a> for MBSFN_ResultToLog {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=8)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(MBSFN_ResultToLog(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MBSFN_ResultToLogInfo {
    #[asn(optional_idx = 0)]
    pub mbsfn_area_id: Option<MBSFN_ResultToLogInfoMBSFN_AreaId>,
    pub carrier_freq: EARFCN,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<MBSFN_ResultToLogInfoIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for MBSFN_ResultToLogInfo {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(MBSFN_ResultToLogInfo {
            mbsfn_area_id: u.arbitrary()?,
            carrier_freq: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct MDT_Activation(pub u8);
impl MDT_Activation {
    pub const IMMEDIATE_MDT_ONLY: u8 = 0u8;
    pub const IMMEDIATE_MDT_AND_TRACE: u8 = 1u8;
    pub const LOGGED_MDT_ONLY: u8 = 2u8;
}
impl<'a> arbitrary::Arbitrary<'a> for MDT_Activation {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(MDT_Activation(u.int_in_range(0..=2)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct MDT_Configuration {
    pub mdt_activation: MDT_Activation,
    pub area_scope_of_mdt: AreaScopeOfMDT,
    pub mdt_mode: MDTMode,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<MDT_ConfigurationIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct MDT_ConfigurationNR(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MDT_Location_Info(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for MDT_Location_Info {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..8 {
            bv.push(u.arbitrary()?);
        }
        if 8 > 8 {
            for _ in 0..u.int_in_range(0..=8 - 8 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(MDT_Location_Info(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum MDTMode {
    #[asn(key = 0, extended = false)]
    ImmediateMDT(ImmediateMDT),
    #[asn(key = 1, extended = false)]
    LoggedMDT(LoggedMDT),
    // Encode of extended choice not yet implemented
    //#[asn(key = 0, extended = true)]
    //MDTMode_Extension(MDTMode_Extension),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MDTMode_Extension {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MDTMode_ExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for MDTMode_Extension {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: MDTMode_ExtensionValue = u.arbitrary()?;
        Ok(MDTMode_Extension {
            id: ProtocolIE_ID(match value {
                MDTMode_ExtensionValue::Id_LoggedMBSFNMDT(_) => 197,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct MDTPLMNList(pub Vec<PLMNidentity>);
impl<'a> arbitrary::Arbitrary<'a> for MDTPLMNList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=16)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(MDTPLMNList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct MME_Code(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for MME_Code {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=1)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(MME_Code(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct MME_Group_ID(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for MME_Group_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(2, std::cmp::min(10, u.int_in_range(2..=2)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(MME_Group_ID(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct MME_UE_S1AP_ID(pub u32);
impl<'a> arbitrary::Arbitrary<'a> for MME_UE_S1AP_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(MME_UE_S1AP_ID(u.int_in_range(0..=4294967295)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMECPRelocationIndication {
    pub protocol_i_es: MMECPRelocationIndicationProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMEConfigurationTransfer {
    pub protocol_i_es: MMEConfigurationTransferProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMEConfigurationUpdate {
    pub protocol_i_es: MMEConfigurationUpdateProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMEConfigurationUpdateAcknowledge {
    pub protocol_i_es: MMEConfigurationUpdateAcknowledgeProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMEConfigurationUpdateFailure {
    pub protocol_i_es: MMEConfigurationUpdateFailureProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMEDirectInformationTransfer {
    pub protocol_i_es: MMEDirectInformationTransferProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMEEarlyStatusTransfer {
    pub protocol_i_es: MMEEarlyStatusTransferProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum MMEPagingTarget {
    #[asn(key = 0, extended = false)]
    Global_ENB_ID(Global_ENB_ID),
    #[asn(key = 1, extended = false)]
    TAI(TAI),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct MMERelaySupportIndicator(pub u8);
impl MMERelaySupportIndicator {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for MMERelaySupportIndicator {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(MMERelaySupportIndicator(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MMEStatusTransfer {
    pub protocol_i_es: MMEStatusTransferProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "PrintableString",
    sz_extensible = true,
    sz_lb = "1",
    sz_ub = "150"
)]
pub struct MMEname(pub String);
impl<'a> arbitrary::Arbitrary<'a> for MMEname {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let str_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=150)?));
        let mut s = String::new();
        for _ in 0..str_length {
            s.push(u.arbitrary::<char>()?);
        }
        Ok(MMEname(s))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct MSClassmark2(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct MSClassmark3(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ManagementBasedMDTAllowed(pub u8);
impl ManagementBasedMDTAllowed {
    pub const ALLOWED: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for ManagementBasedMDTAllowed {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ManagementBasedMDTAllowed(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "64", sz_ub = "64")]
pub struct Masked_IMEISV(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for Masked_IMEISV {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..64 {
            bv.push(u.arbitrary()?);
        }
        if 64 > 64 {
            for _ in 0..u.int_in_range(0..=64 - 64 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(Masked_IMEISV(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum MeasurementThresholdA2 {
    #[asn(key = 0, extended = false)]
    Threshold_RSRP(Threshold_RSRP),
    #[asn(key = 1, extended = false)]
    Threshold_RSRQ(Threshold_RSRQ),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct MeasurementsToActivate(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for MeasurementsToActivate {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..8 {
            bv.push(u.arbitrary()?);
        }
        if 8 > 8 {
            for _ in 0..u.int_in_range(0..=8 - 8 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(MeasurementsToActivate(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct MessageIdentifier(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for MessageIdentifier {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..16 {
            bv.push(u.arbitrary()?);
        }
        if 16 > 16 {
            for _ in 0..u.int_in_range(0..=16 - 16 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(MessageIdentifier(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "32", sz_ub = "32")]
pub struct MobilityInformation(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for MobilityInformation {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..32 {
            bv.push(u.arbitrary()?);
        }
        if 32 > 32 {
            for _ in 0..u.int_in_range(0..=32 - 32 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(MobilityInformation(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct MultiCellLoadReportingRequest {
    pub requested_cell_list: RequestedCellList,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct MultiCellLoadReportingResponse(pub Vec<MultiCellLoadReportingResponse_Item>);
impl<'a> arbitrary::Arbitrary<'a> for MultiCellLoadReportingResponse {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=128)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(MultiCellLoadReportingResponse(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum MultiCellLoadReportingResponse_Item {
    #[asn(key = 0, extended = false)]
    EUTRANResponse(EUTRANResponse),
    #[asn(key = 1, extended = false)]
    UTRANResponse(MultiCellLoadReportingResponse_Item_uTRANResponse),
    #[asn(key = 2, extended = false)]
    GERANResponse(MultiCellLoadReportingResponse_Item_gERANResponse),
    // Encode of extended choice not yet implemented
    //#[asn(key = 0, extended = true)]
    //EHRPD(EHRPDMultiSectorLoadReportingResponseItem),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct MutingAvailabilityIndication(pub u8);
impl MutingAvailabilityIndication {
    pub const AVAILABLE: u8 = 0u8;
    pub const UNAVAILABLE: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for MutingAvailabilityIndication {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(MutingAvailabilityIndication(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct MutingPatternInformation {
    pub muting_pattern_period: MutingPatternInformationMuting_pattern_period,
    #[asn(optional_idx = 0)]
    pub muting_pattern_offset: Option<MutingPatternInformationMuting_pattern_offset>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<MutingPatternInformationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for MutingPatternInformation {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(MutingPatternInformation {
            muting_pattern_period: u.arbitrary()?,
            muting_pattern_offset: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct NAS_PDU(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NASDeliveryIndication {
    pub protocol_i_es: NASDeliveryIndicationProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NASNonDeliveryIndication {
    pub protocol_i_es: NASNonDeliveryIndicationProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct NASSecurityParametersfromE_UTRAN(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct NASSecurityParameterstoE_UTRAN(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct NB_IoT_DefaultPagingDRX(pub u8);
impl NB_IoT_DefaultPagingDRX {
    pub const V128: u8 = 0u8;
    pub const V256: u8 = 1u8;
    pub const V512: u8 = 2u8;
    pub const V1024: u8 = 3u8;
}
impl<'a> arbitrary::Arbitrary<'a> for NB_IoT_DefaultPagingDRX {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NB_IoT_DefaultPagingDRX(u.int_in_range(0..=3)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "13")]
pub struct NB_IoT_Paging_eDRX_Cycle(pub u8);
impl NB_IoT_Paging_eDRX_Cycle {
    pub const HF2: u8 = 0u8;
    pub const HF4: u8 = 1u8;
    pub const HF6: u8 = 2u8;
    pub const HF8: u8 = 3u8;
    pub const HF10: u8 = 4u8;
    pub const HF12: u8 = 5u8;
    pub const HF14: u8 = 6u8;
    pub const HF16: u8 = 7u8;
    pub const HF32: u8 = 8u8;
    pub const HF64: u8 = 9u8;
    pub const HF128: u8 = 10u8;
    pub const HF256: u8 = 11u8;
    pub const HF512: u8 = 12u8;
    pub const HF1024: u8 = 13u8;
}
impl<'a> arbitrary::Arbitrary<'a> for NB_IoT_Paging_eDRX_Cycle {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NB_IoT_Paging_eDRX_Cycle(u.int_in_range(0..=13)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct NB_IoT_Paging_eDRXInformation {
    pub nb_io_t_paging_e_drx_cycle: NB_IoT_Paging_eDRX_Cycle,
    #[asn(optional_idx = 0)]
    pub nb_io_t_paging_time_window: Option<NB_IoT_PagingTimeWindow>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<NB_IoT_Paging_eDRXInformationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for NB_IoT_Paging_eDRXInformation {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NB_IoT_Paging_eDRXInformation {
            nb_io_t_paging_e_drx_cycle: u.arbitrary()?,
            nb_io_t_paging_time_window: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct NB_IoT_PagingDRX(pub u8);
impl NB_IoT_PagingDRX {
    pub const V32: u8 = 0u8;
    pub const V64: u8 = 1u8;
    pub const V128: u8 = 2u8;
    pub const V256: u8 = 3u8;
    pub const V512: u8 = 4u8;
    pub const V1024: u8 = 5u8;
}
impl<'a> arbitrary::Arbitrary<'a> for NB_IoT_PagingDRX {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NB_IoT_PagingDRX(u.int_in_range(0..=5)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct NB_IoT_PagingTimeWindow(pub u8);
impl NB_IoT_PagingTimeWindow {
    pub const S1: u8 = 0u8;
    pub const S2: u8 = 1u8;
    pub const S3: u8 = 2u8;
    pub const S4: u8 = 3u8;
    pub const S5: u8 = 4u8;
    pub const S6: u8 = 5u8;
    pub const S7: u8 = 6u8;
    pub const S8: u8 = 7u8;
    pub const S9: u8 = 8u8;
    pub const S10: u8 = 9u8;
    pub const S11: u8 = 10u8;
    pub const S12: u8 = 11u8;
    pub const S13: u8 = 12u8;
    pub const S14: u8 = 13u8;
    pub const S15: u8 = 14u8;
    pub const S16: u8 = 15u8;
}
impl<'a> arbitrary::Arbitrary<'a> for NB_IoT_PagingTimeWindow {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NB_IoT_PagingTimeWindow(u.int_in_range(0..=15)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct NB_IoT_RLF_Report_Container(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "12", sz_ub = "12")]
pub struct NB_IoT_UEIdentityIndexValue(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for NB_IoT_UEIdentityIndexValue {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..12 {
            bv.push(u.arbitrary()?);
        }
        if 12 > 12 {
            for _ in 0..u.int_in_range(0..=12 - 12 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(NB_IoT_UEIdentityIndexValue(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NG_eNB {
    pub global_ng_e_nb_id: Global_ENB_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NG_eNBIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for NG_eNB {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NG_eNB {
            global_ng_e_nb_id: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NR_CGI {
    pub plmn_identity: PLMNidentity,
    pub nr_cell_identity: NRCellIdentity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NR_CGIIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for NR_CGI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NR_CGI {
            plmn_identity: u.arbitrary()?,
            nr_cell_identity: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "36", sz_ub = "36")]
pub struct NRCellIdentity(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for NRCellIdentity {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..36 {
            bv.push(u.arbitrary()?);
        }
        if 36 > 36 {
            for _ in 0..u.int_in_range(0..=36 - 36 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(NRCellIdentity(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRUESecurityCapabilities {
    pub n_rencryption_algorithms: NRencryptionAlgorithms,
    pub n_rintegrity_protection_algorithms: NRintegrityProtectionAlgorithms,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NRUESecurityCapabilitiesIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for NRUESecurityCapabilities {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NRUESecurityCapabilities {
            n_rencryption_algorithms: u.arbitrary()?,
            n_rintegrity_protection_algorithms: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct NRUESidelinkAggregateMaximumBitrate {
    pub u_eaggregate_maximum_bit_rate: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<NRUESidelinkAggregateMaximumBitrateIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for NRUESidelinkAggregateMaximumBitrate {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NRUESidelinkAggregateMaximumBitrate {
            u_eaggregate_maximum_bit_rate: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct NRV2XServicesAuthorized {
    #[asn(optional_idx = 0)]
    pub vehicle_ue: Option<VehicleUE>,
    #[asn(optional_idx = 1)]
    pub pedestrian_ue: Option<PedestrianUE>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<NRV2XServicesAuthorizedIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for NRV2XServicesAuthorized {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NRV2XServicesAuthorized {
            vehicle_ue: u.arbitrary()?,
            pedestrian_ue: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct NRencryptionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for NRencryptionAlgorithms {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..16 {
            bv.push(u.arbitrary()?);
        }
        if 16 > 16 {
            for _ in 0..u.int_in_range(0..=16 - 16 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(NRencryptionAlgorithms(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "16", sz_ub = "16")]
pub struct NRintegrityProtectionAlgorithms(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for NRintegrityProtectionAlgorithms {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..16 {
            bv.push(u.arbitrary()?);
        }
        if 16 > 16 {
            for _ in 0..u.int_in_range(0..=16 - 16 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(NRintegrityProtectionAlgorithms(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct NRrestrictionin5GS(pub u8);
impl NRrestrictionin5GS {
    pub const N_RRESTRICTEDIN5_GS: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for NRrestrictionin5GS {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NRrestrictionin5GS(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct NRrestrictioninEPSasSecondaryRAT(pub u8);
impl NRrestrictioninEPSasSecondaryRAT {
    pub const N_RRESTRICTEDIN_EP_SAS_SECONDARY_RAT: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for NRrestrictioninEPSasSecondaryRAT {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NRrestrictioninEPSasSecondaryRAT(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct NextPagingAreaScope(pub u8);
impl NextPagingAreaScope {
    pub const SAME: u8 = 0u8;
    pub const CHANGED: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for NextPagingAreaScope {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NextPagingAreaScope(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct NotificationCellList(pub Vec<NotificationCellList_Item>);
impl<'a> arbitrary::Arbitrary<'a> for NotificationCellList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(NotificationCellList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct NotificationCellList_Item {
    pub cell_id: NotificationCellList_ItemCell_ID,
    pub notify_flag: NotifyFlag,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct NotifyFlag(pub u8);
impl NotifyFlag {
    pub const ACTIVATED: u8 = 0u8;
    pub const DEACTIVATED: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for NotifyFlag {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NotifyFlag(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct NotifySourceeNB(pub u8);
impl NotifySourceeNB {
    pub const NOTIFY_SOURCE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for NotifySourceeNB {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NotifySourceeNB(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct NumberOfBroadcasts(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for NumberOfBroadcasts {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NumberOfBroadcasts(u.int_in_range(0..=65535)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct NumberOfMeasurementReportingLevels(pub u8);
impl NumberOfMeasurementReportingLevels {
    pub const RL2: u8 = 0u8;
    pub const RL3: u8 = 1u8;
    pub const RL4: u8 = 2u8;
    pub const RL5: u8 = 3u8;
    pub const RL10: u8 = 4u8;
}
impl<'a> arbitrary::Arbitrary<'a> for NumberOfMeasurementReportingLevels {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NumberOfMeasurementReportingLevels(u.int_in_range(0..=4)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct NumberofBroadcastRequest(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for NumberofBroadcastRequest {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(NumberofBroadcastRequest(u.int_in_range(0..=65535)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct OldBSS_ToNewBSS_Information(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct OverloadAction(pub u8);
impl OverloadAction {
    pub const REJECT_NON_EMERGENCY_MO_DT: u8 = 0u8;
    pub const REJECT_RRC_CR_SIGNALLING: u8 = 1u8;
    pub const PERMIT_EMERGENCY_SESSIONS_AND_MOBILE_TERMINATED_SERVICES_ONLY: u8 = 2u8;
}
impl<'a> arbitrary::Arbitrary<'a> for OverloadAction {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(OverloadAction(u.int_in_range(0..=2)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct OverloadFlag(pub u8);
impl OverloadFlag {
    pub const OVERLOAD: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for OverloadFlag {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(OverloadFlag(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum OverloadResponse {
    #[asn(key = 0, extended = false)]
    OverloadAction(OverloadAction),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct OverloadStart {
    pub protocol_i_es: OverloadStartProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct OverloadStop {
    pub protocol_i_es: OverloadStopProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PC5FlowBitRates {
    pub guaranteed_flow_bit_rate: BitRate,
    pub maximum_flow_bit_rate: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PC5FlowBitRatesIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for PC5FlowBitRates {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PC5FlowBitRates {
            guaranteed_flow_bit_rate: u.arbitrary()?,
            maximum_flow_bit_rate: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct PC5QoSFlowItem {
    pub pqi: FiveQI,
    #[asn(optional_idx = 0)]
    pub pc5_flow_bit_rates: Option<PC5FlowBitRates>,
    #[asn(optional_idx = 1)]
    pub range: Option<Range>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<PC5QoSFlowItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for PC5QoSFlowItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PC5QoSFlowItem {
            pqi: u.arbitrary()?,
            pc5_flow_bit_rates: u.arbitrary()?,
            range: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "2048"
)]
pub struct PC5QoSFlowList(pub Vec<PC5QoSFlowItem>);
impl<'a> arbitrary::Arbitrary<'a> for PC5QoSFlowList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=2048)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PC5QoSFlowList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PC5QoSParameters {
    pub pc5_qo_s_flow_list: PC5QoSFlowList,
    #[asn(optional_idx = 0)]
    pub pc5_link_aggregated_bit_rates: Option<BitRate>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PC5QoSParametersIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for PC5QoSParameters {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PC5QoSParameters {
            pc5_qo_s_flow_list: u.arbitrary()?,
            pc5_link_aggregated_bit_rates: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct PDCP_SN(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for PDCP_SN {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PDCP_SN(u.int_in_range(0..=4095)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "32767")]
pub struct PDCP_SNExtended(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for PDCP_SNExtended {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PDCP_SNExtended(u.int_in_range(0..=32767)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "262143")]
pub struct PDCP_SNlength18(pub u32);
impl<'a> arbitrary::Arbitrary<'a> for PDCP_SNlength18 {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PDCP_SNlength18(u.int_in_range(0..=262143)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PLMNAreaBasedQMC {
    pub plmn_listfor_qmc: PLMNListforQMC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PLMNAreaBasedQMCIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for PLMNAreaBasedQMC {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PLMNAreaBasedQMC {
            plmn_listfor_qmc: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct PLMNListforQMC(pub Vec<PLMNidentity>);
impl<'a> arbitrary::Arbitrary<'a> for PLMNListforQMC {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=16)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PLMNListforQMC(v))
    }
}

pub type PLMNidentity = TBCD_STRING;

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct PS_ServiceNotAvailable(pub u8);
impl PS_ServiceNotAvailable {
    pub const PS_SERVICE_NOT_AVAILABLE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for PS_ServiceNotAvailable {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PS_ServiceNotAvailable(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct PSCellInformation {
    pub ncgi: NR_CGI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<PSCellInformationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for PSCellInformation {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PSCellInformation {
            ncgi: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PWSFailureIndication {
    pub protocol_i_es: PWSFailureIndicationProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PWSRestartIndication {
    pub protocol_i_es: PWSRestartIndicationProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct PWSfailedECGIList(pub Vec<EUTRAN_CGI>);
impl<'a> arbitrary::Arbitrary<'a> for PWSfailedECGIList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PWSfailedECGIList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "1000")]
pub struct Packet_LossRate(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for Packet_LossRate {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Packet_LossRate(u.int_in_range(0..=1000)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct Paging {
    pub protocol_i_es: PagingProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "13")]
pub struct Paging_eDRX_Cycle(pub u8);
impl Paging_eDRX_Cycle {
    pub const HFHALF: u8 = 0u8;
    pub const HF1: u8 = 1u8;
    pub const HF2: u8 = 2u8;
    pub const HF4: u8 = 3u8;
    pub const HF6: u8 = 4u8;
    pub const HF8: u8 = 5u8;
    pub const HF10: u8 = 6u8;
    pub const HF12: u8 = 7u8;
    pub const HF14: u8 = 8u8;
    pub const HF16: u8 = 9u8;
    pub const HF32: u8 = 10u8;
    pub const HF64: u8 = 11u8;
    pub const HF128: u8 = 12u8;
    pub const HF256: u8 = 13u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Paging_eDRX_Cycle {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Paging_eDRX_Cycle(u.int_in_range(0..=13)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct Paging_eDRXInformation {
    pub paging_e_drx_cycle: Paging_eDRX_Cycle,
    #[asn(optional_idx = 0)]
    pub paging_time_window: Option<PagingTimeWindow>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<Paging_eDRXInformationIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "1", ub = "16", extensible = true)]
pub struct PagingAttemptCount(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for PagingAttemptCount {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PagingAttemptCount(u.int_in_range(1..=16)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct PagingAttemptInformation {
    pub paging_attempt_count: PagingAttemptCount,
    pub intended_number_of_paging_attempts: IntendedNumberOfPagingAttempts,
    #[asn(optional_idx = 0)]
    pub next_paging_area_scope: Option<NextPagingAreaScope>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<PagingAttemptInformationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for PagingAttemptInformation {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PagingAttemptInformation {
            paging_attempt_count: u.arbitrary()?,
            intended_number_of_paging_attempts: u.arbitrary()?,
            next_paging_area_scope: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct PagingDRX(pub u8);
impl PagingDRX {
    pub const V32: u8 = 0u8;
    pub const V64: u8 = 1u8;
    pub const V128: u8 = 2u8;
    pub const V256: u8 = 3u8;
}
impl<'a> arbitrary::Arbitrary<'a> for PagingDRX {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PagingDRX(u.int_in_range(0..=3)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "7")]
pub struct PagingPriority(pub u8);
impl PagingPriority {
    pub const PRIOLEVEL1: u8 = 0u8;
    pub const PRIOLEVEL2: u8 = 1u8;
    pub const PRIOLEVEL3: u8 = 2u8;
    pub const PRIOLEVEL4: u8 = 3u8;
    pub const PRIOLEVEL5: u8 = 4u8;
    pub const PRIOLEVEL6: u8 = 5u8;
    pub const PRIOLEVEL7: u8 = 6u8;
    pub const PRIOLEVEL8: u8 = 7u8;
}
impl<'a> arbitrary::Arbitrary<'a> for PagingPriority {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PagingPriority(u.int_in_range(0..=7)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "20")]
pub struct PagingProbabilityInformation(pub u8);
impl PagingProbabilityInformation {
    pub const P00: u8 = 0u8;
    pub const P05: u8 = 1u8;
    pub const P10: u8 = 2u8;
    pub const P15: u8 = 3u8;
    pub const P20: u8 = 4u8;
    pub const P25: u8 = 5u8;
    pub const P30: u8 = 6u8;
    pub const P35: u8 = 7u8;
    pub const P40: u8 = 8u8;
    pub const P45: u8 = 9u8;
    pub const P50: u8 = 10u8;
    pub const P55: u8 = 11u8;
    pub const P60: u8 = 12u8;
    pub const P65: u8 = 13u8;
    pub const P70: u8 = 14u8;
    pub const P75: u8 = 15u8;
    pub const P80: u8 = 16u8;
    pub const P85: u8 = 17u8;
    pub const P90: u8 = 18u8;
    pub const P95: u8 = 19u8;
    pub const P100: u8 = 20u8;
}
impl<'a> arbitrary::Arbitrary<'a> for PagingProbabilityInformation {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PagingProbabilityInformation(u.int_in_range(0..=20)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "15")]
pub struct PagingTimeWindow(pub u8);
impl PagingTimeWindow {
    pub const S1: u8 = 0u8;
    pub const S2: u8 = 1u8;
    pub const S3: u8 = 2u8;
    pub const S4: u8 = 3u8;
    pub const S5: u8 = 4u8;
    pub const S6: u8 = 5u8;
    pub const S7: u8 = 6u8;
    pub const S8: u8 = 7u8;
    pub const S9: u8 = 8u8;
    pub const S10: u8 = 9u8;
    pub const S11: u8 = 10u8;
    pub const S12: u8 = 11u8;
    pub const S13: u8 = 12u8;
    pub const S14: u8 = 13u8;
    pub const S15: u8 = 14u8;
    pub const S16: u8 = 15u8;
}
impl<'a> arbitrary::Arbitrary<'a> for PagingTimeWindow {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PagingTimeWindow(u.int_in_range(0..=15)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PathSwitchRequest {
    pub protocol_i_es: PathSwitchRequestProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PathSwitchRequestAcknowledge {
    pub protocol_i_es: PathSwitchRequestAcknowledgeProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PathSwitchRequestFailure {
    pub protocol_i_es: PathSwitchRequestFailureProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct PedestrianUE(pub u8);
impl PedestrianUE {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for PedestrianUE {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PedestrianUE(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct PendingDataIndication(pub u8);
impl PendingDataIndication {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for PendingDataIndication {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PendingDataIndication(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct Port_Number(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for Port_Number {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(2, std::cmp::min(10, u.int_in_range(2..=2)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(Port_Number(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct Pre_emptionCapability(pub u8);
impl Pre_emptionCapability {
    pub const SHALL_NOT_TRIGGER_PRE_EMPTION: u8 = 0u8;
    pub const MAY_TRIGGER_PRE_EMPTION: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Pre_emptionCapability {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Pre_emptionCapability(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", lb = "0", ub = "1")]
pub struct Pre_emptionVulnerability(pub u8);
impl Pre_emptionVulnerability {
    pub const NOT_PRE_EMPTABLE: u8 = 0u8;
    pub const PRE_EMPTABLE: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Pre_emptionVulnerability {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Pre_emptionVulnerability(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct Presence(pub u8);
impl Presence {
    pub const OPTIONAL: u8 = 0u8;
    pub const CONDITIONAL: u8 = 1u8;
    pub const MANDATORY: u8 = 2u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Presence {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Presence(u.int_in_range(0..=2)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "15")]
pub struct PriorityLevel(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for PriorityLevel {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PriorityLevel(u.int_in_range(0..=15)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct PrivacyIndicator(pub u8);
impl PrivacyIndicator {
    pub const IMMEDIATE_MDT: u8 = 0u8;
    pub const LOGGED_MDT: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for PrivacyIndicator {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PrivacyIndicator(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum PrivateIE_ID {
    #[asn(key = 0, extended = false)]
    Local(PrivateIE_ID_local),
    #[asn(key = 1, extended = false)]
    Global(PrivateIE_ID_global),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    arbitrary::Arbitrary,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct PrivateMessage {
    pub private_i_es: PrivateMessagePrivateIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct ProSeAuthorized {
    #[asn(optional_idx = 0)]
    pub pro_se_direct_discovery: Option<ProSeDirectDiscovery>,
    #[asn(optional_idx = 1)]
    pub pro_se_direct_communication: Option<ProSeDirectCommunication>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<ProSeAuthorizedIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ProSeDirectCommunication(pub u8);
impl ProSeDirectCommunication {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for ProSeDirectCommunication {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ProSeDirectCommunication(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ProSeDirectDiscovery(pub u8);
impl ProSeDirectDiscovery {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for ProSeDirectDiscovery {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ProSeDirectDiscovery(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ProSeUEtoNetworkRelaying(pub u8);
impl ProSeUEtoNetworkRelaying {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for ProSeUEtoNetworkRelaying {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ProSeUEtoNetworkRelaying(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct ProcedureCode(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for ProcedureCode {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ProcedureCode(u.int_in_range(0..=255)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct ProtocolExtensionID(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for ProtocolExtensionID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ProtocolExtensionID(u.int_in_range(0..=65535)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct ProtocolIE_ID(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for ProtocolIE_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ProtocolIE_ID(u.int_in_range(0..=65535)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct QCI(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for QCI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(QCI(u.int_in_range(0..=255)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "1", sz_ub = "1")]
pub struct RAC(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for RAC {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=1)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(RAC(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "4294967295")]
pub struct RAN_UE_NGAP_ID(pub u32);
impl<'a> arbitrary::Arbitrary<'a> for RAN_UE_NGAP_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(RAN_UE_NGAP_ID(u.int_in_range(0..=4294967295)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct RAT_Type(pub u8);
impl RAT_Type {
    pub const NBIOT: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for RAT_Type {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(RAT_Type(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct RIMInformation(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum RIMRoutingAddress {
    #[asn(key = 0, extended = false)]
    GERAN_Cell_ID(GERAN_Cell_ID),
    // Encode of extended choice not yet implemented
    //#[asn(key = 0, extended = true)]
    //TargetRNC_ID(TargetRNC_ID),
    //#[asn(key = 1, extended = true)]
    //EHRPD_Sector_ID(RIMRoutingAddress_eHRPD_Sector_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct RIMTransfer {
    pub rim_information: RIMInformation,
    #[asn(optional_idx = 0)]
    pub rim_routing_address: Option<RIMRoutingAddress>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<RIMTransferIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for RIMTransfer {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(RIMTransfer {
            rim_information: u.arbitrary()?,
            rim_routing_address: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct RLFReportInformation {
    pub ue_rlf_report_container: UE_RLF_Report_Container,
    #[asn(optional_idx = 0)]
    pub ue_rlf_report_container_for_extended_bands:
        Option<UE_RLF_Report_Container_for_extended_bands>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<RLFReportInformationIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct RNC_ID(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for RNC_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(RNC_ID(u.int_in_range(0..=4095)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct RRC_Container(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct RRC_Establishment_Cause(pub u8);
impl RRC_Establishment_Cause {
    pub const EMERGENCY: u8 = 0u8;
    pub const HIGH_PRIORITY_ACCESS: u8 = 1u8;
    pub const MT_ACCESS: u8 = 2u8;
    pub const MO_SIGNALLING: u8 = 3u8;
    pub const MO_DATA: u8 = 4u8;
}
impl<'a> arbitrary::Arbitrary<'a> for RRC_Establishment_Cause {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(RRC_Establishment_Cause(u.int_in_range(0..=4)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "8")]
pub struct Range(pub u8);
impl Range {
    pub const M50: u8 = 0u8;
    pub const M80: u8 = 1u8;
    pub const M180: u8 = 2u8;
    pub const M200: u8 = 3u8;
    pub const M350: u8 = 4u8;
    pub const M400: u8 = 5u8;
    pub const M500: u8 = 6u8;
    pub const M700: u8 = 7u8;
    pub const M1000: u8 = 8u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Range {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Range(u.int_in_range(0..=8)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "16384"
)]
pub struct ReceiveStatusOfULPDCPSDUsExtended(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for ReceiveStatusOfULPDCPSDUsExtended {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..1 {
            bv.push(u.arbitrary()?);
        }
        if 16384 > 1 {
            for _ in 0..u.int_in_range(0..=16384 - 1 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(ReceiveStatusOfULPDCPSDUsExtended(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "131072"
)]
pub struct ReceiveStatusOfULPDCPSDUsPDCP_SNlength18(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);
impl<'a> arbitrary::Arbitrary<'a> for ReceiveStatusOfULPDCPSDUsPDCP_SNlength18 {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..1 {
            bv.push(u.arbitrary()?);
        }
        if 131072 > 1 {
            for _ in 0..u.int_in_range(0..=131072 - 1 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(ReceiveStatusOfULPDCPSDUsPDCP_SNlength18(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "4096",
    sz_ub = "4096"
)]
pub struct ReceiveStatusofULPDCPSDUs(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for ReceiveStatusofULPDCPSDUs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..4096 {
            bv.push(u.arbitrary()?);
        }
        if 4096 > 4096 {
            for _ in 0..u.int_in_range(0..=4096 - 4096 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(ReceiveStatusofULPDCPSDUs(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct RecommendedCellItem {
    pub eutran_cgi: EUTRAN_CGI,
    #[asn(optional_idx = 0)]
    pub time_stayed_in_cell: Option<RecommendedCellItemTimeStayedInCell>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<RecommendedCellItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for RecommendedCellItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(RecommendedCellItem {
            eutran_cgi: u.arbitrary()?,
            time_stayed_in_cell: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct RecommendedCellList(pub Vec<RecommendedCellList_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for RecommendedCellList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=16)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(RecommendedCellList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RecommendedCellsForPaging {
    pub recommended_cell_list: RecommendedCellList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RecommendedCellsForPagingIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for RecommendedCellsForPaging {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(RecommendedCellsForPaging {
            recommended_cell_list: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RecommendedENBItem {
    pub mme_paging_target: MMEPagingTarget,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RecommendedENBItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for RecommendedENBItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(RecommendedENBItem {
            mme_paging_target: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct RecommendedENBList(pub Vec<RecommendedENBList_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for RecommendedENBList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=16)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(RecommendedENBList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RecommendedENBsForPaging {
    pub recommended_enb_list: RecommendedENBList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RecommendedENBsForPagingIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for RecommendedENBsForPaging {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(RecommendedENBsForPaging {
            recommended_enb_list: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct RelativeMMECapacity(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for RelativeMMECapacity {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(RelativeMMECapacity(u.int_in_range(0..=255)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct RelayNode_Indicator(pub u8);
impl RelayNode_Indicator {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for RelayNode_Indicator {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(RelayNode_Indicator(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct RepetitionPeriod(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for RepetitionPeriod {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(RepetitionPeriod(u.int_in_range(0..=4095)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", lb = "0", ub = "7")]
pub struct ReportAmountMDT(pub u8);
impl ReportAmountMDT {
    pub const R1: u8 = 0u8;
    pub const R2: u8 = 1u8;
    pub const R4: u8 = 2u8;
    pub const R8: u8 = 3u8;
    pub const R16: u8 = 4u8;
    pub const R32: u8 = 5u8;
    pub const R64: u8 = 6u8;
    pub const RINFINITY: u8 = 7u8;
}
impl<'a> arbitrary::Arbitrary<'a> for ReportAmountMDT {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ReportAmountMDT(u.int_in_range(0..=7)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ReportArea(pub u8);
impl ReportArea {
    pub const ECGI: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for ReportArea {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ReportArea(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", lb = "0", ub = "12")]
pub struct ReportIntervalMDT(pub u8);
impl ReportIntervalMDT {
    pub const MS120: u8 = 0u8;
    pub const MS240: u8 = 1u8;
    pub const MS480: u8 = 2u8;
    pub const MS640: u8 = 3u8;
    pub const MS1024: u8 = 4u8;
    pub const MS2048: u8 = 5u8;
    pub const MS5120: u8 = 6u8;
    pub const MS10240: u8 = 7u8;
    pub const MIN1: u8 = 8u8;
    pub const MIN6: u8 = 9u8;
    pub const MIN12: u8 = 10u8;
    pub const MIN30: u8 = 11u8;
    pub const MIN60: u8 = 12u8;
}
impl<'a> arbitrary::Arbitrary<'a> for ReportIntervalMDT {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ReportIntervalMDT(u.int_in_range(0..=12)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct ReportingCellList(pub Vec<ReportingCellList_Item>);
impl<'a> arbitrary::Arbitrary<'a> for ReportingCellList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=128)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ReportingCellList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ReportingCellList_Item {
    pub cell_id: IRAT_Cell_ID,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct RequestType {
    pub event_type: EventType,
    pub report_area: ReportArea,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<RequestTypeIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct RequestTypeAdditionalInfo(pub u8);
impl RequestTypeAdditionalInfo {
    pub const INCLUDE_PS_CELL: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for RequestTypeAdditionalInfo {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(RequestTypeAdditionalInfo(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "128"
)]
pub struct RequestedCellList(pub Vec<IRAT_Cell_ID>);
impl<'a> arbitrary::Arbitrary<'a> for RequestedCellList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=128)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(RequestedCellList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RerouteNASRequest {
    pub protocol_i_es: RerouteNASRequestProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct Reset {
    pub protocol_i_es: ResetProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct ResetAcknowledge {
    pub protocol_i_es: ResetAcknowledgeProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct ResetAll(pub u8);
impl ResetAll {
    pub const RESET_ALL: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for ResetAll {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ResetAll(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum ResetType {
    #[asn(key = 0, extended = false)]
    S1_Interface(ResetAll),
    #[asn(key = 1, extended = false)]
    PartOfS1_Interface(UE_associatedLogicalS1_ConnectionListRes),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct RetrieveUEInformation {
    pub protocol_i_es: RetrieveUEInformationProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct Routing_ID(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for Routing_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Routing_ID(u.int_in_range(0..=255)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct S_TMSI {
    pub mmec: MME_Code,
    pub m_tmsi: M_TMSI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<S_TMSIIE_Extensions>,
}



impl<'a> arbitrary::Arbitrary<'a> for S_TMSI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(S_TMSI {
            mmec: u.arbitrary()?,
            m_tmsi: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum S1AP_PDU {
    #[asn(key = 0, extended = false)]
    InitiatingMessage(InitiatingMessage),
    #[asn(key = 1, extended = false)]
    SuccessfulOutcome(SuccessfulOutcome),
    #[asn(key = 2, extended = false)]
    UnsuccessfulOutcome(UnsuccessfulOutcome),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct S1SetupFailure {
    pub protocol_i_es: S1SetupFailureProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct S1SetupRequest {
    pub protocol_i_es: S1SetupRequestProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct S1SetupResponse {
    pub protocol_i_es: S1SetupResponseProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SONConfigurationTransfer {
    pub targete_nb_id: TargeteNB_ID,
    pub sourcee_nb_id: SourceeNB_ID,
    pub son_information: SONInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SONConfigurationTransferIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum SONInformation {
    #[asn(key = 0, extended = false)]
    SONInformationRequest(SONInformationRequest),
    #[asn(key = 1, extended = false)]
    SONInformationReply(SONInformationReply),
    // Encode of extended choice not yet implemented
    //#[asn(key = 0, extended = true)]
    //SONInformation_Extension(SONInformation_Extension),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SONInformation_Extension {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SONInformation_ExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for SONInformation_Extension {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: SONInformation_ExtensionValue = u.arbitrary()?;
        Ok(SONInformation_Extension {
            id: ProtocolIE_ID(match value {
                SONInformation_ExtensionValue::Id_SON_Information_Report(_) => 206,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct SONInformationReply {
    #[asn(optional_idx = 0)]
    pub x2tnl_configuration_info: Option<X2TNLConfigurationInfo>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<SONInformationReplyIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum SONInformationReport {
    #[asn(key = 0, extended = false)]
    RLFReportInformation(RLFReportInformation),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SONInformationRequest(pub u8);
impl SONInformationRequest {
    pub const X2_TNL_CONFIGURATION_INFO: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for SONInformationRequest {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SONInformationRequest(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SONtransferApplicationIdentity(pub u8);
impl SONtransferApplicationIdentity {
    pub const CELL_LOAD_REPORTING: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for SONtransferApplicationIdentity {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SONtransferApplicationIdentity(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum SONtransferCause {
    #[asn(key = 0, extended = false)]
    CellLoadReporting(CellLoadReportingCause),
    // Encode of extended choice not yet implemented
    //#[asn(key = 0, extended = true)]
    //MultiCellLoadReporting(CellLoadReportingCause),
    //#[asn(key = 1, extended = true)]
    //EventTriggeredCellLoadReporting(CellLoadReportingCause),
    //#[asn(key = 2, extended = true)]
    //HOReporting(HOReportingCause),
    //#[asn(key = 3, extended = true)]
    //EutranCellActivation(CellActivationCause),
    //#[asn(key = 4, extended = true)]
    //EnergySavingsIndication(CellStateIndicationCause),
    //#[asn(key = 5, extended = true)]
    //FailureEventReporting(FailureEventReportingCause),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum SONtransferRequestContainer {
    #[asn(key = 0, extended = false)]
    CellLoadReporting(SONtransferRequestContainer_cellLoadReporting),
    // Encode of extended choice not yet implemented
    //#[asn(key = 0, extended = true)]
    //MultiCellLoadReporting(MultiCellLoadReportingRequest),
    //#[asn(key = 1, extended = true)]
    //EventTriggeredCellLoadReporting(EventTriggeredCellLoadReportingRequest),
    //#[asn(key = 2, extended = true)]
    //HOReporting(HOReport),
    //#[asn(key = 3, extended = true)]
    //EutranCellActivation(CellActivationRequest),
    //#[asn(key = 4, extended = true)]
    //EnergySavingsIndication(CellStateIndication),
    //#[asn(key = 5, extended = true)]
    //FailureEventReporting(FailureEventReport),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "0", extensible = true)]
pub enum SONtransferResponseContainer {
    #[asn(key = 0, extended = false)]
    CellLoadReporting(CellLoadReportingResponse),
    // Encode of extended choice not yet implemented
    //#[asn(key = 0, extended = true)]
    //MultiCellLoadReporting(MultiCellLoadReportingResponse),
    //#[asn(key = 1, extended = true)]
    //EventTriggeredCellLoadReporting(EventTriggeredCellLoadReportingResponse),
    //#[asn(key = 2, extended = true)]
    //HOReporting(SONtransferResponseContainer_hOReporting),
    //#[asn(key = 3, extended = true)]
    //EutranCellActivation(CellActivationResponse),
    //#[asn(key = 4, extended = true)]
    //EnergySavingsIndication(SONtransferResponseContainer_energySavingsIndication),
    //#[asn(key = 5, extended = true)]
    //FailureEventReporting(SONtransferResponseContainer_failureEventReporting),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct SRVCCHOIndication(pub u8);
impl SRVCCHOIndication {
    pub const P_SAND_CS: u8 = 0u8;
    pub const C_SONLY: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for SRVCCHOIndication {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SRVCCHOIndication(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SRVCCOperationNotPossible(pub u8);
impl SRVCCOperationNotPossible {
    pub const NOT_POSSIBLE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for SRVCCOperationNotPossible {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SRVCCOperationNotPossible(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SRVCCOperationPossible(pub u8);
impl SRVCCOperationPossible {
    pub const POSSIBLE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for SRVCCOperationPossible {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SRVCCOperationPossible(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct ScheduledCommunicationTime {
    #[asn(optional_idx = 0)]
    pub dayof_week: Option<ScheduledCommunicationTimeDayofWeek>,
    #[asn(optional_idx = 1)]
    pub timeof_day_start: Option<ScheduledCommunicationTimeTimeofDayStart>,
    #[asn(optional_idx = 2)]
    pub timeof_day_end: Option<ScheduledCommunicationTimeTimeofDayEnd>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<ScheduledCommunicationTimeIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for ScheduledCommunicationTime {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ScheduledCommunicationTime {
            dayof_week: u.arbitrary()?,
            timeof_day_start: u.arbitrary()?,
            timeof_day_end: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct SecondaryRATDataUsageReport {
    pub protocol_i_es: SecondaryRATDataUsageReportProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SecondaryRATDataUsageReportItem {
    pub e_rab_id: E_RAB_ID,
    pub secondary_rat_type: SecondaryRATType,
    pub e_rab_usage_report_list: E_RABUsageReportList,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SecondaryRATDataUsageReportItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for SecondaryRATDataUsageReportItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SecondaryRATDataUsageReportItem {
            e_rab_id: u.arbitrary()?,
            secondary_rat_type: u.arbitrary()?,
            e_rab_usage_report_list: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SecondaryRATDataUsageReportList(pub Vec<SecondaryRATDataUsageReportList_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for SecondaryRATDataUsageReportList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(SecondaryRATDataUsageReportList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SecondaryRATDataUsageRequest(pub u8);
impl SecondaryRATDataUsageRequest {
    pub const REQUESTED: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for SecondaryRATDataUsageRequest {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SecondaryRATDataUsageRequest(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct SecondaryRATType(pub u8);
impl SecondaryRATType {
    pub const N_R: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for SecondaryRATType {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SecondaryRATType(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SecurityContext {
    pub next_hop_chaining_count: SecurityContextNextHopChainingCount,
    pub next_hop_parameter: SecurityKey,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SecurityContextIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for SecurityContext {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SecurityContext {
            next_hop_chaining_count: u.arbitrary()?,
            next_hop_parameter: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "BITSTRING",
    sz_extensible = false,
    sz_lb = "256",
    sz_ub = "256"
)]
pub struct SecurityKey(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for SecurityKey {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..256 {
            bv.push(u.arbitrary()?);
        }
        if 256 > 256 {
            for _ in 0..u.int_in_range(0..=256 - 256 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(SecurityKey(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct SerialNumber(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for SerialNumber {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..16 {
            bv.push(u.arbitrary()?);
        }
        if 16 > 16 {
            for _ in 0..u.int_in_range(0..=16 - 16 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(SerialNumber(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "0", sz_ub = "32")]
pub struct ServedDCNs(pub Vec<ServedDCNsItem>);
impl<'a> arbitrary::Arbitrary<'a> for ServedDCNs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=32)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ServedDCNs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ServedDCNsItem {
    pub dcn_id: DCN_ID,
    pub relative_dcn_capacity: RelativeMMECapacity,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ServedDCNsItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for ServedDCNsItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ServedDCNsItem {
            dcn_id: u.arbitrary()?,
            relative_dcn_capacity: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct ServedGUMMEIs(pub Vec<ServedGUMMEIsItem>);
impl<'a> arbitrary::Arbitrary<'a> for ServedGUMMEIs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=8)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ServedGUMMEIs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct ServedGUMMEIsItem {
    pub served_plm_ns: ServedPLMNs,
    pub served_group_i_ds: ServedGroupIDs,
    pub served_mme_cs: ServedMMECs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<ServedGUMMEIsItemIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedGroupIDs(pub Vec<MME_Group_ID>);
impl<'a> arbitrary::Arbitrary<'a> for ServedGroupIDs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ServedGroupIDs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct ServedMMECs(pub Vec<MME_Code>);
impl<'a> arbitrary::Arbitrary<'a> for ServedMMECs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ServedMMECs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "32")]
pub struct ServedPLMNs(pub Vec<PLMNidentity>);
impl<'a> arbitrary::Arbitrary<'a> for ServedPLMNs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=32)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ServedPLMNs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct ServiceType(pub u8);
impl ServiceType {
    pub const Q_MC_FOR_STREAMING_SERVICE: u8 = 0u8;
    pub const Q_MC_FOR_MTSI_SERVICE: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for ServiceType {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ServiceType(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct Source_ToTarget_TransparentContainer(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct SourceBSS_ToTargetBSS_TransparentContainer(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SourceNgRanNode_ID {
    pub global_ran_node_id: Global_RAN_NODE_ID,
    pub selected_tai: FiveGSTAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SourceNgRanNode_IDIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for SourceNgRanNode_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SourceNgRanNode_ID {
            global_ran_node_id: u.arbitrary()?,
            selected_tai: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct SourceNgRanNode_ToTargetNgRanNode_TransparentContainer(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = false)]
pub enum SourceNodeID {
    #[asn(key = 0, extended = false)]
    SourceNgRanNode_ID(SourceNgRanNode_ID),
    #[asn(key = 1, extended = false)]
    SourceNodeID_Extension(SourceNodeID_Extension),
}

impl<'a> arbitrary::Arbitrary<'a> for SourceNodeID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SourceNodeID::SourceNgRanNode_ID(u.arbitrary()?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SourceNodeID_Extension {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct SourceOfUEActivityBehaviourInformation(pub u8);
impl SourceOfUEActivityBehaviourInformation {
    pub const SUBSCRIPTION_INFORMATION: u8 = 0u8;
    pub const STATISTICS: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for SourceOfUEActivityBehaviourInformation {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SourceOfUEActivityBehaviourInformation(
            u.int_in_range(0..=1)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct SourceRNC_ToTargetRNC_TransparentContainer(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false, optional_fields = 1)]
pub struct SourceeNB_ID {
    pub global_enb_id: Global_ENB_ID,
    pub selected_tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SourceeNB_IDIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for SourceeNB_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SourceeNB_ID {
            global_enb_id: u.arbitrary()?,
            selected_tai: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct SourceeNB_ToTargeteNB_TransparentContainer {
    pub rrc_container: RRC_Container,
    #[asn(optional_idx = 0)]
    pub e_rab_information_list: Option<E_RABInformationList>,
    pub target_cell_id: EUTRAN_CGI,
    #[asn(optional_idx = 1)]
    pub subscriber_profile_i_dfor_rfp: Option<SubscriberProfileIDforRFP>,
    pub ue_history_information: UE_HistoryInformation,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "3", extensible = true)]
pub struct StratumLevel(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for StratumLevel {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(StratumLevel(u.int_in_range(0..=3)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "1", ub = "256")]
pub struct SubscriberProfileIDforRFP(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for SubscriberProfileIDforRFP {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SubscriberProfileIDforRFP(u.int_in_range(1..=256)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 7)]
pub struct Subscription_Based_UE_DifferentiationInfo {
    #[asn(optional_idx = 0)]
    pub periodic_communication_indicator:
        Option<Subscription_Based_UE_DifferentiationInfoPeriodicCommunicationIndicator>,
    #[asn(optional_idx = 1)]
    pub periodic_time: Option<Subscription_Based_UE_DifferentiationInfoPeriodicTime>,
    #[asn(optional_idx = 2)]
    pub scheduled_communication_time: Option<ScheduledCommunicationTime>,
    #[asn(optional_idx = 3)]
    pub stationary_indication:
        Option<Subscription_Based_UE_DifferentiationInfoStationaryIndication>,
    #[asn(optional_idx = 4)]
    pub traffic_profile: Option<Subscription_Based_UE_DifferentiationInfoTrafficProfile>,
    #[asn(optional_idx = 5)]
    pub battery_indication: Option<Subscription_Based_UE_DifferentiationInfoBatteryIndication>,
    #[asn(optional_idx = 6)]
    pub ie_extensions: Option<Subscription_Based_UE_DifferentiationInfoIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for Subscription_Based_UE_DifferentiationInfo {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Subscription_Based_UE_DifferentiationInfo {
            periodic_communication_indicator: u.arbitrary()?,
            periodic_time: u.arbitrary()?,
            scheduled_communication_time: u.arbitrary()?,
            stationary_indication: u.arbitrary()?,
            traffic_profile: u.arbitrary()?,
            battery_indication: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SuccessfulOutcome {
    #[asn(key_field = true)]
    pub procedure_code: ProcedureCode,
    pub criticality: Criticality,
    pub value: SuccessfulOutcomeValue,
}

impl<'a> arbitrary::Arbitrary<'a> for SuccessfulOutcome {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: SuccessfulOutcomeValue = u.arbitrary()?;

        Ok(SuccessfulOutcome {
            procedure_code: ProcedureCode(match value {
                SuccessfulOutcomeValue::Id_E_RABModificationIndication(_) => 50,
                SuccessfulOutcomeValue::Id_E_RABModify(_) => 6,
                SuccessfulOutcomeValue::Id_E_RABRelease(_) => 7,
                SuccessfulOutcomeValue::Id_E_RABSetup(_) => 5,
                SuccessfulOutcomeValue::Id_ENBConfigurationUpdate(_) => 29,
                SuccessfulOutcomeValue::Id_HandoverCancel(_) => 4,
                SuccessfulOutcomeValue::Id_HandoverPreparation(_) => 0,
                SuccessfulOutcomeValue::Id_HandoverResourceAllocation(_) => 1,
                SuccessfulOutcomeValue::Id_InitialContextSetup(_) => 9,
                SuccessfulOutcomeValue::Id_Kill(_) => 43,
                SuccessfulOutcomeValue::Id_MMEConfigurationUpdate(_) => 30,
                SuccessfulOutcomeValue::Id_PathSwitchRequest(_) => 3,
                SuccessfulOutcomeValue::Id_Reset(_) => 14,
                SuccessfulOutcomeValue::Id_S1Setup(_) => 17,
                SuccessfulOutcomeValue::Id_UEContextModification(_) => 21,
                SuccessfulOutcomeValue::Id_UEContextModificationIndication(_) => 53,
                SuccessfulOutcomeValue::Id_UEContextRelease(_) => 23,
                SuccessfulOutcomeValue::Id_UEContextResume(_) => 56,
                SuccessfulOutcomeValue::Id_UEContextSuspend(_) => 55,
                SuccessfulOutcomeValue::Id_UERadioCapabilityIDMapping(_) => 63,
                SuccessfulOutcomeValue::Id_UERadioCapabilityMatch(_) => 48,
                SuccessfulOutcomeValue::Id_WriteReplaceWarning(_) => 36,
            }),
            criticality: Criticality(Criticality::REJECT), // TODO: fix?
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct SupportedTAs(pub Vec<SupportedTAs_Item>);
impl<'a> arbitrary::Arbitrary<'a> for SupportedTAs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(SupportedTAs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct SupportedTAs_Item {
    pub tac: TAC,
    pub broadcast_plm_ns: BPLMNs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<SupportedTAs_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for SupportedTAs_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SupportedTAs_Item {
            tac: u.arbitrary()?,
            broadcast_plm_ns: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct SynchronisationInformation {
    #[asn(optional_idx = 0)]
    pub source_stratum_level: Option<StratumLevel>,
    #[asn(optional_idx = 1)]
    pub listening_subframe_pattern: Option<ListeningSubframePattern>,
    #[asn(optional_idx = 2)]
    pub aggressore_cgi_list: Option<ECGI_List>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<SynchronisationInformationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for SynchronisationInformation {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SynchronisationInformation {
            source_stratum_level: u.arbitrary()?,
            listening_subframe_pattern: u.arbitrary()?,
            aggressore_cgi_list: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct SynchronisationStatus(pub u8);
impl SynchronisationStatus {
    pub const SYNCHRONOUS: u8 = 0u8;
    pub const ASYNCHRONOUS: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for SynchronisationStatus {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SynchronisationStatus(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TABasedMDT {
    pub ta_listfor_mdt: TAListforMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TABasedMDTIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for TABasedMDT {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TABasedMDT {
            ta_listfor_mdt: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TABasedQMC {
    pub ta_listfor_qmc: TAListforQMC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TABasedQMCIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for TABasedQMC {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TABasedQMC {
            ta_listfor_qmc: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct TAC(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for TAC {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(2, std::cmp::min(10, u.int_in_range(2..=2)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(TAC(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAI {
    pub plm_nidentity: PLMNidentity,
    pub tac: TAC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for TAI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TAI {
            plm_nidentity: u.arbitrary()?,
            tac: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAI_Broadcast(pub Vec<TAI_Broadcast_Item>);
impl<'a> arbitrary::Arbitrary<'a> for TAI_Broadcast {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TAI_Broadcast(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAI_Broadcast_Item {
    pub tai: TAI,
    pub completed_cellin_tai: CompletedCellinTAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAI_Broadcast_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for TAI_Broadcast_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TAI_Broadcast_Item {
            tai: u.arbitrary()?,
            completed_cellin_tai: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAI_Cancelled(pub Vec<TAI_Cancelled_Item>);
impl<'a> arbitrary::Arbitrary<'a> for TAI_Cancelled {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TAI_Cancelled(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAI_Cancelled_Item {
    pub tai: TAI,
    pub cancelled_cellin_tai: CancelledCellinTAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAI_Cancelled_ItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for TAI_Cancelled_Item {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TAI_Cancelled_Item {
            tai: u.arbitrary()?,
            cancelled_cellin_tai: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIBasedMDT {
    pub tai_listfor_mdt: TAIListforMDT,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIBasedMDTIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for TAIBasedMDT {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TAIBasedMDT {
            tai_listfor_mdt: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIBasedQMC {
    pub tai_listfor_qmc: TAIListforQMC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIBasedQMCIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for TAIBasedQMC {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TAIBasedQMC {
            tai_listfor_qmc: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TAIItem {
    pub tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TAIItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for TAIItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TAIItem {
            tai: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct TAIList(pub Vec<TAIList_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TAIList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TAIList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "2048"
)]
pub struct TAIListForRestart(pub Vec<TAI>);
impl<'a> arbitrary::Arbitrary<'a> for TAIListForRestart {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=2048)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TAIListForRestart(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAIListforMDT(pub Vec<TAI>);
impl<'a> arbitrary::Arbitrary<'a> for TAIListforMDT {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=8)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TAIListforMDT(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAIListforQMC(pub Vec<TAI>);
impl<'a> arbitrary::Arbitrary<'a> for TAIListforQMC {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=8)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TAIListforQMC(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIListforWarning(pub Vec<TAI>);
impl<'a> arbitrary::Arbitrary<'a> for TAIListforWarning {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TAIListforWarning(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAListforMDT(pub Vec<TAC>);
impl<'a> arbitrary::Arbitrary<'a> for TAListforMDT {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=8)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TAListforMDT(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "8")]
pub struct TAListforQMC(pub Vec<TAC>);
impl<'a> arbitrary::Arbitrary<'a> for TAListforQMC {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=8)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TAListforQMC(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "3", sz_ub = "3")]
pub struct TBCD_STRING(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for TBCD_STRING {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(3, std::cmp::min(10, u.int_in_range(3..=3)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(TBCD_STRING(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct Target_ToSource_TransparentContainer(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct TargetBSS_ToSourceBSS_TransparentContainer(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary::Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum TargetID {
    #[asn(key = 0, extended = false)]
    TargeteNB_ID(TargeteNB_ID),
    #[asn(key = 1, extended = false)]
    TargetRNC_ID(TargetRNC_ID),
    #[asn(key = 2, extended = false)]
    CGI(CGI),
    // Encode of extended choice not yet implemented
    //#[asn(key = 0, extended = true)]
    //TargetgNgRanNode_ID(TargetNgRanNode_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TargetNgRanNode_ID {
    pub global_ran_node_id: Global_RAN_NODE_ID,
    pub selected_tai: FiveGSTAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TargetNgRanNode_IDIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for TargetNgRanNode_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TargetNgRanNode_ID {
            global_ran_node_id: u.arbitrary()?,
            selected_tai: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct TargetNgRanNode_ToSourceNgRanNode_TransparentContainer(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct TargetRNC_ID {
    pub lai: LAI,
    #[asn(optional_idx = 0)]
    pub rac: Option<RAC>,
    pub rnc_id: RNC_ID,
    #[asn(optional_idx = 1)]
    pub extended_rnc_id: Option<ExtendedRNC_ID>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<TargetRNC_IDIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for TargetRNC_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TargetRNC_ID {
            lai: u.arbitrary()?,
            rac: u.arbitrary()?,
            rnc_id: u.arbitrary()?,
            extended_rnc_id: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct TargetRNC_ToSourceRNC_TransparentContainer(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TargeteNB_ID {
    pub global_enb_id: Global_ENB_ID,
    pub selected_tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TargeteNB_IDIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for TargeteNB_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TargeteNB_ID {
            global_enb_id: u.arbitrary()?,
            selected_tai: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TargeteNB_ToSourceeNB_TransparentContainer {
    pub rrc_container: RRC_Container,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "97")]
pub struct Threshold_RSRP(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for Threshold_RSRP {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Threshold_RSRP(u.int_in_range(0..=97)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "34")]
pub struct Threshold_RSRQ(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for Threshold_RSRQ {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Threshold_RSRQ(u.int_in_range(0..=34)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct Time_UE_StayedInCell(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for Time_UE_StayedInCell {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Time_UE_StayedInCell(u.int_in_range(0..=4095)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "40950")]
pub struct Time_UE_StayedInCell_EnhancedGranularity(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for Time_UE_StayedInCell_EnhancedGranularity {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Time_UE_StayedInCell_EnhancedGranularity(
            u.int_in_range(0..=40950)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct TimeSinceSecondaryNodeRelease(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for TimeSinceSecondaryNodeRelease {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(4, std::cmp::min(10, u.int_in_range(4..=4)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(TimeSinceSecondaryNodeRelease(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TimeSynchronisationInfo {
    pub stratum_level: StratumLevel,
    pub synchronisation_status: SynchronisationStatus,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TimeSynchronisationInfoIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct TimeToWait(pub u8);
impl TimeToWait {
    pub const V1S: u8 = 0u8;
    pub const V2S: u8 = 1u8;
    pub const V5S: u8 = 2u8;
    pub const V10S: u8 = 3u8;
    pub const V20S: u8 = 4u8;
    pub const V60S: u8 = 5u8;
}
impl<'a> arbitrary::Arbitrary<'a> for TimeToWait {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TimeToWait(u.int_in_range(0..=5)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TooEarlyInterRATHOReportReportFromEUTRAN {
    pub uerlf_report_container: TooEarlyInterRATHOReportReportFromEUTRANUERLFReportContainer,
    #[asn(optional_idx = 0)]
    pub mobility_information: Option<MobilityInformation>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct TraceActivation {
    pub e_utran_trace_id: E_UTRAN_Trace_ID,
    pub interfaces_to_trace: InterfacesToTrace,
    pub trace_depth: TraceDepth,
    pub trace_collection_entity_ip_address: TransportLayerAddress,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<TraceActivationIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "5")]
pub struct TraceDepth(pub u8);
impl TraceDepth {
    pub const MINIMUM: u8 = 0u8;
    pub const MEDIUM: u8 = 1u8;
    pub const MAXIMUM: u8 = 2u8;
    pub const MINIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION: u8 = 3u8;
    pub const MEDIUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION: u8 = 4u8;
    pub const MAXIMUM_WITHOUT_VENDOR_SPECIFIC_EXTENSION: u8 = 5u8;
}
impl<'a> arbitrary::Arbitrary<'a> for TraceDepth {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TraceDepth(u.int_in_range(0..=5)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct TraceFailureIndication {
    pub protocol_i_es: TraceFailureIndicationProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct TraceStart {
    pub protocol_i_es: TraceStartProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "1", ub = "99")]
pub struct TrafficLoadReductionIndication(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for TrafficLoadReductionIndication {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TrafficLoadReductionIndication(u.int_in_range(1..=99)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct TransportInformation {
    pub transport_layer_address: TransportLayerAddress,
    pub ul_gtp_teid: GTP_TEID,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = true, sz_lb = "1", sz_ub = "160")]
pub struct TransportLayerAddress(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for TransportLayerAddress {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..1 {
            bv.push(u.arbitrary()?);
        }
        if 160 > 1 {
            for _ in 0..u.int_in_range(0..=160 - 1 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(TransportLayerAddress(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", lb = "0", ub = "2")]
pub struct TriggeringMessage(pub u8);
impl TriggeringMessage {
    pub const INITIATING_MESSAGE: u8 = 0u8;
    pub const SUCCESSFUL_OUTCOME: u8 = 1u8;
    pub const UNSUCCESSFULL_OUTCOME: u8 = 2u8;
}
impl<'a> arbitrary::Arbitrary<'a> for TriggeringMessage {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TriggeringMessage(u.int_in_range(0..=2)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 2)]
pub struct TunnelInformation {
    pub transport_layer_address: TransportLayerAddress,
    #[asn(optional_idx = 0)]
    pub udp_port_number: Option<Port_Number>,
    #[asn(optional_idx = 1)]
    pub ie_extensions: Option<TunnelInformationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for TunnelInformation {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TunnelInformation {
            transport_layer_address: u.arbitrary()?,
            udp_port_number: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct TypeOfError(pub u8);
impl TypeOfError {
    pub const NOT_UNDERSTOOD: u8 = 0u8;
    pub const MISSING: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for TypeOfError {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(TypeOfError(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "8", sz_ub = "8")]
pub struct UE_Application_Layer_Measurement_Capability(
    pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>,
);
impl<'a> arbitrary::Arbitrary<'a> for UE_Application_Layer_Measurement_Capability {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..8 {
            bv.push(u.arbitrary()?);
        }
        if 8 > 8 {
            for _ in 0..u.int_in_range(0..=8 - 8 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(UE_Application_Layer_Measurement_Capability(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "16")]
pub struct UE_HistoryInformation(pub Vec<LastVisitedCell_Item>);
impl<'a> arbitrary::Arbitrary<'a> for UE_HistoryInformation {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=16)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UE_HistoryInformation(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct UE_HistoryInformationFromTheUE(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct UE_RLF_Report_Container(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct UE_RLF_Report_Container_for_extended_bands(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UE_RetentionInformation(pub u8);
impl UE_RetentionInformation {
    pub const UES_RETAINED: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for UE_RetentionInformation {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(UE_RetentionInformation(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UE_S1AP_ID_pair {
    pub mme_ue_s1ap_id: MME_UE_S1AP_ID,
    pub enb_ue_s1ap_id: ENB_UE_S1AP_ID,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UE_S1AP_ID_pairIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for UE_S1AP_ID_pair {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(UE_S1AP_ID_pair {
            mme_ue_s1ap_id: u.arbitrary()?,
            enb_ue_s1ap_id: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum UE_S1AP_IDs {
    #[asn(key = 0, extended = false)]
    UE_S1AP_ID_pair(UE_S1AP_ID_pair),
    #[asn(key = 1, extended = false)]
    MME_UE_S1AP_ID(MME_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct UE_Usage_Type(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for UE_Usage_Type {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(UE_Usage_Type(u.int_in_range(0..=255)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct UE_associatedLogicalS1_ConnectionItem {
    #[asn(optional_idx = 0)]
    pub mme_ue_s1ap_id: Option<MME_UE_S1AP_ID>,
    #[asn(optional_idx = 1)]
    pub enb_ue_s1ap_id: Option<ENB_UE_S1AP_ID>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<UE_associatedLogicalS1_ConnectionItemIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for UE_associatedLogicalS1_ConnectionItem {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(UE_associatedLogicalS1_ConnectionItem {
            mme_ue_s1ap_id: u.arbitrary()?,
            enb_ue_s1ap_id: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct UE_associatedLogicalS1_ConnectionListRes(
    pub Vec<UE_associatedLogicalS1_ConnectionListRes_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UE_associatedLogicalS1_ConnectionListRes {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UE_associatedLogicalS1_ConnectionListRes(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "256"
)]
pub struct UE_associatedLogicalS1_ConnectionListResAck(
    pub Vec<UE_associatedLogicalS1_ConnectionListResAck_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UE_associatedLogicalS1_ConnectionListResAck {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=256)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UE_associatedLogicalS1_ConnectionListResAck(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UEAggregateMaximumBitrate {
    pub u_eaggregate_maximum_bit_rate_dl: BitRate,
    pub u_eaggregate_maximum_bit_rate_ul: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UEAggregateMaximumBitrateIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UEAppLayerMeasConfig {
    pub container_for_app_layer_meas_config: UEAppLayerMeasConfigContainerForAppLayerMeasConfig,
    pub area_scope_of_qmc: AreaScopeOfQMC,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UEAppLayerMeasConfigIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UECapabilityInfoIndication {
    pub protocol_i_es: UECapabilityInfoIndicationProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UECapabilityInfoRequest(pub u8);
impl UECapabilityInfoRequest {
    pub const REQUESTED: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for UECapabilityInfoRequest {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(UECapabilityInfoRequest(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationConfirm {
    pub protocol_i_es: UEContextModificationConfirmProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationFailure {
    pub protocol_i_es: UEContextModificationFailureProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationIndication {
    pub protocol_i_es: UEContextModificationIndicationProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationRequest {
    pub protocol_i_es: UEContextModificationRequestProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextModificationResponse {
    pub protocol_i_es: UEContextModificationResponseProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextReleaseCommand {
    pub protocol_i_es: UEContextReleaseCommandProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextReleaseComplete {
    pub protocol_i_es: UEContextReleaseCompleteProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextReleaseRequest {
    pub protocol_i_es: UEContextReleaseRequestProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextResumeFailure {
    pub protocol_i_es: UEContextResumeFailureProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextResumeRequest {
    pub protocol_i_es: UEContextResumeRequestProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextResumeResponse {
    pub protocol_i_es: UEContextResumeResponseProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextSuspendRequest {
    pub protocol_i_es: UEContextSuspendRequestProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEContextSuspendResponse {
    pub protocol_i_es: UEContextSuspendResponseProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "10", sz_ub = "10")]
pub struct UEIdentityIndexValue(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for UEIdentityIndexValue {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..10 {
            bv.push(u.arbitrary()?);
        }
        if 10 > 10 {
            for _ in 0..u.int_in_range(0..=10 - 10 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(UEIdentityIndexValue(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UEInformationTransfer {
    pub protocol_i_es: UEInformationTransferProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "1", extensible = true)]
pub enum UEPagingID {
    #[asn(key = 0, extended = false)]
    S_TMSI(S_TMSI),
    #[asn(key = 1, extended = false)]
    IMSI(IMSI),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapability(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapabilityForPaging(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct UERadioCapabilityID(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityIDMappingRequest {
    pub protocol_i_es: UERadioCapabilityIDMappingRequestProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityIDMappingResponse {
    pub protocol_i_es: UERadioCapabilityIDMappingResponseProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityMatchRequest {
    pub protocol_i_es: UERadioCapabilityMatchRequestProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UERadioCapabilityMatchResponse {
    pub protocol_i_es: UERadioCapabilityMatchResponseProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UESecurityCapabilities {
    pub encryption_algorithms: EncryptionAlgorithms,
    pub integrity_protection_algorithms: IntegrityProtectionAlgorithms,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UESecurityCapabilitiesIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for UESecurityCapabilities {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(UESecurityCapabilities {
            encryption_algorithms: u.arbitrary()?,
            integrity_protection_algorithms: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UESidelinkAggregateMaximumBitrate {
    pub ue_sidelink_aggregate_maximum_bit_rate: BitRate,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UESidelinkAggregateMaximumBitrateIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for UESidelinkAggregateMaximumBitrate {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(UESidelinkAggregateMaximumBitrate {
            ue_sidelink_aggregate_maximum_bit_rate: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UEUserPlaneCIoTSupportIndicator(pub u8);
impl UEUserPlaneCIoTSupportIndicator {
    pub const SUPPORTED: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for UEUserPlaneCIoTSupportIndicator {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(UEUserPlaneCIoTSupportIndicator(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UL_CP_SecurityInformation {
    pub ul_nas_mac: UL_NAS_MAC,
    pub ul_nas_count: UL_NAS_Count,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UL_CP_SecurityInformationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for UL_CP_SecurityInformation {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(UL_CP_SecurityInformation {
            ul_nas_mac: u.arbitrary()?,
            ul_nas_count: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "5", sz_ub = "5")]
pub struct UL_NAS_Count(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for UL_NAS_Count {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..5 {
            bv.push(u.arbitrary()?);
        }
        if 5 > 5 {
            for _ in 0..u.int_in_range(0..=5 - 5 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(UL_NAS_Count(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "16", sz_ub = "16")]
pub struct UL_NAS_MAC(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for UL_NAS_MAC {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..16 {
            bv.push(u.arbitrary()?);
        }
        if 16 > 16 {
            for _ in 0..u.int_in_range(0..=16 - 16 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(UL_NAS_MAC(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "VisibleString")]
pub struct URI_Address(pub String);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct UnlicensedSpectrumRestriction(pub u8);
impl UnlicensedSpectrumRestriction {
    pub const UNLICENSED_RESTRICTED: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for UnlicensedSpectrumRestriction {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(UnlicensedSpectrumRestriction(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UnsuccessfulOutcome {
    #[asn(key_field = true)]
    pub procedure_code: ProcedureCode,
    pub criticality: Criticality,
    pub value: UnsuccessfulOutcomeValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UnsuccessfulOutcome {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UnsuccessfulOutcomeValue = u.arbitrary()?;

        Ok(UnsuccessfulOutcome {
            procedure_code: ProcedureCode(match value {
                UnsuccessfulOutcomeValue::Id_ENBConfigurationUpdate(_) => 29,
                UnsuccessfulOutcomeValue::Id_HandoverPreparation(_) => 0,
                UnsuccessfulOutcomeValue::Id_HandoverResourceAllocation(_) => 1,
                UnsuccessfulOutcomeValue::Id_InitialContextSetup(_) => 9,
                UnsuccessfulOutcomeValue::Id_MMEConfigurationUpdate(_) => 30,
                UnsuccessfulOutcomeValue::Id_PathSwitchRequest(_) => 3,
                UnsuccessfulOutcomeValue::Id_S1Setup(_) => 17,
                UnsuccessfulOutcomeValue::Id_UEContextModification(_) => 21,
                UnsuccessfulOutcomeValue::Id_UEContextResume(_) => 56,
            }),
            criticality: Criticality(Criticality::REJECT), // TODO: fix?
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkNASTransport {
    pub protocol_i_es: UplinkNASTransportProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkNonUEAssociatedLPPaTransport {
    pub protocol_i_es: UplinkNonUEAssociatedLPPaTransportProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkS1cdma2000tunnelling {
    pub protocol_i_es: UplinkS1cdma2000tunnellingProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct UplinkUEAssociatedLPPaTransport {
    pub protocol_i_es: UplinkUEAssociatedLPPaTransportProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct UserLocationInformation {
    pub eutran_cgi: EUTRAN_CGI,
    pub tai: TAI,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<UserLocationInformationIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 3)]
pub struct V2XServicesAuthorized {
    #[asn(optional_idx = 0)]
    pub vehicle_ue: Option<VehicleUE>,
    #[asn(optional_idx = 1)]
    pub pedestrian_ue: Option<PedestrianUE>,
    #[asn(optional_idx = 2)]
    pub ie_extensions: Option<V2XServicesAuthorizedIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct VehicleUE(pub u8);
impl VehicleUE {
    pub const AUTHORIZED: u8 = 0u8;
    pub const NOT_AUTHORIZED: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for VehicleUE {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(VehicleUE(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct VoiceSupportMatchIndicator(pub u8);
impl VoiceSupportMatchIndicator {
    pub const SUPPORTED: u8 = 0u8;
    pub const NOT_SUPPORTED: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for VoiceSupportMatchIndicator {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(VoiceSupportMatchIndicator(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct WLANMeasConfig(pub u8);
impl WLANMeasConfig {
    pub const SETUP: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for WLANMeasConfig {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(WLANMeasConfig(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE-OF", sz_extensible = false, sz_lb = "1", sz_ub = "4")]
pub struct WLANMeasConfigNameList(pub Vec<WLANName>);
impl<'a> arbitrary::Arbitrary<'a> for WLANMeasConfigNameList {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=4)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(WLANMeasConfigNameList(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 4)]
pub struct WLANMeasurementConfiguration {
    pub wlan_meas_config: WLANMeasConfig,
    #[asn(optional_idx = 0)]
    pub wlan_meas_config_name_list: Option<WLANMeasConfigNameList>,
    #[asn(optional_idx = 1)]
    pub wlan_rssi: Option<WLANMeasurementConfigurationWlan_rssi>,
    #[asn(optional_idx = 2)]
    pub wlan_rtt: Option<WLANMeasurementConfigurationWlan_rtt>,
    #[asn(optional_idx = 3)]
    pub ie_extensions: Option<WLANMeasurementConfigurationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for WLANMeasurementConfiguration {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(WLANMeasurementConfiguration {
            wlan_meas_config: u.arbitrary()?,
            wlan_meas_config_name_list: u.arbitrary()?,
            wlan_rssi: u.arbitrary()?,
            wlan_rtt: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "32"
)]
pub struct WLANName(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for WLANName {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=1)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(WLANName(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct WUS_Assistance_Information {
    pub paging_probability_information: PagingProbabilityInformation,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<WUS_Assistance_InformationIE_Extensions>,
}

impl<'a> arbitrary::Arbitrary<'a> for WUS_Assistance_Information {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(WUS_Assistance_Information {
            paging_probability_information: u.arbitrary()?,
            ie_extensions: None,
        })
    }
}


#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1024"
)]
pub struct WarningAreaCoordinates(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for WarningAreaCoordinates {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=1)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(WarningAreaCoordinates(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "CHOICE", lb = "0", ub = "2", extensible = true)]
pub enum WarningAreaList {
    #[asn(key = 0, extended = false)]
    CellIDList(ECGIList),
    #[asn(key = 1, extended = false)]
    TrackingAreaListforWarning(TAIListforWarning),
    #[asn(key = 2, extended = false)]
    EmergencyAreaIDList(EmergencyAreaIDList),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "9600"
)]
pub struct WarningMessageContents(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for WarningMessageContents {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=1)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(WarningMessageContents(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "50",
    sz_ub = "50"
)]
pub struct WarningSecurityInfo(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for WarningSecurityInfo {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(50, std::cmp::min(10, u.int_in_range(50..=50)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(WarningSecurityInfo(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "2", sz_ub = "2")]
pub struct WarningType(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for WarningType {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(2, std::cmp::min(10, u.int_in_range(2..=2)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(WarningType(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct WriteReplaceWarningRequest {
    pub protocol_i_es: WriteReplaceWarningRequestProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true)]
pub struct WriteReplaceWarningResponse {
    pub protocol_i_es: WriteReplaceWarningResponseProtocolIEs,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = true, optional_fields = 1)]
pub struct X2TNLConfigurationInfo {
    pub enbx2_transport_layer_addresses: ENBX2TLAs,
    #[asn(optional_idx = 0)]
    pub ie_extensions: Option<X2TNLConfigurationInfoIE_Extensions>,
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct ActivatedCellsList_ItemCell_ID(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Additional_GUTIIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Additional_GUTIIE_Extensions(pub Vec<Additional_GUTIIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for Additional_GUTIIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(Additional_GUTIIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AllocationAndRetentionPriorityIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AllocationAndRetentionPriorityIE_Extensions(
    pub Vec<AllocationAndRetentionPriorityIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for AllocationAndRetentionPriorityIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(AllocationAndRetentionPriorityIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "NULL")]
pub struct AreaScopeOfMDT_pLMNWide;

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AssistanceDataForCECapableUEsIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AssistanceDataForCECapableUEsIE_Extensions(
    pub Vec<AssistanceDataForCECapableUEsIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for AssistanceDataForCECapableUEsIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(AssistanceDataForCECapableUEsIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AssistanceDataForPagingIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AssistanceDataForPagingIE_Extensions(
    pub Vec<AssistanceDataForPagingIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for AssistanceDataForPagingIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(AssistanceDataForPagingIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct AssistanceDataForRecommendedCellsIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct AssistanceDataForRecommendedCellsIE_Extensions(
    pub Vec<AssistanceDataForRecommendedCellsIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for AssistanceDataForRecommendedCellsIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(AssistanceDataForRecommendedCellsIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Bearers_SubjectToEarlyStatusTransfer_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Bearers_SubjectToEarlyStatusTransfer_ItemIE_Extensions(
    pub Vec<Bearers_SubjectToEarlyStatusTransfer_ItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for Bearers_SubjectToEarlyStatusTransfer_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(Bearers_SubjectToEarlyStatusTransfer_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum Bearers_SubjectToEarlyStatusTransferList_EntryValue {
    #[asn(key = 322)]
    Id_Bearers_SubjectToEarlyStatusTransfer_Item(Bearers_SubjectToEarlyStatusTransfer_Item),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Bearers_SubjectToEarlyStatusTransferList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: Bearers_SubjectToEarlyStatusTransferList_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for Bearers_SubjectToEarlyStatusTransferList_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: Bearers_SubjectToEarlyStatusTransferList_EntryValue = u.arbitrary()?;
        Ok(Bearers_SubjectToEarlyStatusTransferList_Entry {
            id: ProtocolIE_ID(match value {
                Bearers_SubjectToEarlyStatusTransferList_EntryValue::Id_Bearers_SubjectToEarlyStatusTransfer_Item(_) => 322
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum Bearers_SubjectToStatusTransfer_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 180)]
    Id_DLCOUNTValueExtended(COUNTValueExtended),
    #[asn(key = 218)]
    Id_DLCOUNTValuePDCP_SNlength18(COUNTvaluePDCP_SNlength18),
    #[asn(key = 181)]
    Id_ReceiveStatusOfULPDCPSDUsExtended(ReceiveStatusOfULPDCPSDUsExtended),
    #[asn(key = 219)]
    Id_ReceiveStatusOfULPDCPSDUsPDCP_SNlength18(ReceiveStatusOfULPDCPSDUsPDCP_SNlength18),
    #[asn(key = 179)]
    Id_ULCOUNTValueExtended(COUNTValueExtended),
    #[asn(key = 217)]
    Id_ULCOUNTValuePDCP_SNlength18(COUNTvaluePDCP_SNlength18),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Bearers_SubjectToStatusTransfer_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: Bearers_SubjectToStatusTransfer_ItemIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for Bearers_SubjectToStatusTransfer_ItemIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: Bearers_SubjectToStatusTransfer_ItemIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(Bearers_SubjectToStatusTransfer_ItemIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                Bearers_SubjectToStatusTransfer_ItemIE_Extensions_EntryExtensionValue::Id_DLCOUNTValueExtended(_) => 180,
                Bearers_SubjectToStatusTransfer_ItemIE_Extensions_EntryExtensionValue::Id_DLCOUNTValuePDCP_SNlength18(_) => 218,
                Bearers_SubjectToStatusTransfer_ItemIE_Extensions_EntryExtensionValue::Id_ReceiveStatusOfULPDCPSDUsExtended(_) => 181,
                Bearers_SubjectToStatusTransfer_ItemIE_Extensions_EntryExtensionValue::Id_ReceiveStatusOfULPDCPSDUsPDCP_SNlength18(_) => 219,
                Bearers_SubjectToStatusTransfer_ItemIE_Extensions_EntryExtensionValue::Id_ULCOUNTValueExtended(_) => 179,
                Bearers_SubjectToStatusTransfer_ItemIE_Extensions_EntryExtensionValue::Id_ULCOUNTValuePDCP_SNlength18(_) => 217,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Bearers_SubjectToStatusTransfer_ItemIE_Extensions(
    pub Vec<Bearers_SubjectToStatusTransfer_ItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for Bearers_SubjectToStatusTransfer_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(Bearers_SubjectToStatusTransfer_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum Bearers_SubjectToStatusTransferList_EntryValue {
    #[asn(key = 89)]
    Id_Bearers_SubjectToStatusTransfer_Item(Bearers_SubjectToStatusTransfer_Item),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Bearers_SubjectToStatusTransferList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: Bearers_SubjectToStatusTransferList_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for Bearers_SubjectToStatusTransferList_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: Bearers_SubjectToStatusTransferList_EntryValue = u.arbitrary()?;
        Ok(Bearers_SubjectToStatusTransferList_Entry {
            id: ProtocolIE_ID(match value {
                Bearers_SubjectToStatusTransferList_EntryValue::Id_Bearers_SubjectToStatusTransfer_Item(_) => 89,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct BluetoothMeasurementConfigurationBt_rssi(pub u8);
impl BluetoothMeasurementConfigurationBt_rssi {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for BluetoothMeasurementConfigurationBt_rssi {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(BluetoothMeasurementConfigurationBt_rssi(
            u.int_in_range(0..=0)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct BluetoothMeasurementConfigurationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct BluetoothMeasurementConfigurationIE_Extensions(
    pub Vec<BluetoothMeasurementConfigurationIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for BluetoothMeasurementConfigurationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(BluetoothMeasurementConfigurationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CGIIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CGIIE_Extensions(pub Vec<CGIIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for CGIIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CGIIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CNTypeRestrictions_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CNTypeRestrictions_ItemIE_Extensions(
    pub Vec<CNTypeRestrictions_ItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for CNTypeRestrictions_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CNTypeRestrictions_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct COUNTValueExtendedIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct COUNTValueExtendedIE_Extensions(pub Vec<COUNTValueExtendedIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for COUNTValueExtendedIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(COUNTValueExtendedIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct COUNTvalueIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct COUNTvalueIE_Extensions(pub Vec<COUNTvalueIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for COUNTvalueIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(COUNTvalueIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct COUNTvaluePDCP_SNlength18IE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct COUNTvaluePDCP_SNlength18IE_Extensions(
    pub Vec<COUNTvaluePDCP_SNlength18IE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for COUNTvaluePDCP_SNlength18IE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(COUNTvaluePDCP_SNlength18IE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSG_IdList_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CSG_IdList_ItemIE_Extensions(pub Vec<CSG_IdList_ItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for CSG_IdList_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CSG_IdList_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CSGMembershipInfoIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CSGMembershipInfoIE_Extensions(pub Vec<CSGMembershipInfoIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for CSGMembershipInfoIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CSGMembershipInfoIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CancelledCellinEAI_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellinEAI_ItemIE_Extensions(
    pub Vec<CancelledCellinEAI_ItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for CancelledCellinEAI_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CancelledCellinEAI_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CancelledCellinTAI_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CancelledCellinTAI_ItemIE_Extensions(
    pub Vec<CancelledCellinTAI_ItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for CancelledCellinTAI_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CancelledCellinTAI_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "503")]
pub struct CandidatePCIPCI(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for CandidatePCIPCI {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CandidatePCIPCI(u.int_in_range(0..=503)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct CandidatePCIEARFCN(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Cdma2000OneXSRVCCInfoIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Cdma2000OneXSRVCCInfoIE_Extensions(pub Vec<Cdma2000OneXSRVCCInfoIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for Cdma2000OneXSRVCCInfoIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(Cdma2000OneXSRVCCInfoIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "1", ub = "60")]
pub struct CellActivationRequestMinimumActivationTime(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for CellActivationRequestMinimumActivationTime {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(CellActivationRequestMinimumActivationTime(
            u.int_in_range(1..=60)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellBasedMDTIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellBasedMDTIE_Extensions(pub Vec<CellBasedMDTIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for CellBasedMDTIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CellBasedMDTIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellBasedQMCIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellBasedQMCIE_Extensions(pub Vec<CellBasedQMCIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for CellBasedQMCIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CellBasedQMCIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellID_Broadcast_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellID_Broadcast_ItemIE_Extensions(pub Vec<CellID_Broadcast_ItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for CellID_Broadcast_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CellID_Broadcast_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellID_Cancelled_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellID_Cancelled_ItemIE_Extensions(pub Vec<CellID_Cancelled_ItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for CellID_Cancelled_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CellID_Cancelled_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellIdentifierAndCELevelForCECapableUEsIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellIdentifierAndCELevelForCECapableUEsIE_Extensions(
    pub Vec<CellIdentifierAndCELevelForCECapableUEsIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for CellIdentifierAndCELevelForCECapableUEsIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CellIdentifierAndCELevelForCECapableUEsIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct CellLoadReportingResponse_uTRAN(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct CellLoadReportingResponse_gERAN(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum CellTrafficTraceProtocolIEs_EntryValue {
    #[asn(key = 86)]
    Id_E_UTRAN_Trace_ID(E_UTRAN_Trace_ID),
    #[asn(key = 100)]
    Id_EUTRAN_CGI(EUTRAN_CGI),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 166)]
    Id_PrivacyIndicator(PrivacyIndicator),
    #[asn(key = 131)]
    Id_TraceCollectionEntityIPAddress(TransportLayerAddress),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellTrafficTraceProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: CellTrafficTraceProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for CellTrafficTraceProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: CellTrafficTraceProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(CellTrafficTraceProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                CellTrafficTraceProtocolIEs_EntryValue::Id_E_UTRAN_Trace_ID(_) => 86,
                CellTrafficTraceProtocolIEs_EntryValue::Id_EUTRAN_CGI(_) => 100,
                CellTrafficTraceProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                CellTrafficTraceProtocolIEs_EntryValue::Id_PrivacyIndicator(_) => 166,
                CellTrafficTraceProtocolIEs_EntryValue::Id_TraceCollectionEntityIPAddress(_) => 131,
                CellTrafficTraceProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct CellTrafficTraceProtocolIEs(pub Vec<CellTrafficTraceProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for CellTrafficTraceProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CellTrafficTraceProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CellTypeIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CellTypeIE_Extensions(pub Vec<CellTypeIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for CellTypeIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CellTypeIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct CellsToActivateList_ItemCell_ID(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompletedCellinEAI_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellinEAI_ItemIE_Extensions(
    pub Vec<CompletedCellinEAI_ItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for CompletedCellinEAI_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CompletedCellinEAI_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CompletedCellinTAI_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CompletedCellinTAI_ItemIE_Extensions(
    pub Vec<CompletedCellinTAI_ItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for CompletedCellinTAI_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CompletedCellinTAI_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ConnectedengNBItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ConnectedengNBItemIE_Extensions(pub Vec<ConnectedengNBItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ConnectedengNBItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ConnectedengNBItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum ConnectionEstablishmentIndicationProtocolIEs_EntryValue {
    #[asn(key = 271)]
    Id_CE_ModeBRestricted(CE_ModeBRestricted),
    #[asn(key = 253)]
    Id_DL_CP_SecurityInformation(DL_CP_SecurityInformation),
    #[asn(key = 280)]
    Id_EndIndication(EndIndication),
    #[asn(key = 251)]
    Id_EnhancedCoverageRestricted(EnhancedCoverageRestricted),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 278)]
    Id_Subscription_Based_UE_DifferentiationInfo(Subscription_Based_UE_DifferentiationInfo),
    #[asn(key = 252)]
    Id_UE_Level_QoS_Parameters(E_RABLevelQoSParameters),
    #[asn(key = 74)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ConnectionEstablishmentIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ConnectionEstablishmentIndicationProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for ConnectionEstablishmentIndicationProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: ConnectionEstablishmentIndicationProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(ConnectionEstablishmentIndicationProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_CE_ModeBRestricted(_) => 271,
                ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_DL_CP_SecurityInformation(_) => 253,
                ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_EndIndication(_) => 280,
                ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_EnhancedCoverageRestricted(_) => 251,
                ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_Subscription_Based_UE_DifferentiationInfo(_) => 278,
                ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_UE_Level_QoS_Parameters(_) => 252,
                ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_UERadioCapability(_) => 74,
                ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_UERadioCapabilityID(_) => 314,
                ConnectionEstablishmentIndicationProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ConnectionEstablishmentIndicationProtocolIEs(
    pub Vec<ConnectionEstablishmentIndicationProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for ConnectionEstablishmentIndicationProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ConnectionEstablishmentIndicationProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ContextatSourceIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ContextatSourceIE_Extensions(pub Vec<ContextatSourceIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ContextatSourceIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ContextatSourceIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CriticalityDiagnosticsIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CriticalityDiagnosticsIE_Extensions(pub Vec<CriticalityDiagnosticsIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for CriticalityDiagnosticsIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CriticalityDiagnosticsIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct CriticalityDiagnostics_IE_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct CriticalityDiagnostics_IE_ItemIE_Extensions(
    pub Vec<CriticalityDiagnostics_IE_ItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for CriticalityDiagnostics_IE_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(CriticalityDiagnostics_IE_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct DAPSRequestInfoDAPSIndicator(pub u8);
impl DAPSRequestInfoDAPSIndicator {
    pub const D_APS_HO_REQUIRED: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for DAPSRequestInfoDAPSIndicator {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(DAPSRequestInfoDAPSIndicator(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSRequestInfoIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DAPSRequestInfoIE_Extensions(pub Vec<DAPSRequestInfoIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for DAPSRequestInfoIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(DAPSRequestInfoIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct DAPSResponseInfoDapsresponseindicator(pub u8);
impl DAPSResponseInfoDapsresponseindicator {
    pub const D_APS_HO_ACCEPTED: u8 = 0u8;
    pub const D_APS_HO_NOT_ACCEPTED: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a> for DAPSResponseInfoDapsresponseindicator {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(DAPSResponseInfoDapsresponseindicator(
            u.int_in_range(0..=1)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSResponseInfoIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DAPSResponseInfoIE_Extensions(pub Vec<DAPSResponseInfoIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for DAPSResponseInfoIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(DAPSResponseInfoIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSResponseInfoItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DAPSResponseInfoItemIE_Extensions(pub Vec<DAPSResponseInfoItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for DAPSResponseInfoItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(DAPSResponseInfoItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum DAPSResponseInfoList_EntryValue {
    #[asn(key = 319)]
    Id_DAPSResponseInfoItem(DAPSResponseInfoItem),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DAPSResponseInfoList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DAPSResponseInfoList_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for DAPSResponseInfoList_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: DAPSResponseInfoList_EntryValue = u.arbitrary()?;
        Ok(DAPSResponseInfoList_Entry {
            id: ProtocolIE_ID(match value {
                DAPSResponseInfoList_EntryValue::Id_DAPSResponseInfoItem(_) => 319,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DL_CP_SecurityInformationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct DL_CP_SecurityInformationIE_Extensions(
    pub Vec<DL_CP_SecurityInformationIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for DL_CP_SecurityInformationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(DL_CP_SecurityInformationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum DeactivateTraceProtocolIEs_EntryValue {
    #[asn(key = 86)]
    Id_E_UTRAN_Trace_ID(E_UTRAN_Trace_ID),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DeactivateTraceProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DeactivateTraceProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for DeactivateTraceProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: DeactivateTraceProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(DeactivateTraceProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                DeactivateTraceProtocolIEs_EntryValue::Id_E_UTRAN_Trace_ID(_) => 86,
                DeactivateTraceProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                DeactivateTraceProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DeactivateTraceProtocolIEs(pub Vec<DeactivateTraceProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for DeactivateTraceProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(DeactivateTraceProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum DownlinkNASTransportProtocolIEs_EntryValue {
    #[asn(key = 299)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 271)]
    Id_CE_ModeBRestricted(CE_ModeBRestricted),
    #[asn(key = 249)]
    Id_DLNASPDUDeliveryAckRequest(DLNASPDUDeliveryAckRequest),
    #[asn(key = 280)]
    Id_EndIndication(EndIndication),
    #[asn(key = 251)]
    Id_EnhancedCoverageRestricted(EnhancedCoverageRestricted),
    #[asn(key = 41)]
    Id_HandoverRestrictionList(HandoverRestrictionList),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 26)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 269)]
    Id_NRUESecurityCapabilities(NRUESecurityCapabilities),
    #[asn(key = 283)]
    Id_PendingDataIndication(PendingDataIndication),
    #[asn(key = 124)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 106)]
    Id_SubscriberProfileIDforRFP(SubscriberProfileIDforRFP),
    #[asn(key = 278)]
    Id_Subscription_Based_UE_DifferentiationInfo(Subscription_Based_UE_DifferentiationInfo),
    #[asn(key = 275)]
    Id_UECapabilityInfoRequest(UECapabilityInfoRequest),
    #[asn(key = 74)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkNASTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkNASTransportProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for DownlinkNASTransportProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: DownlinkNASTransportProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(DownlinkNASTransportProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                DownlinkNASTransportProtocolIEs_EntryValue::Id_AdditionalRRMPriorityIndex(_) => 299,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_CE_ModeBRestricted(_) => 271,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_DLNASPDUDeliveryAckRequest(_) => 349,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_EndIndication(_) => 280,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_EnhancedCoverageRestricted(_) => 251,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_HandoverRestrictionList(_) => 41,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_NAS_PDU(_) => 26,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_NRUESecurityCapabilities(_) => 269,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_PendingDataIndication(_) => 283,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_SRVCCOperationPossible(_) => 124,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_SubscriberProfileIDforRFP(_) => 106,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_Subscription_Based_UE_DifferentiationInfo(_) => 278,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_UECapabilityInfoRequest(_) => 275,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_UERadioCapability(_) => 74,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_UERadioCapabilityID(_) => 314,
                DownlinkNASTransportProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkNASTransportProtocolIEs(pub Vec<DownlinkNASTransportProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for DownlinkNASTransportProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(DownlinkNASTransportProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum DownlinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 147)]
    Id_LPPa_PDU(LPPa_PDU),
    #[asn(key = 148)]
    Id_Routing_ID(Routing_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkNonUEAssociatedLPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for DownlinkNonUEAssociatedLPPaTransportProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: DownlinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(DownlinkNonUEAssociatedLPPaTransportProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                DownlinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue::Id_LPPa_PDU(_) => 147,
                DownlinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue::Id_Routing_ID(_) => 148,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkNonUEAssociatedLPPaTransportProtocolIEs(
    pub Vec<DownlinkNonUEAssociatedLPPaTransportProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for DownlinkNonUEAssociatedLPPaTransportProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(DownlinkNonUEAssociatedLPPaTransportProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum DownlinkS1cdma2000tunnellingProtocolIEs_EntryValue {
    #[asn(key = 12)]
    Id_E_RABSubjecttoDataForwardingList(E_RABSubjecttoDataForwardingList),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 83)]
    Id_cdma2000HOStatus(Cdma2000HOStatus),
    #[asn(key = 70)]
    Id_cdma2000PDU(Cdma2000PDU),
    #[asn(key = 71)]
    Id_cdma2000RATType(Cdma2000RATType),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkS1cdma2000tunnellingProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkS1cdma2000tunnellingProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for DownlinkS1cdma2000tunnellingProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: DownlinkS1cdma2000tunnellingProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(DownlinkS1cdma2000tunnellingProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                DownlinkS1cdma2000tunnellingProtocolIEs_EntryValue::Id_E_RABSubjecttoDataForwardingList(_) => 12,
                DownlinkS1cdma2000tunnellingProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                DownlinkS1cdma2000tunnellingProtocolIEs_EntryValue::Id_cdma2000HOStatus(_) => 83,
                DownlinkS1cdma2000tunnellingProtocolIEs_EntryValue::Id_cdma2000PDU(_) => 70,
                DownlinkS1cdma2000tunnellingProtocolIEs_EntryValue::Id_cdma2000RATType(_) => 71,
                DownlinkS1cdma2000tunnellingProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkS1cdma2000tunnellingProtocolIEs(
    pub Vec<DownlinkS1cdma2000tunnellingProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for DownlinkS1cdma2000tunnellingProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(DownlinkS1cdma2000tunnellingProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum DownlinkUEAssociatedLPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 147)]
    Id_LPPa_PDU(LPPa_PDU),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 148)]
    Id_Routing_ID(Routing_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct DownlinkUEAssociatedLPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: DownlinkUEAssociatedLPPaTransportProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for DownlinkUEAssociatedLPPaTransportProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: DownlinkUEAssociatedLPPaTransportProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(DownlinkUEAssociatedLPPaTransportProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                DownlinkUEAssociatedLPPaTransportProtocolIEs_EntryValue::Id_LPPa_PDU(_) => 147,
                DownlinkUEAssociatedLPPaTransportProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                DownlinkUEAssociatedLPPaTransportProtocolIEs_EntryValue::Id_Routing_ID(_) => 148,
                DownlinkUEAssociatedLPPaTransportProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct DownlinkUEAssociatedLPPaTransportProtocolIEs(
    pub Vec<DownlinkUEAssociatedLPPaTransportProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for DownlinkUEAssociatedLPPaTransportProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(DownlinkUEAssociatedLPPaTransportProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABAdmittedItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABAdmittedItemIE_Extensions(pub Vec<E_RABAdmittedItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABAdmittedItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABAdmittedItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABAdmittedList_EntryValue {
    #[asn(key = 20)]
    Id_E_RABAdmittedItem(E_RABAdmittedItem),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABAdmittedList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABAdmittedList_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABAdmittedList_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABAdmittedList_EntryValue = u.arbitrary()?;
        Ok(E_RABAdmittedList_Entry {
            id: ProtocolIE_ID(match value {
                E_RABAdmittedList_EntryValue::Id_E_RABAdmittedItem(_) => 20,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABDataForwardingItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABDataForwardingItemIE_Extensions(
    pub Vec<E_RABDataForwardingItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABDataForwardingItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABDataForwardingItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABFailedToResumeItemResumeReqIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABFailedToResumeItemResumeReqIE_Extensions(
    pub Vec<E_RABFailedToResumeItemResumeReqIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABFailedToResumeItemResumeReqIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABFailedToResumeItemResumeReqIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABFailedToResumeItemResumeResIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABFailedToResumeItemResumeResIE_Extensions(
    pub Vec<E_RABFailedToResumeItemResumeResIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABFailedToResumeItemResumeResIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABFailedToResumeItemResumeResIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABFailedToResumeListResumeReq_EntryValue {
    #[asn(key = 236)]
    Id_E_RABFailedToResumeItemResumeReq(E_RABFailedToResumeItemResumeReq),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABFailedToResumeListResumeReq_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABFailedToResumeListResumeReq_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABFailedToResumeListResumeReq_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABFailedToResumeListResumeReq_EntryValue = u.arbitrary()?;
        Ok(E_RABFailedToResumeListResumeReq_Entry {
            id: ProtocolIE_ID(match value {
                E_RABFailedToResumeListResumeReq_EntryValue::Id_E_RABFailedToResumeItemResumeReq(_) => 236,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABFailedToResumeListResumeRes_EntryValue {
    #[asn(key = 238)]
    Id_E_RABFailedToResumeItemResumeRes(E_RABFailedToResumeItemResumeRes),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABFailedToResumeListResumeRes_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABFailedToResumeListResumeRes_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABFailedToResumeListResumeRes_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABFailedToResumeListResumeRes_EntryValue = u.arbitrary()?;
        Ok(E_RABFailedToResumeListResumeRes_Entry {
            id: ProtocolIE_ID(match value {
                E_RABFailedToResumeListResumeRes_EntryValue::Id_E_RABFailedToResumeItemResumeRes(_) => 238,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABFailedToSetupItemHOReqAckIE_Extensions_Entry {}



#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABFailedToSetupItemHOReqAckIE_Extensions(
    pub Vec<E_RABFailedToSetupItemHOReqAckIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABFailedToSetupItemHOReqAckIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABFailedToSetupItemHOReqAckIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABFailedtoSetupListHOReqAck_EntryValue {
    #[asn(key = 21)]
    Id_E_RABFailedtoSetupItemHOReqAck(E_RABFailedToSetupItemHOReqAck),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABFailedtoSetupListHOReqAck_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABFailedtoSetupListHOReqAck_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABFailedtoSetupListHOReqAck_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABFailedtoSetupListHOReqAck_EntryValue = u.arbitrary()?;
        Ok(E_RABFailedtoSetupListHOReqAck_Entry {
            id: ProtocolIE_ID(match value {
                    E_RABFailedtoSetupListHOReqAck_EntryValue::Id_E_RABFailedtoSetupItemHOReqAck(_) => 21,
                }),
                criticality: Criticality(Criticality::IGNORE),
                value,
            })
        }
    }

    #[derive(
        asn1_codecs_derive :: AperCodec,
        arbitrary :: Arbitrary,
        serde :: Serialize,
        serde :: Deserialize,
        Eq,
        PartialEq,
        Debug,
        Clone,
    )]
    #[asn(type = "OPEN")]
    pub enum E_RABInformationList_EntryValue {
        #[asn(key = 78)]
        Id_E_RABInformationListItem(E_RABInformationListItem),
    }

    #[derive(
        asn1_codecs_derive :: AperCodec,
        serde :: Serialize,
        serde :: Deserialize,
        Eq,
        PartialEq,
        Debug,
        Clone,
    )]
    #[asn(type = "SEQUENCE", extensible = false)]
    pub struct E_RABInformationList_Entry {
        #[asn(key_field = true)]
        pub id: ProtocolIE_ID,
        pub criticality: Criticality,
        pub value: E_RABInformationList_EntryValue,
    }

    impl<'a> arbitrary::Arbitrary<'a> for E_RABInformationList_Entry {
        fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
            let value: E_RABInformationList_EntryValue = u.arbitrary()?;
            Ok(E_RABInformationList_Entry {
                id: ProtocolIE_ID(match value {
                    E_RABInformationList_EntryValue::Id_E_RABInformationListItem(_) => 78,
                }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABInformationListItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 317)]
    Id_DAPSRequestInfo(DAPSRequestInfo),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABInformationListItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: E_RABInformationListItemIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABInformationListItemIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: E_RABInformationListItemIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(E_RABInformationListItemIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                E_RABInformationListItemIE_Extensions_EntryExtensionValue::Id_DAPSRequestInfo(_) => 317,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABInformationListItemIE_Extensions(
    pub Vec<E_RABInformationListItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABInformationListItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABInformationListItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABItemIE_Extensions(pub Vec<E_RABItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABLevelQoSParametersIE_Extensions_EntryExtensionValue {
    #[asn(key = 273)]
    Id_DownlinkPacketLossRate(Packet_LossRate),
    #[asn(key = 274)]
    Id_UplinkPacketLossRate(Packet_LossRate),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABLevelQoSParametersIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: E_RABLevelQoSParametersIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABLevelQoSParametersIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: E_RABLevelQoSParametersIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(E_RABLevelQoSParametersIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                E_RABLevelQoSParametersIE_Extensions_EntryExtensionValue::Id_DownlinkPacketLossRate(_) => 273,
                E_RABLevelQoSParametersIE_Extensions_EntryExtensionValue::Id_UplinkPacketLossRate(_) => 274,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABLevelQoSParametersIE_Extensions(
    pub Vec<E_RABLevelQoSParametersIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABLevelQoSParametersIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABLevelQoSParametersIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABList_EntryValue {
    #[asn(key = 35)]
    Id_E_RABItem(E_RABItem),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABList_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABList_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABList_EntryValue = u.arbitrary()?;
        Ok(E_RABList_Entry {
            id: ProtocolIE_ID(match value {
                E_RABList_EntryValue::Id_E_RABItem(_) => 35,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABModificationConfirmProtocolIEs_EntryValue {
    #[asn(key = 146)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 205)]
    Id_E_RABFailedToModifyListBearerModConf(E_RABList),
    #[asn(key = 203)]
    Id_E_RABModifyListBearerModConf(E_RABModifyListBearerModConf),
    #[asn(key = 210)]
    Id_E_RABToBeReleasedListBearerModConf(E_RABList),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModificationConfirmProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABModificationConfirmProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABModificationConfirmProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABModificationConfirmProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(E_RABModificationConfirmProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                E_RABModificationConfirmProtocolIEs_EntryValue::Id_CSGMembershipStatus(_) => 146,
                E_RABModificationConfirmProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                E_RABModificationConfirmProtocolIEs_EntryValue::Id_E_RABFailedToModifyListBearerModConf(_) => 205,
                E_RABModificationConfirmProtocolIEs_EntryValue::Id_E_RABModifyListBearerModConf(_) => 203,
                E_RABModificationConfirmProtocolIEs_EntryValue::Id_E_RABToBeReleasedListBearerModConf(_) => 210,
                E_RABModificationConfirmProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                E_RABModificationConfirmProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABModificationConfirmProtocolIEs(pub Vec<E_RABModificationConfirmProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABModificationConfirmProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABModificationConfirmProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary::Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABModificationIndicationProtocolIEs_EntryValue {
    #[asn(key = 226)]
    Id_CSGMembershipInfo(CSGMembershipInfo),
    #[asn(key = 201)]
    Id_E_RABNotToBeModifiedListBearerModInd(E_RABNotToBeModifiedListBearerModInd),
    //#[asn(key = 199)]
    //Id_E_RABToBeModifiedListBearerModInd(E_RABToBeModifiedListBearerModInd),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 176)]
    Id_Tunnel_Information_for_BBF(TunnelInformation),
    #[asn(key = 189)]
    Id_UserLocationInformation(UserLocationInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModificationIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABModificationIndicationProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABModificationIndicationProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABModificationIndicationProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(E_RABModificationIndicationProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                E_RABModificationIndicationProtocolIEs_EntryValue::Id_CSGMembershipInfo(_) => 226,
                E_RABModificationIndicationProtocolIEs_EntryValue::Id_E_RABNotToBeModifiedListBearerModInd(_) => 201,
                // E_RABModificationIndicationProtocolIEs_EntryValue::Id_E_RABToBeModifiedListBearerModInd(_) => 200,
                E_RABModificationIndicationProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                E_RABModificationIndicationProtocolIEs_EntryValue::Id_SecondaryRATDataUsageReportList(_) => 264,
                E_RABModificationIndicationProtocolIEs_EntryValue::Id_Tunnel_Information_for_BBF(_) => 176,
                E_RABModificationIndicationProtocolIEs_EntryValue::Id_UserLocationInformation(_) => 189,
                E_RABModificationIndicationProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABModificationIndicationProtocolIEs(
    pub Vec<E_RABModificationIndicationProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABModificationIndicationProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABModificationIndicationProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModifyItemBearerModConfIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABModifyItemBearerModConfIE_Extensions(
    pub Vec<E_RABModifyItemBearerModConfIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABModifyItemBearerModConfIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABModifyItemBearerModConfIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModifyItemBearerModResIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABModifyItemBearerModResIE_Extensions(
    pub Vec<E_RABModifyItemBearerModResIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABModifyItemBearerModResIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABModifyItemBearerModResIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABModifyListBearerModConf_EntryValue {
    #[asn(key = 204)]
    Id_E_RABModifyItemBearerModConf(E_RABModifyItemBearerModConf),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModifyListBearerModConf_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABModifyListBearerModConf_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABModifyListBearerModConf_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABModifyListBearerModConf_EntryValue = u.arbitrary()?;
        Ok(E_RABModifyListBearerModConf_Entry {
            id: ProtocolIE_ID(match value {
                E_RABModifyListBearerModConf_EntryValue::Id_E_RABModifyItemBearerModConf(_) => 204,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABModifyListBearerModRes_EntryValue {
    #[asn(key = 37)]
    Id_E_RABModifyItemBearerModRes(E_RABModifyItemBearerModRes),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModifyListBearerModRes_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABModifyListBearerModRes_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABModifyListBearerModRes_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABModifyListBearerModRes_EntryValue = u.arbitrary()?;
        Ok(E_RABModifyListBearerModRes_Entry {
            id: ProtocolIE_ID(match value {
                E_RABModifyListBearerModRes_EntryValue::Id_E_RABModifyItemBearerModRes(_) => 37,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABModifyRequestProtocolIEs_EntryValue {
    #[asn(key = 30)]
    Id_E_RABToBeModifiedListBearerModReq(E_RABToBeModifiedListBearerModReq),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 268)]
    Id_SecondaryRATDataUsageRequest(SecondaryRATDataUsageRequest),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
    #[asn(key = 66)]
    Id_uEaggregateMaximumBitrate(UEAggregateMaximumBitrate),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModifyRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABModifyRequestProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABModifyRequestProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABModifyRequestProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(E_RABModifyRequestProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                E_RABModifyRequestProtocolIEs_EntryValue::Id_E_RABToBeModifiedListBearerModReq(_) => 30,
                E_RABModifyRequestProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                E_RABModifyRequestProtocolIEs_EntryValue::Id_SecondaryRATDataUsageRequest(_) => 268,
                E_RABModifyRequestProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
                E_RABModifyRequestProtocolIEs_EntryValue::Id_uEaggregateMaximumBitrate(_) => 66,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABModifyRequestProtocolIEs(pub Vec<E_RABModifyRequestProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABModifyRequestProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABModifyRequestProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABModifyResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 32)]
    Id_E_RABFailedToModifyList(E_RABList),
    #[asn(key = 31)]
    Id_E_RABModifyListBearerModRes(E_RABModifyListBearerModRes),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABModifyResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABModifyResponseProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABModifyResponseProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABModifyResponseProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(E_RABModifyResponseProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                E_RABModifyResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                E_RABModifyResponseProtocolIEs_EntryValue::Id_E_RABFailedToModifyList(_) => 32,
                E_RABModifyResponseProtocolIEs_EntryValue::Id_E_RABModifyListBearerModRes(_) => 31,
                E_RABModifyResponseProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                E_RABModifyResponseProtocolIEs_EntryValue::Id_SecondaryRATDataUsageReportList(_) => 264,
                E_RABModifyResponseProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABModifyResponseProtocolIEs(pub Vec<E_RABModifyResponseProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABModifyResponseProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABModifyResponseProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABNotToBeModifiedItemBearerModIndIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABNotToBeModifiedItemBearerModIndIE_Extensions(
    pub Vec<E_RABNotToBeModifiedItemBearerModIndIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABNotToBeModifiedItemBearerModIndIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABNotToBeModifiedItemBearerModIndIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABNotToBeModifiedListBearerModInd_EntryValue {
    #[asn(key = 202)]
    Id_E_RABNotToBeModifiedItemBearerModInd(E_RABNotToBeModifiedItemBearerModInd),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABNotToBeModifiedListBearerModInd_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABNotToBeModifiedListBearerModInd_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABNotToBeModifiedListBearerModInd_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABNotToBeModifiedListBearerModInd_EntryValue = u.arbitrary()?;
        Ok(E_RABNotToBeModifiedListBearerModInd_Entry {
            id: ProtocolIE_ID(match value {
                E_RABNotToBeModifiedListBearerModInd_EntryValue::Id_E_RABNotToBeModifiedItemBearerModInd(_) => 202,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABReleaseCommandProtocolIEs_EntryValue {
    #[asn(key = 33)]
    Id_E_RABToBeReleasedList(E_RABList),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 26)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
    #[asn(key = 66)]
    Id_uEaggregateMaximumBitrate(UEAggregateMaximumBitrate),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABReleaseCommandProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABReleaseCommandProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABReleaseCommandProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABReleaseCommandProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(E_RABReleaseCommandProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                E_RABReleaseCommandProtocolIEs_EntryValue::Id_E_RABToBeReleasedList(_) => 33,
                E_RABReleaseCommandProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                E_RABReleaseCommandProtocolIEs_EntryValue::Id_NAS_PDU(_) => 26,
                E_RABReleaseCommandProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
                E_RABReleaseCommandProtocolIEs_EntryValue::Id_uEaggregateMaximumBitrate(_) => 66,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABReleaseCommandProtocolIEs(pub Vec<E_RABReleaseCommandProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABReleaseCommandProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABReleaseCommandProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABReleaseIndicationProtocolIEs_EntryValue {
    #[asn(key = 110)]
    Id_E_RABReleasedList(E_RABList),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 189)]
    Id_UserLocationInformation(UserLocationInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABReleaseIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABReleaseIndicationProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABReleaseIndicationProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABReleaseIndicationProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(E_RABReleaseIndicationProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                E_RABReleaseIndicationProtocolIEs_EntryValue::Id_E_RABReleasedList(_) => 110,
                E_RABReleaseIndicationProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                E_RABReleaseIndicationProtocolIEs_EntryValue::Id_SecondaryRATDataUsageReportList(_) => 264,
                E_RABReleaseIndicationProtocolIEs_EntryValue::Id_UserLocationInformation(_) => 189,
                E_RABReleaseIndicationProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABReleaseIndicationProtocolIEs(pub Vec<E_RABReleaseIndicationProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABReleaseIndicationProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABReleaseIndicationProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABReleaseItemBearerRelCompIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABReleaseItemBearerRelCompIE_Extensions(
    pub Vec<E_RABReleaseItemBearerRelCompIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABReleaseItemBearerRelCompIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABReleaseItemBearerRelCompIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABReleaseListBearerRelComp_EntryValue {
    #[asn(key = 15)]
    Id_E_RABReleaseItemBearerRelComp(E_RABReleaseItemBearerRelComp),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABReleaseListBearerRelComp_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABReleaseListBearerRelComp_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABReleaseListBearerRelComp_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABReleaseListBearerRelComp_EntryValue = u.arbitrary()?;
        Ok(E_RABReleaseListBearerRelComp_Entry {
            id: ProtocolIE_ID(match value {
                E_RABReleaseListBearerRelComp_EntryValue::Id_E_RABReleaseItemBearerRelComp(_) => 15,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABReleaseResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 34)]
    Id_E_RABFailedToReleaseList(E_RABList),
    #[asn(key = 69)]
    Id_E_RABReleaseListBearerRelComp(E_RABReleaseListBearerRelComp),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 189)]
    Id_UserLocationInformation(UserLocationInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABReleaseResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABReleaseResponseProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABReleaseResponseProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABReleaseResponseProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(E_RABReleaseResponseProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                E_RABReleaseResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                E_RABReleaseResponseProtocolIEs_EntryValue::Id_E_RABFailedToReleaseList(_) => 34,
                E_RABReleaseResponseProtocolIEs_EntryValue::Id_E_RABReleaseListBearerRelComp(_) => 69,
                E_RABReleaseResponseProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                E_RABReleaseResponseProtocolIEs_EntryValue::Id_SecondaryRATDataUsageReportList(_) => 264,
                E_RABReleaseResponseProtocolIEs_EntryValue::Id_UserLocationInformation(_) => 189,
                E_RABReleaseResponseProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABReleaseResponseProtocolIEs(pub Vec<E_RABReleaseResponseProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABReleaseResponseProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABReleaseResponseProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABSetupItemBearerSUResIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABSetupItemBearerSUResIE_Extensions(
    pub Vec<E_RABSetupItemBearerSUResIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABSetupItemBearerSUResIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABSetupItemBearerSUResIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    arbitrary::Arbitrary,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABSetupItemCtxtSUResIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABSetupItemCtxtSUResIE_Extensions(
    pub Vec<E_RABSetupItemCtxtSUResIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABSetupItemCtxtSUResIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABSetupItemCtxtSUResIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABSetupListBearerSURes_EntryValue {
    #[asn(key = 39)]
    Id_E_RABSetupItemBearerSURes(E_RABSetupItemBearerSURes),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABSetupListBearerSURes_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABSetupListBearerSURes_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABSetupListBearerSURes_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABSetupListBearerSURes_EntryValue = u.arbitrary()?;
        Ok(E_RABSetupListBearerSURes_Entry {
            id: ProtocolIE_ID(match value {
                E_RABSetupListBearerSURes_EntryValue::Id_E_RABSetupItemBearerSURes(_) => 39,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABSetupListCtxtSURes_EntryValue {
    #[asn(key = 50)]
    Id_E_RABSetupItemCtxtSURes(E_RABSetupItemCtxtSURes),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABSetupListCtxtSURes_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABSetupListCtxtSURes_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABSetupListCtxtSURes_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABSetupListCtxtSURes_EntryValue = u.arbitrary()?;
        Ok(E_RABSetupListCtxtSURes_Entry {
            id: ProtocolIE_ID(match value {
                E_RABSetupListCtxtSURes_EntryValue::Id_E_RABSetupItemCtxtSURes(_) => 50,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABSetupRequestProtocolIEs_EntryValue {
    #[asn(key = 16)]
    Id_E_RABToBeSetupListBearerSUReq(E_RABToBeSetupListBearerSUReq),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
    #[asn(key = 66)]
    Id_uEaggregateMaximumBitrate(UEAggregateMaximumBitrate),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABSetupRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABSetupRequestProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABSetupRequestProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABSetupRequestProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(E_RABSetupRequestProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                E_RABSetupRequestProtocolIEs_EntryValue::Id_E_RABToBeSetupListBearerSUReq(_) => 16,
                E_RABSetupRequestProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                E_RABSetupRequestProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
                E_RABSetupRequestProtocolIEs_EntryValue::Id_uEaggregateMaximumBitrate(_) => 66,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABSetupRequestProtocolIEs(pub Vec<E_RABSetupRequestProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABSetupRequestProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABSetupRequestProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABSetupResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 29)]
    Id_E_RABFailedToSetupListBearerSURes(E_RABList),
    #[asn(key = 28)]
    Id_E_RABSetupListBearerSURes(E_RABSetupListBearerSURes),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABSetupResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABSetupResponseProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABSetupResponseProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABSetupResponseProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(E_RABSetupResponseProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                E_RABSetupResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                E_RABSetupResponseProtocolIEs_EntryValue::Id_E_RABFailedToSetupListBearerSURes(_) => 29,
                E_RABSetupResponseProtocolIEs_EntryValue::Id_E_RABSetupListBearerSURes(_) => 28,
                E_RABSetupResponseProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                E_RABSetupResponseProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct E_RABSetupResponseProtocolIEs(pub Vec<E_RABSetupResponseProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABSetupResponseProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABSetupResponseProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABSubjecttoDataForwardingList_EntryValue {
    #[asn(key = 14)]
    Id_E_RABDataForwardingItem(E_RABDataForwardingItem),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABSubjecttoDataForwardingList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABSubjecttoDataForwardingList_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABSubjecttoDataForwardingList_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABSubjecttoDataForwardingList_EntryValue = u.arbitrary()?;
        Ok(E_RABSubjecttoDataForwardingList_Entry {
            id: ProtocolIE_ID(match value {
                E_RABSubjecttoDataForwardingList_EntryValue::Id_E_RABDataForwardingItem(_) => 14,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeModifiedItemBearerModIndIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABToBeModifiedItemBearerModIndIE_Extensions(
    pub Vec<E_RABToBeModifiedItemBearerModIndIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeModifiedItemBearerModIndIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABToBeModifiedItemBearerModIndIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABToBeModifiedItemBearerModReqIE_Extensions_EntryExtensionValue {
    #[asn(key = 185)]
    Id_TransportInformation(TransportInformation),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeModifiedItemBearerModReqIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: E_RABToBeModifiedItemBearerModReqIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeModifiedItemBearerModReqIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: E_RABToBeModifiedItemBearerModReqIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(E_RABToBeModifiedItemBearerModReqIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                E_RABToBeModifiedItemBearerModReqIE_Extensions_EntryExtensionValue::Id_TransportInformation(_) => 185,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABToBeModifiedItemBearerModReqIE_Extensions(
    pub Vec<E_RABToBeModifiedItemBearerModReqIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeModifiedItemBearerModReqIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABToBeModifiedItemBearerModReqIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABToBeModifiedListBearerModInd_EntryValue {
    #[asn(key = 200)]
    Id_E_RABToBeModifiedItemBearerModInd(E_RABToBeModifiedItemBearerModInd),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeModifiedListBearerModInd_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABToBeModifiedListBearerModInd_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeModifiedListBearerModInd_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABToBeModifiedListBearerModInd_EntryValue = u.arbitrary()?;
        Ok(E_RABToBeModifiedListBearerModInd_Entry {
            id: ProtocolIE_ID(match value {
                E_RABToBeModifiedListBearerModInd_EntryValue::Id_E_RABToBeModifiedItemBearerModInd(_) => 200,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABToBeModifiedListBearerModReq_EntryValue {
    #[asn(key = 36)]
    Id_E_RABToBeModifiedItemBearerModReq(E_RABToBeModifiedItemBearerModReq),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeModifiedListBearerModReq_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABToBeModifiedListBearerModReq_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeModifiedListBearerModReq_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABToBeModifiedListBearerModReq_EntryValue = u.arbitrary()?;
        Ok(E_RABToBeModifiedListBearerModReq_Entry {
            id: ProtocolIE_ID(match value {
                E_RABToBeModifiedListBearerModReq_EntryValue::Id_E_RABToBeModifiedItemBearerModReq(_) => 36,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSetupItemBearerSUReqIE_Extensions_EntryExtensionValue {
    #[asn(key = 233)]
    Id_BearerType(BearerType),
    #[asn(key = 156)]
    Id_Correlation_ID(Correlation_ID),
    #[asn(key = 305)]
    Id_Ethernet_Type(Ethernet_Type),
    #[asn(key = 183)]
    Id_SIPTO_Correlation_ID(Correlation_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSetupItemBearerSUReqIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: E_RABToBeSetupItemBearerSUReqIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSetupItemBearerSUReqIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: E_RABToBeSetupItemBearerSUReqIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(E_RABToBeSetupItemBearerSUReqIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                E_RABToBeSetupItemBearerSUReqIE_Extensions_EntryExtensionValue::Id_BearerType(_) => 233,
                E_RABToBeSetupItemBearerSUReqIE_Extensions_EntryExtensionValue::Id_Correlation_ID(_) => 156,
                E_RABToBeSetupItemBearerSUReqIE_Extensions_EntryExtensionValue::Id_Ethernet_Type(_) => 305,
                E_RABToBeSetupItemBearerSUReqIE_Extensions_EntryExtensionValue::Id_SIPTO_Correlation_ID(_) => 183,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABToBeSetupItemBearerSUReqIE_Extensions(
    pub Vec<E_RABToBeSetupItemBearerSUReqIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSetupItemBearerSUReqIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABToBeSetupItemBearerSUReqIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSetupItemCtxtSUReqIE_Extensions_EntryExtensionValue {
    #[asn(key = 233)]
    Id_BearerType(BearerType),
    #[asn(key = 156)]
    Id_Correlation_ID(Correlation_ID),
    #[asn(key = 305)]
    Id_Ethernet_Type(Ethernet_Type),
    #[asn(key = 183)]
    Id_SIPTO_Correlation_ID(Correlation_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSetupItemCtxtSUReqIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: E_RABToBeSetupItemCtxtSUReqIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSetupItemCtxtSUReqIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: E_RABToBeSetupItemCtxtSUReqIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(E_RABToBeSetupItemCtxtSUReqIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                E_RABToBeSetupItemCtxtSUReqIE_Extensions_EntryExtensionValue::Id_BearerType(_) => 233,
                E_RABToBeSetupItemCtxtSUReqIE_Extensions_EntryExtensionValue::Id_Correlation_ID(_) => 156,
                E_RABToBeSetupItemCtxtSUReqIE_Extensions_EntryExtensionValue::Id_Ethernet_Type(_) => 305,
                E_RABToBeSetupItemCtxtSUReqIE_Extensions_EntryExtensionValue::Id_SIPTO_Correlation_ID(_) => 183,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABToBeSetupItemCtxtSUReqIE_Extensions(
    pub Vec<E_RABToBeSetupItemCtxtSUReqIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSetupItemCtxtSUReqIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABToBeSetupItemCtxtSUReqIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSetupItemHOReqIE_Extensions_EntryExtensionValue {
    #[asn(key = 233)]
    Id_BearerType(BearerType),
    #[asn(key = 143)]
    Id_Data_Forwarding_Not_Possible(Data_Forwarding_Not_Possible),
    #[asn(key = 305)]
    Id_Ethernet_Type(Ethernet_Type),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSetupItemHOReqIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: E_RABToBeSetupItemHOReqIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSetupItemHOReqIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: E_RABToBeSetupItemHOReqIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(E_RABToBeSetupItemHOReqIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                E_RABToBeSetupItemHOReqIE_Extensions_EntryExtensionValue::Id_BearerType(_) => 233,
                E_RABToBeSetupItemHOReqIE_Extensions_EntryExtensionValue::Id_Data_Forwarding_Not_Possible(_) => 143,
                E_RABToBeSetupItemHOReqIE_Extensions_EntryExtensionValue::Id_Ethernet_Type(_) => 305,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABToBeSetupItemHOReqIE_Extensions(
    pub Vec<E_RABToBeSetupItemHOReqIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSetupItemHOReqIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABToBeSetupItemHOReqIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSetupListBearerSUReq_EntryValue {
    #[asn(key = 17)]
    Id_E_RABToBeSetupItemBearerSUReq(E_RABToBeSetupItemBearerSUReq),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSetupListBearerSUReq_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABToBeSetupListBearerSUReq_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSetupListBearerSUReq_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABToBeSetupListBearerSUReq_EntryValue = u.arbitrary()?;
        Ok(E_RABToBeSetupListBearerSUReq_Entry {
            id: ProtocolIE_ID(match value {
                E_RABToBeSetupListBearerSUReq_EntryValue::Id_E_RABToBeSetupItemBearerSUReq(_) => 17,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSetupListCtxtSUReq_EntryValue {
    #[asn(key = 52)]
    Id_E_RABToBeSetupItemCtxtSUReq(E_RABToBeSetupItemCtxtSUReq),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSetupListCtxtSUReq_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABToBeSetupListCtxtSUReq_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSetupListCtxtSUReq_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABToBeSetupListCtxtSUReq_EntryValue = u.arbitrary()?;
        Ok(E_RABToBeSetupListCtxtSUReq_Entry {
            id: ProtocolIE_ID(match value {
                E_RABToBeSetupListCtxtSUReq_EntryValue::Id_E_RABToBeSetupItemCtxtSUReq(_) => 52,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSetupListHOReq_EntryValue {
    #[asn(key = 27)]
    Id_E_RABToBeSetupItemHOReq(E_RABToBeSetupItemHOReq),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSetupListHOReq_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABToBeSetupListHOReq_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSetupListHOReq_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABToBeSetupListHOReq_EntryValue = u.arbitrary()?;
        Ok(E_RABToBeSetupListHOReq_Entry {
            id: ProtocolIE_ID(match value {
                E_RABToBeSetupListHOReq_EntryValue::Id_E_RABToBeSetupItemHOReq(_) => 27,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSwitchedDLItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABToBeSwitchedDLItemIE_Extensions(
    pub Vec<E_RABToBeSwitchedDLItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSwitchedDLItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABToBeSwitchedDLItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSwitchedDLList_EntryValue {
    #[asn(key = 23)]
    Id_E_RABToBeSwitchedDLItem(E_RABToBeSwitchedDLItem),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSwitchedDLList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABToBeSwitchedDLList_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSwitchedDLList_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABToBeSwitchedDLList_EntryValue = u.arbitrary()?;
        Ok(E_RABToBeSwitchedDLList_Entry {
            id: ProtocolIE_ID(match value {
                E_RABToBeSwitchedDLList_EntryValue::Id_E_RABToBeSwitchedDLItem(_) => 23,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSwitchedULItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABToBeSwitchedULItemIE_Extensions(
    pub Vec<E_RABToBeSwitchedULItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSwitchedULItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABToBeSwitchedULItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABToBeSwitchedULList_EntryValue {
    #[asn(key = 94)]
    Id_E_RABToBeSwitchedULItem(E_RABToBeSwitchedULItem),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABToBeSwitchedULList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABToBeSwitchedULList_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABToBeSwitchedULList_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABToBeSwitchedULList_EntryValue = u.arbitrary()?;
        Ok(E_RABToBeSwitchedULList_Entry {
            id: ProtocolIE_ID(match value {
                E_RABToBeSwitchedULList_EntryValue::Id_E_RABToBeSwitchedULItem(_) => 94,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct E_RABUsageReportItemStartTimestamp(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABUsageReportItemStartTimestamp {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(4, std::cmp::min(10, u.int_in_range(4..=4)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(E_RABUsageReportItemStartTimestamp(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING", sz_extensible = false, sz_lb = "4", sz_ub = "4")]
pub struct E_RABUsageReportItemEndTimestamp(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABUsageReportItemEndTimestamp {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(4, std::cmp::min(10, u.int_in_range(4..=4)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(E_RABUsageReportItemEndTimestamp(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "18446744073709551615")]
pub struct E_RABUsageReportItemUsageCountUL(pub u64);
impl<'a> arbitrary::Arbitrary<'a> for E_RABUsageReportItemUsageCountUL {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABUsageReportItemUsageCountUL(
            u.int_in_range(0..=18446744073709551615)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "18446744073709551615")]
pub struct E_RABUsageReportItemUsageCountDL(pub u64);
impl<'a> arbitrary::Arbitrary<'a> for E_RABUsageReportItemUsageCountDL {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(E_RABUsageReportItemUsageCountDL(
            u.int_in_range(0..=18446744073709551615)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABUsageReportItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct E_RABUsageReportItemIE_Extensions(pub Vec<E_RABUsageReportItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for E_RABUsageReportItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(E_RABUsageReportItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum E_RABUsageReportList_EntryValue {
    #[asn(key = 267)]
    Id_E_RABUsageReportItem(E_RABUsageReportItem),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct E_RABUsageReportList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: E_RABUsageReportList_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for E_RABUsageReportList_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: E_RABUsageReportList_EntryValue = u.arbitrary()?;
        Ok(E_RABUsageReportList_Entry {
            id: ProtocolIE_ID(match value {
                E_RABUsageReportList_EntryValue::Id_E_RABUsageReportItem(_) => 267,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EN_DCSONConfigurationTransferIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EN_DCSONConfigurationTransferIE_Extensions(
    pub Vec<EN_DCSONConfigurationTransferIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for EN_DCSONConfigurationTransferIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(EN_DCSONConfigurationTransferIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EN_DCSONeNBIdentificationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EN_DCSONeNBIdentificationIE_Extensions(
    pub Vec<EN_DCSONeNBIdentificationIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for EN_DCSONeNBIdentificationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(EN_DCSONeNBIdentificationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EN_DCSONengNBIdentificationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EN_DCSONengNBIdentificationIE_Extensions(
    pub Vec<EN_DCSONengNBIdentificationIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for EN_DCSONengNBIdentificationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(EN_DCSONengNBIdentificationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EN_DCTransferTypeReplyIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EN_DCTransferTypeReplyIE_Extensions(pub Vec<EN_DCTransferTypeReplyIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for EN_DCTransferTypeReplyIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(EN_DCTransferTypeReplyIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EN_DCTransferTypeRequestIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EN_DCTransferTypeRequestIE_Extensions(
    pub Vec<EN_DCTransferTypeRequestIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for EN_DCTransferTypeRequestIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(EN_DCTransferTypeRequestIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENB_EarlyStatusTransfer_TransparentContainerIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ENB_EarlyStatusTransfer_TransparentContainerIE_Extensions(
    pub Vec<ENB_EarlyStatusTransfer_TransparentContainerIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for ENB_EarlyStatusTransfer_TransparentContainerIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ENB_EarlyStatusTransfer_TransparentContainerIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "20", sz_ub = "20")]
pub struct ENB_ID_macroENB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for ENB_ID_macroENB_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..20 {
            bv.push(u.arbitrary()?);
        }
        if 20 > 20 {
            for _ in 0..u.int_in_range(0..=20 - 20 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(ENB_ID_macroENB_ID(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "28", sz_ub = "28")]
pub struct ENB_ID_homeENB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for ENB_ID_homeENB_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..28 {
            bv.push(u.arbitrary()?);
        }
        if 28 > 28 {
            for _ in 0..u.int_in_range(0..=28 - 28 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(ENB_ID_homeENB_ID(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "18", sz_ub = "18")]
pub struct ENB_ID_short_macroENB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for ENB_ID_short_macroENB_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..18 {
            bv.push(u.arbitrary()?);
        }
        if 18 > 18 {
            for _ in 0..u.int_in_range(0..=18 - 18 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(ENB_ID_short_macroENB_ID(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "21", sz_ub = "21")]
pub struct ENB_ID_long_macroENB_ID(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for ENB_ID_long_macroENB_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..21 {
            bv.push(u.arbitrary()?);
        }
        if 21 > 21 {
            for _ in 0..u.int_in_range(0..=21 - 21 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(ENB_ID_long_macroENB_ID(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENB_StatusTransfer_TransparentContainerIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ENB_StatusTransfer_TransparentContainerIE_Extensions(
    pub Vec<ENB_StatusTransfer_TransparentContainerIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for ENB_StatusTransfer_TransparentContainerIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ENB_StatusTransfer_TransparentContainerIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum ENBCPRelocationIndicationProtocolIEs_EntryValue {
    #[asn(key = 100)]
    Id_EUTRAN_CGI(EUTRAN_CGI),
    #[asn(key = 96)]
    Id_S_TMSI(S_TMSI),
    #[asn(key = 67)]
    Id_TAI(TAI),
    #[asn(key = 254)]
    Id_UL_CP_SecurityInformation(UL_CP_SecurityInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBCPRelocationIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBCPRelocationIndicationProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for ENBCPRelocationIndicationProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: ENBCPRelocationIndicationProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(ENBCPRelocationIndicationProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                ENBCPRelocationIndicationProtocolIEs_EntryValue::Id_EUTRAN_CGI(_) => 100,
                ENBCPRelocationIndicationProtocolIEs_EntryValue::Id_S_TMSI(_) => 96,
                ENBCPRelocationIndicationProtocolIEs_EntryValue::Id_TAI(_) => 67,
                ENBCPRelocationIndicationProtocolIEs_EntryValue::Id_UL_CP_SecurityInformation(_) => 254,
                ENBCPRelocationIndicationProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBCPRelocationIndicationProtocolIEs(
    pub Vec<ENBCPRelocationIndicationProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for ENBCPRelocationIndicationProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ENBCPRelocationIndicationProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum ENBConfigurationTransferProtocolIEs_EntryValue {
    #[asn(key = 294)]
    Id_EN_DCSONConfigurationTransfer_ECT(EN_DCSONConfigurationTransfer),
    #[asn(key = 310)]
    Id_IntersystemSONConfigurationTransferECT(IntersystemSONConfigurationTransfer),
    #[asn(key = 129)]
    Id_SONConfigurationTransferECT(SONConfigurationTransfer),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBConfigurationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBConfigurationTransferProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for ENBConfigurationTransferProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: ENBConfigurationTransferProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(ENBConfigurationTransferProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                ENBConfigurationTransferProtocolIEs_EntryValue::Id_EN_DCSONConfigurationTransfer_ECT(_) => 294,
                ENBConfigurationTransferProtocolIEs_EntryValue::Id_IntersystemSONConfigurationTransferECT(_) => 310,
                ENBConfigurationTransferProtocolIEs_EntryValue::Id_SONConfigurationTransferECT(_) => 129,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBConfigurationTransferProtocolIEs(pub Vec<ENBConfigurationTransferProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ENBConfigurationTransferProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ENBConfigurationTransferProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum ENBConfigurationUpdateProtocolIEs_EntryValue {
    #[asn(key = 128)]
    Id_CSG_IdList(CSG_IdList),
    #[asn(key = 292)]
    Id_ConnectedengNBToAddList(ConnectedengNBList),
    #[asn(key = 293)]
    Id_ConnectedengNBToRemoveList(ConnectedengNBList),
    #[asn(key = 137)]
    Id_DefaultPagingDRX(PagingDRX),
    #[asn(key = 234)]
    Id_NB_IoT_DefaultPagingDRX(NB_IoT_DefaultPagingDRX),
    #[asn(key = 64)]
    Id_SupportedTAs(SupportedTAs),
    #[asn(key = 60)]
    Id_eNBname(ENBname),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBConfigurationUpdateProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBConfigurationUpdateProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for ENBConfigurationUpdateProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: ENBConfigurationUpdateProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(ENBConfigurationUpdateProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                ENBConfigurationUpdateProtocolIEs_EntryValue::Id_CSG_IdList(_) => 128,
                ENBConfigurationUpdateProtocolIEs_EntryValue::Id_ConnectedengNBToAddList(_) => 292,
                ENBConfigurationUpdateProtocolIEs_EntryValue::Id_ConnectedengNBToRemoveList(_) => 293,
                ENBConfigurationUpdateProtocolIEs_EntryValue::Id_DefaultPagingDRX(_) => 137,
                ENBConfigurationUpdateProtocolIEs_EntryValue::Id_NB_IoT_DefaultPagingDRX(_) => 234,
                ENBConfigurationUpdateProtocolIEs_EntryValue::Id_SupportedTAs(_) => 64,
                ENBConfigurationUpdateProtocolIEs_EntryValue::Id_eNBname(_) => 60,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBConfigurationUpdateProtocolIEs(pub Vec<ENBConfigurationUpdateProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ENBConfigurationUpdateProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ENBConfigurationUpdateProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum ENBConfigurationUpdateAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBConfigurationUpdateAcknowledgeProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for ENBConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: ENBConfigurationUpdateAcknowledgeProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(ENBConfigurationUpdateAcknowledgeProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                ENBConfigurationUpdateAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBConfigurationUpdateAcknowledgeProtocolIEs(
    pub Vec<ENBConfigurationUpdateAcknowledgeProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for ENBConfigurationUpdateAcknowledgeProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ENBConfigurationUpdateAcknowledgeProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum ENBConfigurationUpdateFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 65)]
    Id_TimeToWait(TimeToWait),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBConfigurationUpdateFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBConfigurationUpdateFailureProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for ENBConfigurationUpdateFailureProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: ENBConfigurationUpdateFailureProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(ENBConfigurationUpdateFailureProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                ENBConfigurationUpdateFailureProtocolIEs_EntryValue::Id_Cause(_) => 2,
                ENBConfigurationUpdateFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                ENBConfigurationUpdateFailureProtocolIEs_EntryValue::Id_TimeToWait(_) => 65,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBConfigurationUpdateFailureProtocolIEs(
    pub Vec<ENBConfigurationUpdateFailureProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for ENBConfigurationUpdateFailureProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ENBConfigurationUpdateFailureProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum ENBDirectInformationTransferProtocolIEs_EntryValue {
    #[asn(key = 121)]
    Id_Inter_SystemInformationTransferTypeEDT(Inter_SystemInformationTransferType),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBDirectInformationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBDirectInformationTransferProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for ENBDirectInformationTransferProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: ENBDirectInformationTransferProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(ENBDirectInformationTransferProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                ENBDirectInformationTransferProtocolIEs_EntryValue::Id_Inter_SystemInformationTransferTypeEDT(_) => 121,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBDirectInformationTransferProtocolIEs(
    pub Vec<ENBDirectInformationTransferProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for ENBDirectInformationTransferProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ENBDirectInformationTransferProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum ENBEarlyStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 321)]
    Id_eNB_EarlyStatusTransfer_TransparentContainer(ENB_EarlyStatusTransfer_TransparentContainer),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBEarlyStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBEarlyStatusTransferProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for ENBEarlyStatusTransferProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: ENBEarlyStatusTransferProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(ENBEarlyStatusTransferProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                ENBEarlyStatusTransferProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                ENBEarlyStatusTransferProtocolIEs_EntryValue::Id_eNB_EarlyStatusTransfer_TransparentContainer(_) => 321,
                ENBEarlyStatusTransferProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBEarlyStatusTransferProtocolIEs(pub Vec<ENBEarlyStatusTransferProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ENBEarlyStatusTransferProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ENBEarlyStatusTransferProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum ENBStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 90)]
    Id_eNB_StatusTransfer_TransparentContainer(ENB_StatusTransfer_TransparentContainer),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ENBStatusTransferProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for ENBStatusTransferProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: ENBStatusTransferProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(ENBStatusTransferProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                ENBStatusTransferProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                ENBStatusTransferProtocolIEs_EntryValue::Id_eNB_StatusTransfer_TransparentContainer(_) => 90,
                ENBStatusTransferProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ENBStatusTransferProtocolIEs(pub Vec<ENBStatusTransferProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ENBStatusTransferProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ENBStatusTransferProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ENBX2ExtTLAIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ENBX2ExtTLAIE_Extensions(pub Vec<ENBX2ExtTLAIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ENBX2ExtTLAIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ENBX2ExtTLAIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EUTRAN_CGIIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EUTRAN_CGIIE_Extensions(pub Vec<EUTRAN_CGIIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for EUTRAN_CGIIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(EUTRAN_CGIIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct EUTRANResponseCell_ID(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EmergencyAreaID_Broadcast_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaID_Broadcast_ItemIE_Extensions(
    pub Vec<EmergencyAreaID_Broadcast_ItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for EmergencyAreaID_Broadcast_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(EmergencyAreaID_Broadcast_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct EmergencyAreaID_Cancelled_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct EmergencyAreaID_Cancelled_ItemIE_Extensions(
    pub Vec<EmergencyAreaID_Cancelled_ItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for EmergencyAreaID_Cancelled_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(EmergencyAreaID_Cancelled_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum ErrorIndicationProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 96)]
    Id_S_TMSI(S_TMSI),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ErrorIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ErrorIndicationProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for ErrorIndicationProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: ErrorIndicationProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(ErrorIndicationProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                ErrorIndicationProtocolIEs_EntryValue::Id_Cause(_) => 2,
                ErrorIndicationProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                ErrorIndicationProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                ErrorIndicationProtocolIEs_EntryValue::Id_S_TMSI(_) => 96,
                ErrorIndicationProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ErrorIndicationProtocolIEs(pub Vec<ErrorIndicationProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ErrorIndicationProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ErrorIndicationProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExpectedUEActivityBehaviourIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExpectedUEActivityBehaviourIE_Extensions(
    pub Vec<ExpectedUEActivityBehaviourIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for ExpectedUEActivityBehaviourIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ExpectedUEActivityBehaviourIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ExpectedUEBehaviourIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ExpectedUEBehaviourIE_Extensions(pub Vec<ExpectedUEBehaviourIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ExpectedUEBehaviourIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ExpectedUEBehaviourIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct FiveGSTAIIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct FiveGSTAIIE_Extensions(pub Vec<FiveGSTAIIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for FiveGSTAIIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(FiveGSTAIIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ForbiddenLAs_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ForbiddenLAs_ItemIE_Extensions(pub Vec<ForbiddenLAs_ItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ForbiddenLAs_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ForbiddenLAs_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ForbiddenTAs_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ForbiddenTAs_ItemIE_Extensions(pub Vec<ForbiddenTAs_ItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ForbiddenTAs_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ForbiddenTAs_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum GBR_QosInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 257)]
    Id_extended_e_RAB_GuaranteedBitrateDL(ExtendedBitRate),
    #[asn(key = 258)]
    Id_extended_e_RAB_GuaranteedBitrateUL(ExtendedBitRate),
    #[asn(key = 255)]
    Id_extended_e_RAB_MaximumBitrateDL(ExtendedBitRate),
    #[asn(key = 256)]
    Id_extended_e_RAB_MaximumBitrateUL(ExtendedBitRate),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GBR_QosInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: GBR_QosInformationIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for GBR_QosInformationIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: GBR_QosInformationIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(GBR_QosInformationIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                GBR_QosInformationIE_Extensions_EntryExtensionValue::Id_extended_e_RAB_GuaranteedBitrateDL(_) => 257,
                GBR_QosInformationIE_Extensions_EntryExtensionValue::Id_extended_e_RAB_GuaranteedBitrateUL(_) => 258,
                GBR_QosInformationIE_Extensions_EntryExtensionValue::Id_extended_e_RAB_MaximumBitrateDL(_) => 255,
                GBR_QosInformationIE_Extensions_EntryExtensionValue::Id_extended_e_RAB_MaximumBitrateUL(_) => 256,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GBR_QosInformationIE_Extensions(pub Vec<GBR_QosInformationIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for GBR_QosInformationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(GBR_QosInformationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GERAN_Cell_IDIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GERAN_Cell_IDIE_Extensions(pub Vec<GERAN_Cell_IDIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for GERAN_Cell_IDIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(GERAN_Cell_IDIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GNBIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GNBIE_Extensions(pub Vec<GNBIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for GNBIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(GNBIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct GUMMEIIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct GUMMEIIE_Extensions(pub Vec<GUMMEIIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for GUMMEIIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(GUMMEIIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Global_ENB_IDIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Global_ENB_IDIE_Extensions(pub Vec<Global_ENB_IDIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for Global_ENB_IDIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(Global_ENB_IDIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Global_GNB_IDIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Global_GNB_IDIE_Extensions(pub Vec<Global_GNB_IDIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for Global_GNB_IDIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(Global_GNB_IDIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Global_en_gNB_IDIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Global_en_gNB_IDIE_Extensions(pub Vec<Global_en_gNB_IDIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for Global_en_gNB_IDIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(Global_en_gNB_IDIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum HandoverCancelProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCancelProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverCancelProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for HandoverCancelProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: HandoverCancelProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(HandoverCancelProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                HandoverCancelProtocolIEs_EntryValue::Id_Cause(_) => 2,
                HandoverCancelProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                HandoverCancelProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverCancelProtocolIEs(pub Vec<HandoverCancelProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for HandoverCancelProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(HandoverCancelProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum HandoverCancelAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCancelAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverCancelAcknowledgeProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for HandoverCancelAcknowledgeProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: HandoverCancelAcknowledgeProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(HandoverCancelAcknowledgeProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                HandoverCancelAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                HandoverCancelAcknowledgeProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                HandoverCancelAcknowledgeProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverCancelAcknowledgeProtocolIEs(
    pub Vec<HandoverCancelAcknowledgeProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for HandoverCancelAcknowledgeProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(HandoverCancelAcknowledgeProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum HandoverCommandProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 12)]
    Id_E_RABSubjecttoDataForwardingList(E_RABSubjecttoDataForwardingList),
    #[asn(key = 13)]
    Id_E_RABtoReleaseListHOCmd(E_RABList),
    #[asn(key = 1)]
    Id_HandoverType(HandoverType),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 135)]
    Id_NASSecurityParametersfromE_UTRAN(NASSecurityParametersfromE_UTRAN),
    #[asn(key = 123)]
    Id_Target_ToSource_TransparentContainer(Target_ToSource_TransparentContainer),
    #[asn(key = 139)]
    Id_Target_ToSource_TransparentContainer_Secondary(Target_ToSource_TransparentContainer),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverCommandProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverCommandProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for HandoverCommandProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: HandoverCommandProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(HandoverCommandProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                HandoverCommandProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                HandoverCommandProtocolIEs_EntryValue::Id_E_RABSubjecttoDataForwardingList(_) => 12,
                HandoverCommandProtocolIEs_EntryValue::Id_E_RABtoReleaseListHOCmd(_) => 13,
                HandoverCommandProtocolIEs_EntryValue::Id_HandoverType(_) => 1,
                HandoverCommandProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                HandoverCommandProtocolIEs_EntryValue::Id_NASSecurityParametersfromE_UTRAN(_) => 135,
                HandoverCommandProtocolIEs_EntryValue::Id_Target_ToSource_TransparentContainer(_) => 123,
                HandoverCommandProtocolIEs_EntryValue::Id_Target_ToSource_TransparentContainer_Secondary(_) => 139,
                HandoverCommandProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverCommandProtocolIEs(pub Vec<HandoverCommandProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for HandoverCommandProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(HandoverCommandProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum HandoverFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverFailureProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for HandoverFailureProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: HandoverFailureProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(HandoverFailureProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                HandoverFailureProtocolIEs_EntryValue::Id_Cause(_) => 2,
                HandoverFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                HandoverFailureProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverFailureProtocolIEs(pub Vec<HandoverFailureProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for HandoverFailureProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(HandoverFailureProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum HandoverNotifyProtocolIEs_EntryValue {
    #[asn(key = 100)]
    Id_EUTRAN_CGI(EUTRAN_CGI),
    #[asn(key = 186)]
    Id_LHN_ID(LHN_ID),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 320)]
    Id_NotifySourceeNB(NotifySourceeNB),
    #[asn(key = 288)]
    Id_PSCellInformation(PSCellInformation),
    #[asn(key = 67)]
    Id_TAI(TAI),
    #[asn(key = 176)]
    Id_Tunnel_Information_for_BBF(TunnelInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverNotifyProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverNotifyProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for HandoverNotifyProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: HandoverNotifyProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(HandoverNotifyProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                HandoverNotifyProtocolIEs_EntryValue::Id_EUTRAN_CGI(_) => 100,
                HandoverNotifyProtocolIEs_EntryValue::Id_LHN_ID(_) => 186,
                HandoverNotifyProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                HandoverNotifyProtocolIEs_EntryValue::Id_NotifySourceeNB(_) => 320,
                HandoverNotifyProtocolIEs_EntryValue::Id_PSCellInformation(_) => 288,
                HandoverNotifyProtocolIEs_EntryValue::Id_TAI(_) => 67,
                HandoverNotifyProtocolIEs_EntryValue::Id_Tunnel_Information_for_BBF(_) => 176,
                HandoverNotifyProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverNotifyProtocolIEs(pub Vec<HandoverNotifyProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for HandoverNotifyProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(HandoverNotifyProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum HandoverPreparationFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverPreparationFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverPreparationFailureProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for HandoverPreparationFailureProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: HandoverPreparationFailureProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(HandoverPreparationFailureProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                HandoverPreparationFailureProtocolIEs_EntryValue::Id_Cause(_) => 2,
                HandoverPreparationFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                HandoverPreparationFailureProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                HandoverPreparationFailureProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverPreparationFailureProtocolIEs(
    pub Vec<HandoverPreparationFailureProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for HandoverPreparationFailureProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(HandoverPreparationFailureProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum HandoverRequestProtocolIEs_EntryValue {
    #[asn(key = 299)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 277)]
    Id_AerialUEsubscriptionInformation(AerialUEsubscriptionInformation),
    #[asn(key = 271)]
    Id_CE_ModeBRestricted(CE_ModeBRestricted),
    #[asn(key = 127)]
    Id_CSG_Id(CSG_Id),
    #[asn(key = 146)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 53)]
    Id_E_RABToBeSetupListHOReq(E_RABToBeSetupListHOReq),
    #[asn(key = 251)]
    Id_EnhancedCoverageRestricted(EnhancedCoverageRestricted),
    #[asn(key = 196)]
    Id_ExpectedUEBehaviour(ExpectedUEBehaviour),
    #[asn(key = 75)]
    Id_GUMMEI_ID(GUMMEI),
    #[asn(key = 41)]
    Id_HandoverRestrictionList(HandoverRestrictionList),
    #[asn(key = 1)]
    Id_HandoverType(HandoverType),
    #[asn(key = 301)]
    Id_IAB_Authorized(IAB_Authorized),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 158)]
    Id_MME_UE_S1AP_ID_2(MME_UE_S1AP_ID),
    #[asn(key = 165)]
    Id_ManagementBasedMDTAllowed(ManagementBasedMDTAllowed),
    #[asn(key = 177)]
    Id_ManagementBasedMDTPLMNList(MDTPLMNList),
    #[asn(key = 192)]
    Id_Masked_IMEISV(Masked_IMEISV),
    #[asn(key = 136)]
    Id_NASSecurityParameterstoE_UTRAN(NASSecurityParameterstoE_UTRAN),
    #[asn(key = 269)]
    Id_NRUESecurityCapabilities(NRUESecurityCapabilities),
    #[asn(key = 307)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 306)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 308)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 283)]
    Id_PendingDataIndication(PendingDataIndication),
    #[asn(key = 195)]
    Id_ProSeAuthorized(ProSeAuthorized),
    #[asn(key = 98)]
    Id_RequestType(RequestType),
    #[asn(key = 124)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 40)]
    Id_SecurityContext(SecurityContext),
    #[asn(key = 104)]
    Id_Source_ToTarget_TransparentContainer(Source_ToTarget_TransparentContainer),
    #[asn(key = 278)]
    Id_Subscription_Based_UE_DifferentiationInfo(Subscription_Based_UE_DifferentiationInfo),
    #[asn(key = 25)]
    Id_TraceActivation(TraceActivation),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 107)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
    #[asn(key = 248)]
    Id_UESidelinkAggregateMaximumBitrate(UESidelinkAggregateMaximumBitrate),
    #[asn(key = 241)]
    Id_UEUserPlaneCIoTSupportIndicator(UEUserPlaneCIoTSupportIndicator),
    #[asn(key = 240)]
    Id_V2XServicesAuthorized(V2XServicesAuthorized),
    #[asn(key = 66)]
    Id_uEaggregateMaximumBitrate(UEAggregateMaximumBitrate),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverRequestProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for HandoverRequestProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: HandoverRequestProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(HandoverRequestProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                HandoverRequestProtocolIEs_EntryValue::Id_AdditionalRRMPriorityIndex(_) => 299,
                HandoverRequestProtocolIEs_EntryValue::Id_AerialUEsubscriptionInformation(_) => 277,
                HandoverRequestProtocolIEs_EntryValue::Id_CE_ModeBRestricted(_) => 271,
                HandoverRequestProtocolIEs_EntryValue::Id_CSG_Id(_) => 127,
                HandoverRequestProtocolIEs_EntryValue::Id_CSGMembershipStatus(_) => 146,
                HandoverRequestProtocolIEs_EntryValue::Id_Cause(_) => 2,
                HandoverRequestProtocolIEs_EntryValue::Id_E_RABToBeSetupListHOReq(_) => 53,
                HandoverRequestProtocolIEs_EntryValue::Id_EnhancedCoverageRestricted(_) => 251,
                HandoverRequestProtocolIEs_EntryValue::Id_ExpectedUEBehaviour(_) => 196,
                HandoverRequestProtocolIEs_EntryValue::Id_GUMMEI_ID(_) => 75,
                HandoverRequestProtocolIEs_EntryValue::Id_HandoverRestrictionList(_) => 41,
                HandoverRequestProtocolIEs_EntryValue::Id_HandoverType(_) => 1,
                HandoverRequestProtocolIEs_EntryValue::Id_IAB_Authorized(_) => 301,
                HandoverRequestProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                HandoverRequestProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID_2(_) => 158,
                HandoverRequestProtocolIEs_EntryValue::Id_ManagementBasedMDTAllowed(_) => 165,
                HandoverRequestProtocolIEs_EntryValue::Id_ManagementBasedMDTPLMNList(_) => 177,
                HandoverRequestProtocolIEs_EntryValue::Id_Masked_IMEISV(_) => 192,
                HandoverRequestProtocolIEs_EntryValue::Id_NASSecurityParameterstoE_UTRAN(_) => 136,
                HandoverRequestProtocolIEs_EntryValue::Id_NRUESecurityCapabilities(_) => 269,
                HandoverRequestProtocolIEs_EntryValue::Id_NRUESidelinkAggregateMaximumBitrate(_) => 307,
                HandoverRequestProtocolIEs_EntryValue::Id_NRV2XServicesAuthorized(_) => 306,
                HandoverRequestProtocolIEs_EntryValue::Id_PC5QoSParameters(_) => 308,
                HandoverRequestProtocolIEs_EntryValue::Id_PendingDataIndication(_) => 283,
                HandoverRequestProtocolIEs_EntryValue::Id_ProSeAuthorized(_) => 195,
                HandoverRequestProtocolIEs_EntryValue::Id_RequestType(_) => 98,
                HandoverRequestProtocolIEs_EntryValue::Id_SRVCCOperationPossible(_) => 124,
                HandoverRequestProtocolIEs_EntryValue::Id_SecurityContext(_) => 40,
                HandoverRequestProtocolIEs_EntryValue::Id_Source_ToTarget_TransparentContainer(_) => 104,
                HandoverRequestProtocolIEs_EntryValue::Id_Subscription_Based_UE_DifferentiationInfo(_) => 278,
                HandoverRequestProtocolIEs_EntryValue::Id_TraceActivation(_) => 25,
                HandoverRequestProtocolIEs_EntryValue::Id_UERadioCapabilityID(_) => 314,
                HandoverRequestProtocolIEs_EntryValue::Id_UESecurityCapabilities(_) => 107,
                HandoverRequestProtocolIEs_EntryValue::Id_UESidelinkAggregateMaximumBitrate(_) => 248,
                HandoverRequestProtocolIEs_EntryValue::Id_UEUserPlaneCIoTSupportIndicator(_) => 241,
                HandoverRequestProtocolIEs_EntryValue::Id_V2XServicesAuthorized(_) => 240,
                HandoverRequestProtocolIEs_EntryValue::Id_uEaggregateMaximumBitrate(_) => 66,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverRequestProtocolIEs(pub Vec<HandoverRequestProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for HandoverRequestProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(HandoverRequestProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum HandoverRequestAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 242)]
    Id_CE_mode_B_SupportIndicator(CE_mode_B_SupportIndicator),
    #[asn(key = 127)]
    Id_CSG_Id(CSG_Id),
    #[asn(key = 145)]
    Id_CellAccessMode(CellAccessMode),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 18)]
    Id_E_RABAdmittedList(E_RABAdmittedList),
    #[asn(key = 19)]
    Id_E_RABFailedToSetupListHOReqAck(E_RABFailedtoSetupListHOReqAck),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 123)]
    Id_Target_ToSource_TransparentContainer(Target_ToSource_TransparentContainer),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequestAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverRequestAcknowledgeProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for HandoverRequestAcknowledgeProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: HandoverRequestAcknowledgeProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(HandoverRequestAcknowledgeProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_CE_mode_B_SupportIndicator(_) => 242,
                HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_CSG_Id(_) => 127,
                HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_CellAccessMode(_) => 145,
                HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_E_RABAdmittedList(_) => 18,
                HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_E_RABFailedToSetupListHOReqAck(_) => 19,
                HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_Target_ToSource_TransparentContainer(_) => 123,
                HandoverRequestAcknowledgeProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverRequestAcknowledgeProtocolIEs(
    pub Vec<HandoverRequestAcknowledgeProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for HandoverRequestAcknowledgeProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(HandoverRequestAcknowledgeProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary::Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum HandoverRequiredProtocolIEs_EntryValue {
    #[asn(key = 127)]
    Id_CSG_Id(CSG_Id),
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 145)]
    Id_CellAccessMode(CellAccessMode),
    #[asn(key = 79)]
    Id_Direct_Forwarding_Path_Availability(Direct_Forwarding_Path_Availability),
    #[asn(key = 1)]
    Id_HandoverType(HandoverType),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 132)]
    Id_MSClassmark2(MSClassmark2),
    #[asn(key = 133)]
    Id_MSClassmark3(MSClassmark3),
    #[asn(key = 150)]
    Id_PS_ServiceNotAvailable(PS_ServiceNotAvailable),
    #[asn(key = 125)]
    Id_SRVCCHOIndication(SRVCCHOIndication),
    #[asn(key = 104)]
    Id_Source_ToTarget_TransparentContainer(Source_ToTarget_TransparentContainer),
    #[asn(key = 138)]
    Id_Source_ToTarget_TransparentContainer_Secondary(Source_ToTarget_TransparentContainer),
    #[asn(key = 4)]
    Id_TargetID(TargetID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRequiredProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverRequiredProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for HandoverRequiredProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: HandoverRequiredProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(HandoverRequiredProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                HandoverRequiredProtocolIEs_EntryValue::Id_CSG_Id(_) => 127,
                HandoverRequiredProtocolIEs_EntryValue::Id_Cause(_) => 2,
                HandoverRequiredProtocolIEs_EntryValue::Id_CellAccessMode(_) => 145,
                HandoverRequiredProtocolIEs_EntryValue::Id_Direct_Forwarding_Path_Availability(_) => 79,
                HandoverRequiredProtocolIEs_EntryValue::Id_HandoverType(_) => 1,
                HandoverRequiredProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                HandoverRequiredProtocolIEs_EntryValue::Id_MSClassmark2(_) => 132,
                HandoverRequiredProtocolIEs_EntryValue::Id_MSClassmark3(_) => 133,
                HandoverRequiredProtocolIEs_EntryValue::Id_PS_ServiceNotAvailable(_) => 150,
                HandoverRequiredProtocolIEs_EntryValue::Id_SRVCCHOIndication(_) => 125,
                HandoverRequiredProtocolIEs_EntryValue::Id_Source_ToTarget_TransparentContainer(_) => 104,
                HandoverRequiredProtocolIEs_EntryValue::Id_Source_ToTarget_TransparentContainer_Secondary(_) => 138,
                HandoverRequiredProtocolIEs_EntryValue::Id_TargetID(_) => 4,
                HandoverRequiredProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverRequiredProtocolIEs(pub Vec<HandoverRequiredProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for HandoverRequiredProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(HandoverRequiredProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum HandoverRestrictionListIE_Extensions_EntryExtensionValue {
    #[asn(key = 282)]
    Id_CNTypeRestrictions(CNTypeRestrictions),
    #[asn(key = 290)]
    Id_LastNG_RANPLMNIdentity(PLMNidentity),
    #[asn(key = 287)]
    Id_NRrestrictionin5GS(NRrestrictionin5GS),
    #[asn(key = 261)]
    Id_NRrestrictioninEPSasSecondaryRAT(NRrestrictioninEPSasSecondaryRAT),
    #[asn(key = 270)]
    Id_UnlicensedSpectrumRestriction(UnlicensedSpectrumRestriction),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverRestrictionListIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: HandoverRestrictionListIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for HandoverRestrictionListIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: HandoverRestrictionListIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(HandoverRestrictionListIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                HandoverRestrictionListIE_Extensions_EntryExtensionValue::Id_CNTypeRestrictions(_) => 282,
                HandoverRestrictionListIE_Extensions_EntryExtensionValue::Id_LastNG_RANPLMNIdentity(_) => 290,
                HandoverRestrictionListIE_Extensions_EntryExtensionValue::Id_NRrestrictionin5GS(_) => 287,
                HandoverRestrictionListIE_Extensions_EntryExtensionValue::Id_NRrestrictioninEPSasSecondaryRAT(_) => 261,
                HandoverRestrictionListIE_Extensions_EntryExtensionValue::Id_UnlicensedSpectrumRestriction(_) => 270,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct HandoverRestrictionListIE_Extensions(
    pub Vec<HandoverRestrictionListIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for HandoverRestrictionListIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(HandoverRestrictionListIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum HandoverSuccessProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct HandoverSuccessProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: HandoverSuccessProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for HandoverSuccessProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: HandoverSuccessProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(HandoverSuccessProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                HandoverSuccessProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                HandoverSuccessProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct HandoverSuccessProtocolIEs(pub Vec<HandoverSuccessProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for HandoverSuccessProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(HandoverSuccessProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct IRAT_Cell_ID_eUTRAN(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct IRAT_Cell_ID_uTRAN(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct IRAT_Cell_ID_gERAN(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum ImmediateMDTIE_Extensions_EntryExtensionValue {
    #[asn(key = 284)]
    Id_BluetoothMeasurementConfiguration(BluetoothMeasurementConfiguration),
    #[asn(key = 171)]
    Id_M3Configuration(M3Configuration),
    #[asn(key = 172)]
    Id_M4Configuration(M4Configuration),
    #[asn(key = 173)]
    Id_M5Configuration(M5Configuration),
    #[asn(key = 220)]
    Id_M6Configuration(M6Configuration),
    #[asn(key = 221)]
    Id_M7Configuration(M7Configuration),
    #[asn(key = 174)]
    Id_MDT_Location_Info(MDT_Location_Info),
    #[asn(key = 285)]
    Id_WLANMeasurementConfiguration(WLANMeasurementConfiguration),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ImmediateMDTIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: ImmediateMDTIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for ImmediateMDTIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: ImmediateMDTIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(ImmediateMDTIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                ImmediateMDTIE_Extensions_EntryExtensionValue::Id_BluetoothMeasurementConfiguration(_) => 284,
                ImmediateMDTIE_Extensions_EntryExtensionValue::Id_M3Configuration(_) => 171,
                ImmediateMDTIE_Extensions_EntryExtensionValue::Id_M4Configuration(_) => 172,
                ImmediateMDTIE_Extensions_EntryExtensionValue::Id_M5Configuration(_) => 173,
                ImmediateMDTIE_Extensions_EntryExtensionValue::Id_M6Configuration(_) => 220,
                ImmediateMDTIE_Extensions_EntryExtensionValue::Id_M7Configuration(_) => 221,
                ImmediateMDTIE_Extensions_EntryExtensionValue::Id_MDT_Location_Info(_) => 174,
                ImmediateMDTIE_Extensions_EntryExtensionValue::Id_WLANMeasurementConfiguration(_) => 285,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ImmediateMDTIE_Extensions(pub Vec<ImmediateMDTIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ImmediateMDTIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ImmediateMDTIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InformationOnRecommendedCellsAndENBsForPagingIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct InformationOnRecommendedCellsAndENBsForPagingIE_Extensions(
    pub Vec<InformationOnRecommendedCellsAndENBsForPagingIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for InformationOnRecommendedCellsAndENBsForPagingIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(InformationOnRecommendedCellsAndENBsForPagingIE_Extensions(
            v,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum InitialContextSetupFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialContextSetupFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialContextSetupFailureProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for InitialContextSetupFailureProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: InitialContextSetupFailureProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(InitialContextSetupFailureProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                InitialContextSetupFailureProtocolIEs_EntryValue::Id_Cause(_) => 2,
                InitialContextSetupFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                InitialContextSetupFailureProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                InitialContextSetupFailureProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialContextSetupFailureProtocolIEs(
    pub Vec<InitialContextSetupFailureProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for InitialContextSetupFailureProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(InitialContextSetupFailureProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum InitialContextSetupRequestProtocolIEs_EntryValue {
    #[asn(key = 187)]
    Id_AdditionalCSFallbackIndicator(AdditionalCSFallbackIndicator),
    #[asn(key = 299)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 277)]
    Id_AerialUEsubscriptionInformation(AerialUEsubscriptionInformation),
    #[asn(key = 271)]
    Id_CE_ModeBRestricted(CE_ModeBRestricted),
    #[asn(key = 108)]
    Id_CSFallbackIndicator(CSFallbackIndicator),
    #[asn(key = 146)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 24)]
    Id_E_RABToBeSetupListCtxtSUReq(E_RABToBeSetupListCtxtSUReq),
    #[asn(key = 251)]
    Id_EnhancedCoverageRestricted(EnhancedCoverageRestricted),
    #[asn(key = 196)]
    Id_ExpectedUEBehaviour(ExpectedUEBehaviour),
    #[asn(key = 75)]
    Id_GUMMEI_ID(GUMMEI),
    #[asn(key = 41)]
    Id_HandoverRestrictionList(HandoverRestrictionList),
    #[asn(key = 301)]
    Id_IAB_Authorized(IAB_Authorized),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 158)]
    Id_MME_UE_S1AP_ID_2(MME_UE_S1AP_ID),
    #[asn(key = 165)]
    Id_ManagementBasedMDTAllowed(ManagementBasedMDTAllowed),
    #[asn(key = 177)]
    Id_ManagementBasedMDTPLMNList(MDTPLMNList),
    #[asn(key = 192)]
    Id_Masked_IMEISV(Masked_IMEISV),
    #[asn(key = 269)]
    Id_NRUESecurityCapabilities(NRUESecurityCapabilities),
    #[asn(key = 307)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 306)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 308)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 283)]
    Id_PendingDataIndication(PendingDataIndication),
    #[asn(key = 195)]
    Id_ProSeAuthorized(ProSeAuthorized),
    #[asn(key = 159)]
    Id_RegisteredLAI(LAI),
    #[asn(key = 124)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 73)]
    Id_SecurityKey(SecurityKey),
    #[asn(key = 106)]
    Id_SubscriberProfileIDforRFP(SubscriberProfileIDforRFP),
    #[asn(key = 278)]
    Id_Subscription_Based_UE_DifferentiationInfo(Subscription_Based_UE_DifferentiationInfo),
    #[asn(key = 25)]
    Id_TraceActivation(TraceActivation),
    #[asn(key = 74)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 107)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
    #[asn(key = 248)]
    Id_UESidelinkAggregateMaximumBitrate(UESidelinkAggregateMaximumBitrate),
    #[asn(key = 241)]
    Id_UEUserPlaneCIoTSupportIndicator(UEUserPlaneCIoTSupportIndicator),
    #[asn(key = 240)]
    Id_V2XServicesAuthorized(V2XServicesAuthorized),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
    #[asn(key = 66)]
    Id_uEaggregateMaximumBitrate(UEAggregateMaximumBitrate),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialContextSetupRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialContextSetupRequestProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for InitialContextSetupRequestProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: InitialContextSetupRequestProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(InitialContextSetupRequestProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_AdditionalCSFallbackIndicator(_) => 187,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_AdditionalRRMPriorityIndex(_) => 299,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_AerialUEsubscriptionInformation(_) => 277,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_CE_ModeBRestricted(_) => 271,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_CSFallbackIndicator(_) => 108,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_CSGMembershipStatus(_) => 146,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_E_RABToBeSetupListCtxtSUReq(_) => 24,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_EnhancedCoverageRestricted(_) => 251,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_ExpectedUEBehaviour(_) => 196,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_GUMMEI_ID(_) => 75,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_HandoverRestrictionList(_) => 41,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_IAB_Authorized(_) => 301,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID_2(_) => 158,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_ManagementBasedMDTAllowed(_) => 165,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_ManagementBasedMDTPLMNList(_) => 177,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_Masked_IMEISV(_) => 192,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_NRUESecurityCapabilities(_) => 269,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_NRUESidelinkAggregateMaximumBitrate(_) => 307,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_NRV2XServicesAuthorized(_) => 306,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_PC5QoSParameters(_) => 308,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_PendingDataIndication(_) => 283,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_ProSeAuthorized(_) => 195,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_RegisteredLAI(_) => 159,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_SRVCCOperationPossible(_) => 124,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_SecurityKey(_) => 73,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_SubscriberProfileIDforRFP(_) => 106,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_Subscription_Based_UE_DifferentiationInfo(_) => 278,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_TraceActivation(_) => 25,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_UERadioCapability(_) => 74,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_UERadioCapabilityID(_) => 314,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_UESecurityCapabilities(_) => 107,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_UESidelinkAggregateMaximumBitrate(_) => 248,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_UEUserPlaneCIoTSupportIndicator(_) => 241,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_V2XServicesAuthorized(_) => 240,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
                InitialContextSetupRequestProtocolIEs_EntryValue::Id_uEaggregateMaximumBitrate(_) => 66,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialContextSetupRequestProtocolIEs(
    pub Vec<InitialContextSetupRequestProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for InitialContextSetupRequestProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(InitialContextSetupRequestProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum InitialContextSetupResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 48)]
    Id_E_RABFailedToSetupListCtxtSURes(E_RABList),
    #[asn(key = 51)]
    Id_E_RABSetupListCtxtSURes(E_RABSetupListCtxtSURes),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialContextSetupResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialContextSetupResponseProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for InitialContextSetupResponseProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: InitialContextSetupResponseProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(InitialContextSetupResponseProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                InitialContextSetupResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                InitialContextSetupResponseProtocolIEs_EntryValue::Id_E_RABFailedToSetupListCtxtSURes(_) => 48,
                InitialContextSetupResponseProtocolIEs_EntryValue::Id_E_RABSetupListCtxtSURes(_) => 51,
                InitialContextSetupResponseProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                InitialContextSetupResponseProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialContextSetupResponseProtocolIEs(
    pub Vec<InitialContextSetupResponseProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for InitialContextSetupResponseProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(InitialContextSetupResponseProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum InitialUEMessageProtocolIEs_EntryValue {
    #[asn(key = 242)]
    Id_CE_mode_B_SupportIndicator(CE_mode_B_SupportIndicator),
    #[asn(key = 127)]
    Id_CSG_Id(CSG_Id),
    #[asn(key = 145)]
    Id_CellAccessMode(CellAccessMode),
    #[asn(key = 250)]
    Id_Coverage_Level(Coverage_Level),
    #[asn(key = 246)]
    Id_DCN_ID(DCN_ID),
    #[asn(key = 281)]
    Id_EDT_Session(EDT_Session),
    #[asn(key = 100)]
    Id_EUTRAN_CGI(EUTRAN_CGI),
    #[asn(key = 75)]
    Id_GUMMEI_ID(GUMMEI),
    #[asn(key = 170)]
    Id_GUMMEIType(GUMMEIType),
    #[asn(key = 155)]
    Id_GW_TransportLayerAddress(TransportLayerAddress),
    #[asn(key = 302)]
    Id_IAB_Node_Indication(IAB_Node_Indication),
    #[asn(key = 186)]
    Id_LHN_ID(LHN_ID),
    #[asn(key = 223)]
    Id_MME_Group_ID(MME_Group_ID),
    #[asn(key = 26)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 134)]
    Id_RRC_Establishment_Cause(RRC_Establishment_Cause),
    #[asn(key = 160)]
    Id_RelayNode_Indicator(RelayNode_Indicator),
    #[asn(key = 96)]
    Id_S_TMSI(S_TMSI),
    #[asn(key = 184)]
    Id_SIPTO_L_GW_TransportLayerAddress(TransportLayerAddress),
    #[asn(key = 67)]
    Id_TAI(TAI),
    #[asn(key = 176)]
    Id_Tunnel_Information_for_BBF(TunnelInformation),
    #[asn(key = 263)]
    Id_UE_Application_Layer_Measurement_Capability(UE_Application_Layer_Measurement_Capability),
    #[asn(key = 230)]
    Id_UE_Usage_Type(UE_Usage_Type),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InitialUEMessageProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: InitialUEMessageProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for InitialUEMessageProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: InitialUEMessageProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(InitialUEMessageProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                InitialUEMessageProtocolIEs_EntryValue::Id_CE_mode_B_SupportIndicator(_) => 242,
                InitialUEMessageProtocolIEs_EntryValue::Id_CSG_Id(_) => 127,
                InitialUEMessageProtocolIEs_EntryValue::Id_CellAccessMode(_) => 145,
                InitialUEMessageProtocolIEs_EntryValue::Id_Coverage_Level(_) => 250,
                InitialUEMessageProtocolIEs_EntryValue::Id_DCN_ID(_) => 246,
                InitialUEMessageProtocolIEs_EntryValue::Id_EDT_Session(_) => 281,
                InitialUEMessageProtocolIEs_EntryValue::Id_EUTRAN_CGI(_) => 100,
                InitialUEMessageProtocolIEs_EntryValue::Id_GUMMEI_ID(_) => 75,
                InitialUEMessageProtocolIEs_EntryValue::Id_GUMMEIType(_) => 170,
                InitialUEMessageProtocolIEs_EntryValue::Id_GW_TransportLayerAddress(_) => 155,
                InitialUEMessageProtocolIEs_EntryValue::Id_IAB_Node_Indication(_) => 302,
                InitialUEMessageProtocolIEs_EntryValue::Id_LHN_ID(_) => 186,
                InitialUEMessageProtocolIEs_EntryValue::Id_MME_Group_ID(_) => 223,
                InitialUEMessageProtocolIEs_EntryValue::Id_NAS_PDU(_) => 26,
                InitialUEMessageProtocolIEs_EntryValue::Id_RRC_Establishment_Cause(_) => 134,
                InitialUEMessageProtocolIEs_EntryValue::Id_RelayNode_Indicator(_) => 160,
                InitialUEMessageProtocolIEs_EntryValue::Id_S_TMSI(_) => 96,
                InitialUEMessageProtocolIEs_EntryValue::Id_SIPTO_L_GW_TransportLayerAddress(_) => 184,
                InitialUEMessageProtocolIEs_EntryValue::Id_TAI(_) => 67,
                InitialUEMessageProtocolIEs_EntryValue::Id_Tunnel_Information_for_BBF(_) => 176,
                InitialUEMessageProtocolIEs_EntryValue::Id_UE_Application_Layer_Measurement_Capability(_) => 263,
                InitialUEMessageProtocolIEs_EntryValue::Id_UE_Usage_Type(_) => 230,
                InitialUEMessageProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct InitialUEMessageProtocolIEs(pub Vec<InitialUEMessageProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for InitialUEMessageProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(InitialUEMessageProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary::Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum InitiatingMessageValue {
    #[asn(key = 42)]
    Id_CellTrafficTrace(CellTrafficTrace),
    #[asn(key = 54)]
    Id_ConnectionEstablishmentIndication(ConnectionEstablishmentIndication),
    #[asn(key = 26)]
    Id_DeactivateTrace(DeactivateTrace),
    #[asn(key = 19)]
    Id_DownlinkS1cdma2000tunnelling(DownlinkS1cdma2000tunnelling),
    #[asn(key = 50)]
    Id_E_RABModificationIndication(E_RABModificationIndication),
    #[asn(key = 6)]
    Id_E_RABModify(E_RABModifyRequest),
    #[asn(key = 7)]
    Id_E_RABRelease(E_RABReleaseCommand),
    #[asn(key = 8)]
    Id_E_RABReleaseIndication(E_RABReleaseIndication),
    #[asn(key = 5)]
    Id_E_RABSetup(E_RABSetupRequest),
    #[asn(key = 29)]
    Id_ENBConfigurationUpdate(ENBConfigurationUpdate),
    #[asn(key = 15)]
    Id_ErrorIndication(ErrorIndication),
    #[asn(key = 4)]
    Id_HandoverCancel(HandoverCancel),
    #[asn(key = 2)]
    Id_HandoverNotification(HandoverNotify),
    #[asn(key = 0)]
    Id_HandoverPreparation(HandoverRequired),
    #[asn(key = 1)]
    Id_HandoverResourceAllocation(HandoverRequest),
    #[asn(key = 64)]
    Id_HandoverSuccess(HandoverSuccess),
    #[asn(key = 9)]
    Id_InitialContextSetup(InitialContextSetupRequest),
    #[asn(key = 43)]
    Id_Kill(KillRequest),
    #[asn(key = 33)]
    Id_LocationReport(LocationReport),
    #[asn(key = 31)]
    Id_LocationReportingControl(LocationReportingControl),
    #[asn(key = 32)]
    Id_LocationReportingFailureIndication(LocationReportingFailureIndication),
    #[asn(key = 61)]
    Id_MMECPRelocationIndication(MMECPRelocationIndication),
    #[asn(key = 41)]
    Id_MMEConfigurationTransfer(MMEConfigurationTransfer),
    #[asn(key = 30)]
    Id_MMEConfigurationUpdate(MMEConfigurationUpdate),
    #[asn(key = 38)]
    Id_MMEDirectInformationTransfer(MMEDirectInformationTransfer),
    #[asn(key = 66)]
    Id_MMEEarlyStatusTransfer(MMEEarlyStatusTransfer),
    #[asn(key = 25)]
    Id_MMEStatusTransfer(MMEStatusTransfer),
    #[asn(key = 57)]
    Id_NASDeliveryIndication(NASDeliveryIndication),
    #[asn(key = 16)]
    Id_NASNonDeliveryIndication(NASNonDeliveryIndication),
    #[asn(key = 34)]
    Id_OverloadStart(OverloadStart),
    #[asn(key = 35)]
    Id_OverloadStop(OverloadStop),
    #[asn(key = 51)]
    Id_PWSFailureIndication(PWSFailureIndication),
    #[asn(key = 49)]
    Id_PWSRestartIndication(PWSRestartIndication),
    #[asn(key = 10)]
    Id_Paging(Paging),
    #[asn(key = 3)]
    Id_PathSwitchRequest(PathSwitchRequest),
    //#[asn(key = 39)]
    //Id_PrivateMessage(PrivateMessage),
    #[asn(key = 52)]
    Id_RerouteNASRequest(RerouteNASRequest),
    #[asn(key = 14)]
    Id_Reset(Reset),
    #[asn(key = 58)]
    Id_RetrieveUEInformation(RetrieveUEInformation),
    #[asn(key = 17)]
    Id_S1Setup(S1SetupRequest),
    #[asn(key = 62)]
    Id_SecondaryRATDataUsageReport(SecondaryRATDataUsageReport),
    #[asn(key = 28)]
    Id_TraceFailureIndication(TraceFailureIndication),
    #[asn(key = 27)]
    Id_TraceStart(TraceStart),
    #[asn(key = 22)]
    Id_UECapabilityInfoIndication(UECapabilityInfoIndication),
    #[asn(key = 21)]
    Id_UEContextModification(UEContextModificationRequest),
    #[asn(key = 53)]
    Id_UEContextModificationIndication(UEContextModificationIndication),
    #[asn(key = 23)]
    Id_UEContextRelease(UEContextReleaseCommand),
    #[asn(key = 18)]
    Id_UEContextReleaseRequest(UEContextReleaseRequest),
    #[asn(key = 56)]
    Id_UEContextResume(UEContextResumeRequest),
    #[asn(key = 55)]
    Id_UEContextSuspend(UEContextSuspendRequest),
    #[asn(key = 59)]
    Id_UEInformationTransfer(UEInformationTransfer),
    #[asn(key = 63)]
    Id_UERadioCapabilityIDMapping(UERadioCapabilityIDMappingRequest),
    #[asn(key = 48)]
    Id_UERadioCapabilityMatch(UERadioCapabilityMatchRequest),
    #[asn(key = 20)]
    Id_UplinkS1cdma2000tunnelling(UplinkS1cdma2000tunnelling),
    #[asn(key = 36)]
    Id_WriteReplaceWarning(WriteReplaceWarningRequest),
    #[asn(key = 11)]
    Id_downlinkNASTransport(DownlinkNASTransport),
    #[asn(key = 46)]
    Id_downlinkNonUEAssociatedLPPaTransport(DownlinkNonUEAssociatedLPPaTransport),
    #[asn(key = 44)]
    Id_downlinkUEAssociatedLPPaTransport(DownlinkUEAssociatedLPPaTransport),
    #[asn(key = 60)]
    Id_eNBCPRelocationIndication(ENBCPRelocationIndication),
    #[asn(key = 40)]
    Id_eNBConfigurationTransfer(ENBConfigurationTransfer),
    #[asn(key = 37)]
    Id_eNBDirectInformationTransfer(ENBDirectInformationTransfer),
    #[asn(key = 65)]
    Id_eNBEarlyStatusTransfer(ENBEarlyStatusTransfer),
    #[asn(key = 24)]
    Id_eNBStatusTransfer(ENBStatusTransfer),
    #[asn(key = 12)]
    Id_initialUEMessage(InitialUEMessage),
    #[asn(key = 13)]
    Id_uplinkNASTransport(UplinkNASTransport),
    #[asn(key = 47)]
    Id_uplinkNonUEAssociatedLPPaTransport(UplinkNonUEAssociatedLPPaTransport),
    #[asn(key = 45)]
    Id_uplinkUEAssociatedLPPaTransport(UplinkUEAssociatedLPPaTransport),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "1", ub = "1024")]
pub struct InterSystemMeasurementItemFreqBandIndicatorNR(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for InterSystemMeasurementItemFreqBandIndicatorNR {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(InterSystemMeasurementItemFreqBandIndicatorNR(
            u.int_in_range(1..=1024)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "32")]
pub struct InterSystemMeasurementItemSSBfrequencies(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for InterSystemMeasurementItemSSBfrequencies {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(InterSystemMeasurementItemSSBfrequencies(
            u.int_in_range(0..=32)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct InterSystemMeasurementItemSubcarrierSpacingSSB(pub u8);
impl InterSystemMeasurementItemSubcarrierSpacingSSB {
    pub const K_HZ15: u8 = 0u8;
    pub const K_HZ30: u8 = 1u8;
    pub const K_HZ60: u8 = 2u8;
    pub const K_HZ120: u8 = 3u8;
    pub const K_HZ240: u8 = 4u8;
}
impl<'a> arbitrary::Arbitrary<'a> for InterSystemMeasurementItemSubcarrierSpacingSSB {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(InterSystemMeasurementItemSubcarrierSpacingSSB(
            u.int_in_range(0..=4)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "1", ub = "16")]
pub struct InterSystemMeasurementItemMaxRSIndexCellQual(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for InterSystemMeasurementItemMaxRSIndexCellQual {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(InterSystemMeasurementItemMaxRSIndexCellQual(
            u.int_in_range(1..=16)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct InterSystemMeasurementItemSMTC(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct InterSystemMeasurementItemThreshRS_Index_r15(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct InterSystemMeasurementItemSSBToMeasure(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct InterSystemMeasurementItemSSRSSIMeasurement(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct InterSystemMeasurementItemQuantityConfigNR_R15(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct InterSystemMeasurementItemBlackCellsToAddModList(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterSystemMeasurementItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct InterSystemMeasurementItemIE_Extensions(
    pub Vec<InterSystemMeasurementItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for InterSystemMeasurementItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(InterSystemMeasurementItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "1", ub = "100")]
pub struct InterSystemMeasurementParametersMeasurementDuration(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for InterSystemMeasurementParametersMeasurementDuration {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(InterSystemMeasurementParametersMeasurementDuration(
            u.int_in_range(1..=100)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct InterSystemMeasurementParametersIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct InterSystemMeasurementParametersIE_Extensions(
    pub Vec<InterSystemMeasurementParametersIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for InterSystemMeasurementParametersIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(InterSystemMeasurementParametersIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct IntersystemMeasurementConfigurationRSRP(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for IntersystemMeasurementConfigurationRSRP {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(IntersystemMeasurementConfigurationRSRP(
            u.int_in_range(0..=127)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct IntersystemMeasurementConfigurationRSRQ(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for IntersystemMeasurementConfigurationRSRQ {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(IntersystemMeasurementConfigurationRSRQ(
            u.int_in_range(0..=127)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "127")]
pub struct IntersystemMeasurementConfigurationSINR(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for IntersystemMeasurementConfigurationSINR {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(IntersystemMeasurementConfigurationSINR(
            u.int_in_range(0..=127)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct IntersystemMeasurementConfigurationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct IntersystemMeasurementConfigurationIE_Extensions(
    pub Vec<IntersystemMeasurementConfigurationIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for IntersystemMeasurementConfigurationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(IntersystemMeasurementConfigurationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum KillRequestProtocolIEs_EntryValue {
    #[asn(key = 191)]
    Id_KillAllWarningMessages(KillAllWarningMessages),
    #[asn(key = 111)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 112)]
    Id_SerialNumber(SerialNumber),
    #[asn(key = 113)]
    Id_WarningAreaList(WarningAreaList),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct KillRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: KillRequestProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for KillRequestProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: KillRequestProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(KillRequestProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                KillRequestProtocolIEs_EntryValue::Id_KillAllWarningMessages(_) => 191,
                KillRequestProtocolIEs_EntryValue::Id_MessageIdentifier(_) => 111,
                KillRequestProtocolIEs_EntryValue::Id_SerialNumber(_) => 112,
                KillRequestProtocolIEs_EntryValue::Id_WarningAreaList(_) => 113,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct KillRequestProtocolIEs(pub Vec<KillRequestProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for KillRequestProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(KillRequestProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum KillResponseProtocolIEs_EntryValue {
    #[asn(key = 141)]
    Id_BroadcastCancelledAreaList(BroadcastCancelledAreaList),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 111)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 112)]
    Id_SerialNumber(SerialNumber),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct KillResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: KillResponseProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for KillResponseProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: KillResponseProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(KillResponseProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                KillResponseProtocolIEs_EntryValue::Id_BroadcastCancelledAreaList(_) => 141,
                KillResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                KillResponseProtocolIEs_EntryValue::Id_MessageIdentifier(_) => 111,
                KillResponseProtocolIEs_EntryValue::Id_SerialNumber(_) => 112,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct KillResponseProtocolIEs(pub Vec<KillResponseProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for KillResponseProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(KillResponseProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LAIIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LAIIE_Extensions(pub Vec<LAIIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for LAIIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(LAIIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum LastVisitedEUTRANCellInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 168)]
    Id_HO_Cause(Cause),
    #[asn(key = 167)]
    Id_Time_UE_StayedInCell_EnhancedGranularity(Time_UE_StayedInCell_EnhancedGranularity),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LastVisitedEUTRANCellInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: LastVisitedEUTRANCellInformationIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for LastVisitedEUTRANCellInformationIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: LastVisitedEUTRANCellInformationIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(LastVisitedEUTRANCellInformationIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                LastVisitedEUTRANCellInformationIE_Extensions_EntryExtensionValue::Id_HO_Cause(_) => 168,
                LastVisitedEUTRANCellInformationIE_Extensions_EntryExtensionValue::Id_Time_UE_StayedInCell_EnhancedGranularity(_) => 167,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LastVisitedEUTRANCellInformationIE_Extensions(
    pub Vec<LastVisitedEUTRANCellInformationIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for LastVisitedEUTRANCellInformationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(LastVisitedEUTRANCellInformationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "NULL")]
pub struct LastVisitedGERANCellInformation_undefined;

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "3")]
pub struct ListeningSubframePatternPattern_period(pub u8);
impl ListeningSubframePatternPattern_period {
    pub const MS1280: u8 = 0u8;
    pub const MS2560: u8 = 1u8;
    pub const MS5120: u8 = 2u8;
    pub const MS10240: u8 = 3u8;
}
impl<'a> arbitrary::Arbitrary<'a> for ListeningSubframePatternPattern_period {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ListeningSubframePatternPattern_period(
            u.int_in_range(0..=3)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "10239", extensible = true)]
pub struct ListeningSubframePatternPattern_offset(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for ListeningSubframePatternPattern_offset {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ListeningSubframePatternPattern_offset(
            u.int_in_range(0..=10239)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ListeningSubframePatternIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ListeningSubframePatternIE_Extensions(
    pub Vec<ListeningSubframePatternIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for ListeningSubframePatternIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ListeningSubframePatternIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum LocationReportProtocolIEs_EntryValue {
    #[asn(key = 100)]
    Id_EUTRAN_CGI(EUTRAN_CGI),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 288)]
    Id_PSCellInformation(PSCellInformation),
    #[asn(key = 98)]
    Id_RequestType(RequestType),
    #[asn(key = 67)]
    Id_TAI(TAI),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationReportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: LocationReportProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for LocationReportProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: LocationReportProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(LocationReportProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                LocationReportProtocolIEs_EntryValue::Id_EUTRAN_CGI(_) => 100,
                LocationReportProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                LocationReportProtocolIEs_EntryValue::Id_PSCellInformation(_) => 288,
                LocationReportProtocolIEs_EntryValue::Id_RequestType(_) => 98,
                LocationReportProtocolIEs_EntryValue::Id_TAI(_) => 67,
                LocationReportProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct LocationReportProtocolIEs(pub Vec<LocationReportProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for LocationReportProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(LocationReportProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum LocationReportingControlProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 98)]
    Id_RequestType(RequestType),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationReportingControlProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: LocationReportingControlProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for LocationReportingControlProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: LocationReportingControlProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(LocationReportingControlProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                LocationReportingControlProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                LocationReportingControlProtocolIEs_EntryValue::Id_RequestType(_) => 98,
                LocationReportingControlProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct LocationReportingControlProtocolIEs(pub Vec<LocationReportingControlProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for LocationReportingControlProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(LocationReportingControlProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum LocationReportingFailureIndicationProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LocationReportingFailureIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: LocationReportingFailureIndicationProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for LocationReportingFailureIndicationProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: LocationReportingFailureIndicationProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(LocationReportingFailureIndicationProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                LocationReportingFailureIndicationProtocolIEs_EntryValue::Id_Cause(_) => 2,
                LocationReportingFailureIndicationProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                LocationReportingFailureIndicationProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct LocationReportingFailureIndicationProtocolIEs(
    pub Vec<LocationReportingFailureIndicationProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for LocationReportingFailureIndicationProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(LocationReportingFailureIndicationProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LoggedMBSFNMDTIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LoggedMBSFNMDTIE_Extensions(pub Vec<LoggedMBSFNMDTIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for LoggedMBSFNMDTIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(LoggedMBSFNMDTIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum LoggedMDTIE_Extensions_EntryExtensionValue {
    #[asn(key = 284)]
    Id_BluetoothMeasurementConfiguration(BluetoothMeasurementConfiguration),
    #[asn(key = 285)]
    Id_WLANMeasurementConfiguration(WLANMeasurementConfiguration),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct LoggedMDTIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: LoggedMDTIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for LoggedMDTIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: LoggedMDTIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(LoggedMDTIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                LoggedMDTIE_Extensions_EntryExtensionValue::Id_BluetoothMeasurementConfiguration(_) => 284,
                LoggedMDTIE_Extensions_EntryExtensionValue::Id_WLANMeasurementConfiguration(_) => 285,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct LoggedMDTIE_Extensions(pub Vec<LoggedMDTIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for LoggedMDTIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(LoggedMDTIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M1PeriodicReportingIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M1PeriodicReportingIE_Extensions(pub Vec<M1PeriodicReportingIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for M1PeriodicReportingIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(M1PeriodicReportingIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M1ThresholdEventA2IE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M1ThresholdEventA2IE_Extensions(pub Vec<M1ThresholdEventA2IE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for M1ThresholdEventA2IE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(M1ThresholdEventA2IE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M3ConfigurationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M3ConfigurationIE_Extensions(pub Vec<M3ConfigurationIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for M3ConfigurationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(M3ConfigurationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M4ConfigurationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M4ConfigurationIE_Extensions(pub Vec<M4ConfigurationIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for M4ConfigurationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(M4ConfigurationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M5ConfigurationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M5ConfigurationIE_Extensions(pub Vec<M5ConfigurationIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for M5ConfigurationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(M5ConfigurationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M6ConfigurationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M6ConfigurationIE_Extensions(pub Vec<M6ConfigurationIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for M6ConfigurationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(M6ConfigurationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct M7ConfigurationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct M7ConfigurationIE_Extensions(pub Vec<M7ConfigurationIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for M7ConfigurationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(M7ConfigurationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "255")]
pub struct MBSFN_ResultToLogInfoMBSFN_AreaId(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for MBSFN_ResultToLogInfoMBSFN_AreaId {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(MBSFN_ResultToLogInfoMBSFN_AreaId(u.int_in_range(0..=255)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MBSFN_ResultToLogInfoIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MBSFN_ResultToLogInfoIE_Extensions(pub Vec<MBSFN_ResultToLogInfoIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for MBSFN_ResultToLogInfoIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(MBSFN_ResultToLogInfoIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum MDT_ConfigurationIE_Extensions_EntryExtensionValue {
    #[asn(key = 178)]
    Id_SignallingBasedMDTPLMNList(MDTPLMNList),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MDT_ConfigurationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: MDT_ConfigurationIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for MDT_ConfigurationIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: MDT_ConfigurationIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(MDT_ConfigurationIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                MDT_ConfigurationIE_Extensions_EntryExtensionValue::Id_SignallingBasedMDTPLMNList(_) => 178,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MDT_ConfigurationIE_Extensions(pub Vec<MDT_ConfigurationIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for MDT_ConfigurationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(MDT_ConfigurationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum MDTMode_ExtensionValue {
    #[asn(key = 197)]
    Id_LoggedMBSFNMDT(LoggedMBSFNMDT),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum MMECPRelocationIndicationProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMECPRelocationIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMECPRelocationIndicationProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for MMECPRelocationIndicationProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: MMECPRelocationIndicationProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(MMECPRelocationIndicationProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                MMECPRelocationIndicationProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                MMECPRelocationIndicationProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMECPRelocationIndicationProtocolIEs(
    pub Vec<MMECPRelocationIndicationProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for MMECPRelocationIndicationProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(MMECPRelocationIndicationProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum MMEConfigurationTransferProtocolIEs_EntryValue {
    #[asn(key = 295)]
    Id_EN_DCSONConfigurationTransfer_MCT(EN_DCSONConfigurationTransfer),
    #[asn(key = 309)]
    Id_IntersystemSONConfigurationTransferMCT(IntersystemSONConfigurationTransfer),
    #[asn(key = 130)]
    Id_SONConfigurationTransferMCT(SONConfigurationTransfer),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMEConfigurationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMEConfigurationTransferProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for MMEConfigurationTransferProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: MMEConfigurationTransferProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(MMEConfigurationTransferProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                MMEConfigurationTransferProtocolIEs_EntryValue::Id_EN_DCSONConfigurationTransfer_MCT(_) => 295,
                MMEConfigurationTransferProtocolIEs_EntryValue::Id_IntersystemSONConfigurationTransferMCT(_) => 309,
                MMEConfigurationTransferProtocolIEs_EntryValue::Id_SONConfigurationTransferMCT(_) => 130,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMEConfigurationTransferProtocolIEs(pub Vec<MMEConfigurationTransferProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for MMEConfigurationTransferProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(MMEConfigurationTransferProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum MMEConfigurationUpdateProtocolIEs_EntryValue {
    #[asn(key = 61)]
    Id_MMEname(MMEname),
    #[asn(key = 87)]
    Id_RelativeMMECapacity(RelativeMMECapacity),
    #[asn(key = 247)]
    Id_ServedDCNs(ServedDCNs),
    #[asn(key = 105)]
    Id_ServedGUMMEIs(ServedGUMMEIs),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMEConfigurationUpdateProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMEConfigurationUpdateProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for MMEConfigurationUpdateProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: MMEConfigurationUpdateProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(MMEConfigurationUpdateProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                MMEConfigurationUpdateProtocolIEs_EntryValue::Id_MMEname(_) => 61,
                MMEConfigurationUpdateProtocolIEs_EntryValue::Id_RelativeMMECapacity(_) => 87,
                MMEConfigurationUpdateProtocolIEs_EntryValue::Id_ServedDCNs(_) => 247,
                MMEConfigurationUpdateProtocolIEs_EntryValue::Id_ServedGUMMEIs(_) => 105,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMEConfigurationUpdateProtocolIEs(pub Vec<MMEConfigurationUpdateProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for MMEConfigurationUpdateProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(MMEConfigurationUpdateProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum MMEConfigurationUpdateAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMEConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMEConfigurationUpdateAcknowledgeProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for MMEConfigurationUpdateAcknowledgeProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: MMEConfigurationUpdateAcknowledgeProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(MMEConfigurationUpdateAcknowledgeProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                MMEConfigurationUpdateAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMEConfigurationUpdateAcknowledgeProtocolIEs(
    pub Vec<MMEConfigurationUpdateAcknowledgeProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for MMEConfigurationUpdateAcknowledgeProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(MMEConfigurationUpdateAcknowledgeProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum MMEConfigurationUpdateFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 65)]
    Id_TimeToWait(TimeToWait),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMEConfigurationUpdateFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMEConfigurationUpdateFailureProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for MMEConfigurationUpdateFailureProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: MMEConfigurationUpdateFailureProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(MMEConfigurationUpdateFailureProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                MMEConfigurationUpdateFailureProtocolIEs_EntryValue::Id_Cause(_) => 2,
                MMEConfigurationUpdateFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                MMEConfigurationUpdateFailureProtocolIEs_EntryValue::Id_TimeToWait(_) => 65,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMEConfigurationUpdateFailureProtocolIEs(
    pub Vec<MMEConfigurationUpdateFailureProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for MMEConfigurationUpdateFailureProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(MMEConfigurationUpdateFailureProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum MMEDirectInformationTransferProtocolIEs_EntryValue {
    #[asn(key = 122)]
    Id_Inter_SystemInformationTransferTypeMDT(Inter_SystemInformationTransferType),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMEDirectInformationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMEDirectInformationTransferProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for MMEDirectInformationTransferProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: MMEDirectInformationTransferProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(MMEDirectInformationTransferProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                MMEDirectInformationTransferProtocolIEs_EntryValue::Id_Inter_SystemInformationTransferTypeMDT(_) => 122,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMEDirectInformationTransferProtocolIEs(
    pub Vec<MMEDirectInformationTransferProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for MMEDirectInformationTransferProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(MMEDirectInformationTransferProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum MMEEarlyStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 321)]
    Id_eNB_EarlyStatusTransfer_TransparentContainer(ENB_EarlyStatusTransfer_TransparentContainer),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMEEarlyStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMEEarlyStatusTransferProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for MMEEarlyStatusTransferProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: MMEEarlyStatusTransferProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(MMEEarlyStatusTransferProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                MMEEarlyStatusTransferProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                MMEEarlyStatusTransferProtocolIEs_EntryValue::Id_eNB_EarlyStatusTransfer_TransparentContainer(_) => 321,
                MMEEarlyStatusTransferProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMEEarlyStatusTransferProtocolIEs(pub Vec<MMEEarlyStatusTransferProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for MMEEarlyStatusTransferProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(MMEEarlyStatusTransferProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum MMEStatusTransferProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 90)]
    Id_eNB_StatusTransfer_TransparentContainer(ENB_StatusTransfer_TransparentContainer),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MMEStatusTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: MMEStatusTransferProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for MMEStatusTransferProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: MMEStatusTransferProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(MMEStatusTransferProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                MMEStatusTransferProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                MMEStatusTransferProtocolIEs_EntryValue::Id_eNB_StatusTransfer_TransparentContainer(_) => 90,
                MMEStatusTransferProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct MMEStatusTransferProtocolIEs(pub Vec<MMEStatusTransferProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for MMEStatusTransferProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(MMEStatusTransferProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct MultiCellLoadReportingResponse_Item_uTRANResponse(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct MultiCellLoadReportingResponse_Item_gERANResponse(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "4")]
pub struct MutingPatternInformationMuting_pattern_period(pub u8);
impl MutingPatternInformationMuting_pattern_period {
    pub const MS0: u8 = 0u8;
    pub const MS1280: u8 = 1u8;
    pub const MS2560: u8 = 2u8;
    pub const MS5120: u8 = 3u8;
    pub const MS10240: u8 = 4u8;
}
impl<'a> arbitrary::Arbitrary<'a> for MutingPatternInformationMuting_pattern_period {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(MutingPatternInformationMuting_pattern_period(
            u.int_in_range(0..=4)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "10239", extensible = true)]
pub struct MutingPatternInformationMuting_pattern_offset(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for MutingPatternInformationMuting_pattern_offset {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(MutingPatternInformationMuting_pattern_offset(
            u.int_in_range(0..=10239)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct MutingPatternInformationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct MutingPatternInformationIE_Extensions(
    pub Vec<MutingPatternInformationIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for MutingPatternInformationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(MutingPatternInformationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum NASDeliveryIndicationProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NASDeliveryIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NASDeliveryIndicationProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for NASDeliveryIndicationProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: NASDeliveryIndicationProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(NASDeliveryIndicationProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                NASDeliveryIndicationProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                NASDeliveryIndicationProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NASDeliveryIndicationProtocolIEs(pub Vec<NASDeliveryIndicationProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for NASDeliveryIndicationProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(NASDeliveryIndicationProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum NASNonDeliveryIndicationProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 26)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NASNonDeliveryIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: NASNonDeliveryIndicationProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for NASNonDeliveryIndicationProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: NASNonDeliveryIndicationProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(NASNonDeliveryIndicationProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                NASNonDeliveryIndicationProtocolIEs_EntryValue::Id_Cause(_) => 2,
                NASNonDeliveryIndicationProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                NASNonDeliveryIndicationProtocolIEs_EntryValue::Id_NAS_PDU(_) => 26,
                NASNonDeliveryIndicationProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct NASNonDeliveryIndicationProtocolIEs(pub Vec<NASNonDeliveryIndicationProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for NASNonDeliveryIndicationProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(NASNonDeliveryIndicationProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NB_IoT_Paging_eDRXInformationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NB_IoT_Paging_eDRXInformationIE_Extensions(
    pub Vec<NB_IoT_Paging_eDRXInformationIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for NB_IoT_Paging_eDRXInformationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(NB_IoT_Paging_eDRXInformationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NG_eNBIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NG_eNBIE_Extensions(pub Vec<NG_eNBIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for NG_eNBIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(NG_eNBIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NR_CGIIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NR_CGIIE_Extensions(pub Vec<NR_CGIIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for NR_CGIIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(NR_CGIIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRUESecurityCapabilitiesIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRUESecurityCapabilitiesIE_Extensions(
    pub Vec<NRUESecurityCapabilitiesIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for NRUESecurityCapabilitiesIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(NRUESecurityCapabilitiesIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRUESidelinkAggregateMaximumBitrateIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRUESidelinkAggregateMaximumBitrateIE_Extensions(
    pub Vec<NRUESidelinkAggregateMaximumBitrateIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for NRUESidelinkAggregateMaximumBitrateIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(NRUESidelinkAggregateMaximumBitrateIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct NRV2XServicesAuthorizedIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct NRV2XServicesAuthorizedIE_Extensions(
    pub Vec<NRV2XServicesAuthorizedIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for NRV2XServicesAuthorizedIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(NRV2XServicesAuthorizedIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct NotificationCellList_ItemCell_ID(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum OverloadStartProtocolIEs_EntryValue {
    #[asn(key = 154)]
    Id_GUMMEIList(GUMMEIList),
    #[asn(key = 101)]
    Id_OverloadResponse(OverloadResponse),
    #[asn(key = 161)]
    Id_TrafficLoadReductionIndication(TrafficLoadReductionIndication),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverloadStartProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: OverloadStartProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for OverloadStartProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: OverloadStartProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(OverloadStartProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                OverloadStartProtocolIEs_EntryValue::Id_GUMMEIList(_) => 154,
                OverloadStartProtocolIEs_EntryValue::Id_OverloadResponse(_) => 101,
                OverloadStartProtocolIEs_EntryValue::Id_TrafficLoadReductionIndication(_) => 161,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct OverloadStartProtocolIEs(pub Vec<OverloadStartProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for OverloadStartProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(OverloadStartProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum OverloadStopProtocolIEs_EntryValue {
    #[asn(key = 154)]
    Id_GUMMEIList(GUMMEIList),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct OverloadStopProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: OverloadStopProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for OverloadStopProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: OverloadStopProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(OverloadStopProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                OverloadStopProtocolIEs_EntryValue::Id_GUMMEIList(_) => 154,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct OverloadStopProtocolIEs(pub Vec<OverloadStopProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for OverloadStopProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(OverloadStopProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PC5FlowBitRatesIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PC5FlowBitRatesIE_Extensions(pub Vec<PC5FlowBitRatesIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for PC5FlowBitRatesIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PC5FlowBitRatesIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PC5QoSFlowItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PC5QoSFlowItemIE_Extensions(pub Vec<PC5QoSFlowItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for PC5QoSFlowItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PC5QoSFlowItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PC5QoSParametersIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PC5QoSParametersIE_Extensions(pub Vec<PC5QoSParametersIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for PC5QoSParametersIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PC5QoSParametersIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PLMNAreaBasedQMCIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PLMNAreaBasedQMCIE_Extensions(pub Vec<PLMNAreaBasedQMCIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for PLMNAreaBasedQMCIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PLMNAreaBasedQMCIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PSCellInformationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PSCellInformationIE_Extensions(pub Vec<PSCellInformationIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for PSCellInformationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PSCellInformationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum PWSFailureIndicationProtocolIEs_EntryValue {
    #[asn(key = 59)]
    Id_Global_ENB_ID(Global_ENB_ID),
    #[asn(key = 222)]
    Id_PWSfailedECGIList(PWSfailedECGIList),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PWSFailureIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PWSFailureIndicationProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for PWSFailureIndicationProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: PWSFailureIndicationProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(PWSFailureIndicationProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                PWSFailureIndicationProtocolIEs_EntryValue::Id_Global_ENB_ID(_) => 59,
                PWSFailureIndicationProtocolIEs_EntryValue::Id_PWSfailedECGIList(_) => 222,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PWSFailureIndicationProtocolIEs(pub Vec<PWSFailureIndicationProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for PWSFailureIndicationProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PWSFailureIndicationProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum PWSRestartIndicationProtocolIEs_EntryValue {
    #[asn(key = 182)]
    Id_ECGIListForRestart(ECGIListForRestart),
    #[asn(key = 190)]
    Id_EmergencyAreaIDListForRestart(EmergencyAreaIDListForRestart),
    #[asn(key = 59)]
    Id_Global_ENB_ID(Global_ENB_ID),
    #[asn(key = 188)]
    Id_TAIListForRestart(TAIListForRestart),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PWSRestartIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PWSRestartIndicationProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for PWSRestartIndicationProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: PWSRestartIndicationProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(PWSRestartIndicationProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                PWSRestartIndicationProtocolIEs_EntryValue::Id_ECGIListForRestart(_) => 182,
                PWSRestartIndicationProtocolIEs_EntryValue::Id_EmergencyAreaIDListForRestart(_) => 190,
                PWSRestartIndicationProtocolIEs_EntryValue::Id_Global_ENB_ID(_) => 59,
                PWSRestartIndicationProtocolIEs_EntryValue::Id_TAIListForRestart(_) => 188, 
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PWSRestartIndicationProtocolIEs(pub Vec<PWSRestartIndicationProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for PWSRestartIndicationProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PWSRestartIndicationProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum PagingProtocolIEs_EntryValue {
    #[asn(key = 211)]
    Id_AssistanceDataForPaging(AssistanceDataForPaging),
    #[asn(key = 271)]
    Id_CE_ModeBRestricted(CE_ModeBRestricted),
    #[asn(key = 109)]
    Id_CNDomain(CNDomain),
    #[asn(key = 128)]
    Id_CSG_IdList(CSG_IdList),
    #[asn(key = 304)]
    Id_DataSize(DataSize),
    #[asn(key = 251)]
    Id_EnhancedCoverageRestricted(EnhancedCoverageRestricted),
    #[asn(key = 239)]
    Id_NB_IoT_Paging_eDRXInformation(NB_IoT_Paging_eDRXInformation),
    #[asn(key = 324)]
    Id_NB_IoT_PagingDRX(NB_IoT_PagingDRX),
    #[asn(key = 244)]
    Id_NB_IoT_UEIdentityIndexValue(NB_IoT_UEIdentityIndexValue),
    #[asn(key = 227)]
    Id_Paging_eDRXInformation(Paging_eDRXInformation),
    #[asn(key = 151)]
    Id_PagingPriority(PagingPriority),
    #[asn(key = 46)]
    Id_TAIList(TAIList),
    #[asn(key = 80)]
    Id_UEIdentityIndexValue(UEIdentityIndexValue),
    #[asn(key = 43)]
    Id_UEPagingID(UEPagingID),
    #[asn(key = 198)]
    Id_UERadioCapabilityForPaging(UERadioCapabilityForPaging),
    #[asn(key = 323)]
    Id_WUS_Assistance_Information(WUS_Assistance_Information),
    #[asn(key = 231)]
    Id_extended_UEIdentityIndexValue(Extended_UEIdentityIndexValue),
    #[asn(key = 44)]
    Id_pagingDRX(PagingDRX),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PagingProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PagingProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for PagingProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: PagingProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(PagingProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                PagingProtocolIEs_EntryValue::Id_AssistanceDataForPaging(_) => 211,
                PagingProtocolIEs_EntryValue::Id_CE_ModeBRestricted(_) => 271,
                PagingProtocolIEs_EntryValue::Id_CNDomain(_) => 109,
                PagingProtocolIEs_EntryValue::Id_CSG_IdList(_) => 128,
                PagingProtocolIEs_EntryValue::Id_DataSize(_) => 304,
                PagingProtocolIEs_EntryValue::Id_EnhancedCoverageRestricted(_) => 251,
                PagingProtocolIEs_EntryValue::Id_NB_IoT_Paging_eDRXInformation(_) => 239,
                PagingProtocolIEs_EntryValue::Id_NB_IoT_PagingDRX(_) => 324,
                PagingProtocolIEs_EntryValue::Id_NB_IoT_UEIdentityIndexValue(_) => 244,
                PagingProtocolIEs_EntryValue::Id_Paging_eDRXInformation(_) => 227,
                PagingProtocolIEs_EntryValue::Id_PagingPriority(_) => 151,
                PagingProtocolIEs_EntryValue::Id_TAIList(_) => 46,
                PagingProtocolIEs_EntryValue::Id_UEIdentityIndexValue(_) => 80,
                PagingProtocolIEs_EntryValue::Id_UEPagingID(_) => 43,
                PagingProtocolIEs_EntryValue::Id_UERadioCapabilityForPaging(_) => 198,
                PagingProtocolIEs_EntryValue::Id_WUS_Assistance_Information(_) => 323,
                PagingProtocolIEs_EntryValue::Id_extended_UEIdentityIndexValue(_) => 231,
                PagingProtocolIEs_EntryValue::Id_pagingDRX(_) => 44,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PagingProtocolIEs(pub Vec<PagingProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for PagingProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PagingProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Paging_eDRXInformationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Paging_eDRXInformationIE_Extensions(pub Vec<Paging_eDRXInformationIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for Paging_eDRXInformationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(Paging_eDRXInformationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PagingAttemptInformationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PagingAttemptInformationIE_Extensions(
    pub Vec<PagingAttemptInformationIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for PagingAttemptInformationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PagingAttemptInformationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestProtocolIEs_EntryValue {
    #[asn(key = 127)]
    Id_CSG_Id(CSG_Id),
    #[asn(key = 146)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 145)]
    Id_CellAccessMode(CellAccessMode),
    #[asn(key = 22)]
    Id_E_RABToBeSwitchedDLList(E_RABToBeSwitchedDLList),
    #[asn(key = 100)]
    Id_EUTRAN_CGI(EUTRAN_CGI),
    #[asn(key = 186)]
    Id_LHN_ID(LHN_ID),
    #[asn(key = 269)]
    Id_NRUESecurityCapabilities(NRUESecurityCapabilities),
    #[asn(key = 288)]
    Id_PSCellInformation(PSCellInformation),
    #[asn(key = 245)]
    Id_RRC_Resume_Cause(RRC_Establishment_Cause),
    #[asn(key = 157)]
    Id_SourceMME_GUMMEI(GUMMEI),
    #[asn(key = 88)]
    Id_SourceMME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 67)]
    Id_TAI(TAI),
    #[asn(key = 176)]
    Id_Tunnel_Information_for_BBF(TunnelInformation),
    #[asn(key = 107)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PathSwitchRequestProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for PathSwitchRequestProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: PathSwitchRequestProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(PathSwitchRequestProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                PathSwitchRequestProtocolIEs_EntryValue::Id_CSG_Id(_) => 127,
                PathSwitchRequestProtocolIEs_EntryValue::Id_CSGMembershipStatus(_) => 146,
                PathSwitchRequestProtocolIEs_EntryValue::Id_CellAccessMode(_) => 145,
                PathSwitchRequestProtocolIEs_EntryValue::Id_E_RABToBeSwitchedDLList(_) => 22,
                PathSwitchRequestProtocolIEs_EntryValue::Id_EUTRAN_CGI(_) => 100,
                PathSwitchRequestProtocolIEs_EntryValue::Id_LHN_ID(_) => 186,
                PathSwitchRequestProtocolIEs_EntryValue::Id_NRUESecurityCapabilities(_) => 269,
                PathSwitchRequestProtocolIEs_EntryValue::Id_PSCellInformation(_) => 288,
                PathSwitchRequestProtocolIEs_EntryValue::Id_RRC_Resume_Cause(_) => 245,
                PathSwitchRequestProtocolIEs_EntryValue::Id_SourceMME_GUMMEI(_) => 157,
                PathSwitchRequestProtocolIEs_EntryValue::Id_SourceMME_UE_S1AP_ID(_) => 88,
                PathSwitchRequestProtocolIEs_EntryValue::Id_TAI(_) => 67,
                PathSwitchRequestProtocolIEs_EntryValue::Id_Tunnel_Information_for_BBF(_) => 176,
                PathSwitchRequestProtocolIEs_EntryValue::Id_UESecurityCapabilities(_) => 107,
                PathSwitchRequestProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestProtocolIEs(pub Vec<PathSwitchRequestProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for PathSwitchRequestProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PathSwitchRequestProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 299)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 277)]
    Id_AerialUEsubscriptionInformation(AerialUEsubscriptionInformation),
    #[asn(key = 271)]
    Id_CE_ModeBRestricted(CE_ModeBRestricted),
    #[asn(key = 146)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 33)]
    Id_E_RABToBeReleasedList(E_RABList),
    #[asn(key = 95)]
    Id_E_RABToBeSwitchedULList(E_RABToBeSwitchedULList),
    #[asn(key = 251)]
    Id_EnhancedCoverageRestricted(EnhancedCoverageRestricted),
    #[asn(key = 41)]
    Id_HandoverRestrictionList(HandoverRestrictionList),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 158)]
    Id_MME_UE_S1AP_ID_2(MME_UE_S1AP_ID),
    #[asn(key = 269)]
    Id_NRUESecurityCapabilities(NRUESecurityCapabilities),
    #[asn(key = 307)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 306)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 308)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 283)]
    Id_PendingDataIndication(PendingDataIndication),
    #[asn(key = 195)]
    Id_ProSeAuthorized(ProSeAuthorized),
    #[asn(key = 40)]
    Id_SecurityContext(SecurityContext),
    #[asn(key = 278)]
    Id_Subscription_Based_UE_DifferentiationInfo(Subscription_Based_UE_DifferentiationInfo),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 248)]
    Id_UESidelinkAggregateMaximumBitrate(UESidelinkAggregateMaximumBitrate),
    #[asn(key = 241)]
    Id_UEUserPlaneCIoTSupportIndicator(UEUserPlaneCIoTSupportIndicator),
    #[asn(key = 240)]
    Id_V2XServicesAuthorized(V2XServicesAuthorized),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
    #[asn(key = 66)]
    Id_uEaggregateMaximumBitrate(UEAggregateMaximumBitrate),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PathSwitchRequestAcknowledgeProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for PathSwitchRequestAcknowledgeProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: PathSwitchRequestAcknowledgeProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(PathSwitchRequestAcknowledgeProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_AdditionalRRMPriorityIndex(_) => 299,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_AerialUEsubscriptionInformation(_) => 277,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_CE_ModeBRestricted(_) => 271,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_CSGMembershipStatus(_) => 146,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_E_RABToBeReleasedList(_) => 33,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_E_RABToBeSwitchedULList(_) => 95,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_EnhancedCoverageRestricted(_) => 251,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_HandoverRestrictionList(_) => 41,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID_2(_) => 158,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_NRUESecurityCapabilities(_) => 269,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_NRUESidelinkAggregateMaximumBitrate(_) => 307,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_NRV2XServicesAuthorized(_) => 306,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_PC5QoSParameters(_) => 308,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_PendingDataIndication(_) => 283,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_ProSeAuthorized(_) => 195,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_SecurityContext(_) => 40,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_Subscription_Based_UE_DifferentiationInfo(_) => 278,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_UERadioCapabilityID(_) => 314,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_UESidelinkAggregateMaximumBitrate(_) => 248,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_UEUserPlaneCIoTSupportIndicator(_) => 241,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_V2XServicesAuthorized(_) => 240,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
                PathSwitchRequestAcknowledgeProtocolIEs_EntryValue::Id_uEaggregateMaximumBitrate(_) => 66,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestAcknowledgeProtocolIEs(
    pub Vec<PathSwitchRequestAcknowledgeProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for PathSwitchRequestAcknowledgeProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PathSwitchRequestAcknowledgeProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum PathSwitchRequestFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PathSwitchRequestFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: PathSwitchRequestFailureProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for PathSwitchRequestFailureProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: PathSwitchRequestFailureProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(PathSwitchRequestFailureProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                PathSwitchRequestFailureProtocolIEs_EntryValue::Id_Cause(_) => 2,
                PathSwitchRequestFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                PathSwitchRequestFailureProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                PathSwitchRequestFailureProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct PathSwitchRequestFailureProtocolIEs(pub Vec<PathSwitchRequestFailureProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for PathSwitchRequestFailureProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PathSwitchRequestFailureProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "65535")]
pub struct PrivateIE_ID_local(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for PrivateIE_ID_local {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(PrivateIE_ID_local(u.int_in_range(0..=65535)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OBJECT-IDENTIFIER")]
pub struct PrivateIE_ID_global(Vec<u32>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct PrivateMessagePrivateIEs_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct PrivateMessagePrivateIEs(pub Vec<PrivateMessagePrivateIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for PrivateMessagePrivateIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(PrivateMessagePrivateIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum ProSeAuthorizedIE_Extensions_EntryExtensionValue {
    #[asn(key = 216)]
    Id_ProSeUEtoNetworkRelaying(ProSeUEtoNetworkRelaying),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ProSeAuthorizedIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: ProSeAuthorizedIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for ProSeAuthorizedIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: ProSeAuthorizedIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(ProSeAuthorizedIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                ProSeAuthorizedIE_Extensions_EntryExtensionValue::Id_ProSeUEtoNetworkRelaying(_) => 216,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ProSeAuthorizedIE_Extensions(pub Vec<ProSeAuthorizedIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ProSeAuthorizedIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ProSeAuthorizedIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "16",
    sz_ub = "16"
)]
pub struct RIMRoutingAddress_eHRPD_Sector_ID(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for RIMRoutingAddress_eHRPD_Sector_ID {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(16, std::cmp::min(10, u.int_in_range(16..=16)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(RIMRoutingAddress_eHRPD_Sector_ID(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RIMTransferIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RIMTransferIE_Extensions(pub Vec<RIMTransferIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for RIMTransferIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(RIMTransferIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum RLFReportInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 313)]
    Id_NB_IoT_RLF_Report_Container(NB_IoT_RLF_Report_Container),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RLFReportInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: RLFReportInformationIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for RLFReportInformationIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: RLFReportInformationIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(RLFReportInformationIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                RLFReportInformationIE_Extensions_EntryExtensionValue::Id_NB_IoT_RLF_Report_Container(_) => 313,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RLFReportInformationIE_Extensions(pub Vec<RLFReportInformationIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for RLFReportInformationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(RLFReportInformationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "4095")]
pub struct RecommendedCellItemTimeStayedInCell(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for RecommendedCellItemTimeStayedInCell {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(RecommendedCellItemTimeStayedInCell(
            u.int_in_range(0..=4095)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedCellItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedCellItemIE_Extensions(pub Vec<RecommendedCellItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for RecommendedCellItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(RecommendedCellItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum RecommendedCellList_EntryValue {
    #[asn(key = 214)]
    Id_RecommendedCellItem(RecommendedCellItem),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedCellList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RecommendedCellList_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for RecommendedCellList_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: RecommendedCellList_EntryValue = u.arbitrary()?;
        Ok(RecommendedCellList_Entry {
            id: ProtocolIE_ID(match value {
                RecommendedCellList_EntryValue::Id_RecommendedCellItem(_) => 214,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedCellsForPagingIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedCellsForPagingIE_Extensions(
    pub Vec<RecommendedCellsForPagingIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for RecommendedCellsForPagingIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(RecommendedCellsForPagingIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedENBItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedENBItemIE_Extensions(pub Vec<RecommendedENBItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for RecommendedENBItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(RecommendedENBItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum RecommendedENBList_EntryValue {
    #[asn(key = 215)]
    Id_RecommendedENBItem(RecommendedENBItem),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedENBList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RecommendedENBList_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for RecommendedENBList_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: RecommendedENBList_EntryValue = u.arbitrary()?;
        Ok(RecommendedENBList_Entry {
            id: ProtocolIE_ID(match value {
                RecommendedENBList_EntryValue::Id_RecommendedENBItem(_) => 215,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RecommendedENBsForPagingIE_Extensions_Entry {}



#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RecommendedENBsForPagingIE_Extensions(
    pub Vec<RecommendedENBsForPagingIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for RecommendedENBsForPagingIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(RecommendedENBsForPagingIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum RequestTypeIE_Extensions_EntryExtensionValue {
    #[asn(key = 298)]
    Id_RequestTypeAdditionalInfo(RequestTypeAdditionalInfo),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RequestTypeIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: RequestTypeIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for RequestTypeIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: RequestTypeIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(RequestTypeIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                RequestTypeIE_Extensions_EntryExtensionValue::Id_RequestTypeAdditionalInfo(_) => 298,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct RequestTypeIE_Extensions(pub Vec<RequestTypeIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for RequestTypeIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(RequestTypeIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum RerouteNASRequestProtocolIEs_EntryValue {
    #[asn(key = 224)]
    Id_Additional_GUTI(Additional_GUTI),
    #[asn(key = 223)]
    Id_MME_Group_ID(MME_Group_ID),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 230)]
    Id_UE_Usage_Type(UE_Usage_Type),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RerouteNASRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RerouteNASRequestProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for RerouteNASRequestProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: RerouteNASRequestProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(RerouteNASRequestProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                RerouteNASRequestProtocolIEs_EntryValue::Id_Additional_GUTI(_) => 224,
                RerouteNASRequestProtocolIEs_EntryValue::Id_MME_Group_ID(_) => 223,
                RerouteNASRequestProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                RerouteNASRequestProtocolIEs_EntryValue::Id_UE_Usage_Type(_) => 230,
                RerouteNASRequestProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RerouteNASRequestProtocolIEs(pub Vec<RerouteNASRequestProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for RerouteNASRequestProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(RerouteNASRequestProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum ResetProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 92)]
    Id_ResetType(ResetType),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResetProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ResetProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for ResetProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: ResetProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(ResetProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                ResetProtocolIEs_EntryValue::Id_Cause(_) => 2,
                ResetProtocolIEs_EntryValue::Id_ResetType(_) => 92,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ResetProtocolIEs(pub Vec<ResetProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ResetProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ResetProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum ResetAcknowledgeProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 93)]
    Id_UE_associatedLogicalS1_ConnectionListResAck(UE_associatedLogicalS1_ConnectionListResAck),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ResetAcknowledgeProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: ResetAcknowledgeProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for ResetAcknowledgeProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: ResetAcknowledgeProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(ResetAcknowledgeProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                ResetAcknowledgeProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                ResetAcknowledgeProtocolIEs_EntryValue::Id_UE_associatedLogicalS1_ConnectionListResAck(_) => 93,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct ResetAcknowledgeProtocolIEs(pub Vec<ResetAcknowledgeProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ResetAcknowledgeProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ResetAcknowledgeProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum RetrieveUEInformationProtocolIEs_EntryValue {
    #[asn(key = 96)]
    Id_S_TMSI(S_TMSI),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct RetrieveUEInformationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: RetrieveUEInformationProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for RetrieveUEInformationProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: RetrieveUEInformationProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(RetrieveUEInformationProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                RetrieveUEInformationProtocolIEs_EntryValue::Id_S_TMSI(_) => 96,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct RetrieveUEInformationProtocolIEs(pub Vec<RetrieveUEInformationProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for RetrieveUEInformationProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(RetrieveUEInformationProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct S_TMSIIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct S_TMSIIE_Extensions(pub Vec<S_TMSIIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for S_TMSIIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(S_TMSIIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum S1SetupFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 65)]
    Id_TimeToWait(TimeToWait),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct S1SetupFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: S1SetupFailureProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for S1SetupFailureProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: S1SetupFailureProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(S1SetupFailureProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                S1SetupFailureProtocolIEs_EntryValue::Id_Cause(_) => 2,
                S1SetupFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                S1SetupFailureProtocolIEs_EntryValue::Id_TimeToWait(_) => 65,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct S1SetupFailureProtocolIEs(pub Vec<S1SetupFailureProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for S1SetupFailureProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(S1SetupFailureProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum S1SetupRequestProtocolIEs_EntryValue {
    #[asn(key = 128)]
    Id_CSG_IdList(CSG_IdList),
    #[asn(key = 291)]
    Id_ConnectedengNBList(ConnectedengNBList),
    #[asn(key = 137)]
    Id_DefaultPagingDRX(PagingDRX),
    #[asn(key = 59)]
    Id_Global_ENB_ID(Global_ENB_ID),
    #[asn(key = 234)]
    Id_NB_IoT_DefaultPagingDRX(NB_IoT_DefaultPagingDRX),
    #[asn(key = 64)]
    Id_SupportedTAs(SupportedTAs),
    #[asn(key = 228)]
    Id_UE_RetentionInformation(UE_RetentionInformation),
    #[asn(key = 60)]
    Id_eNBname(ENBname),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct S1SetupRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: S1SetupRequestProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for S1SetupRequestProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: S1SetupRequestProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(S1SetupRequestProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                S1SetupRequestProtocolIEs_EntryValue::Id_CSG_IdList(_) => 128,
                S1SetupRequestProtocolIEs_EntryValue::Id_ConnectedengNBList(_) => 291,
                S1SetupRequestProtocolIEs_EntryValue::Id_DefaultPagingDRX(_) => 137,
                S1SetupRequestProtocolIEs_EntryValue::Id_Global_ENB_ID(_) => 59,
                S1SetupRequestProtocolIEs_EntryValue::Id_NB_IoT_DefaultPagingDRX(_) => 234,
                S1SetupRequestProtocolIEs_EntryValue::Id_SupportedTAs(_) => 64,
                S1SetupRequestProtocolIEs_EntryValue::Id_UE_RetentionInformation(_) => 228,
                S1SetupRequestProtocolIEs_EntryValue::Id_eNBname(_) => 60,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct S1SetupRequestProtocolIEs(pub Vec<S1SetupRequestProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for S1SetupRequestProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(S1SetupRequestProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum S1SetupResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 303)]
    Id_IAB_Supported(IAB_Supported),
    #[asn(key = 163)]
    Id_MMERelaySupportIndicator(MMERelaySupportIndicator),
    #[asn(key = 61)]
    Id_MMEname(MMEname),
    #[asn(key = 87)]
    Id_RelativeMMECapacity(RelativeMMECapacity),
    #[asn(key = 247)]
    Id_ServedDCNs(ServedDCNs),
    #[asn(key = 105)]
    Id_ServedGUMMEIs(ServedGUMMEIs),
    #[asn(key = 228)]
    Id_UE_RetentionInformation(UE_RetentionInformation),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct S1SetupResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: S1SetupResponseProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for S1SetupResponseProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: S1SetupResponseProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(S1SetupResponseProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                S1SetupResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                S1SetupResponseProtocolIEs_EntryValue::Id_IAB_Supported(_) => 303,
                S1SetupResponseProtocolIEs_EntryValue::Id_MMERelaySupportIndicator(_) => 163,
                S1SetupResponseProtocolIEs_EntryValue::Id_MMEname(_) => 61,
                S1SetupResponseProtocolIEs_EntryValue::Id_RelativeMMECapacity(_) => 87,
                S1SetupResponseProtocolIEs_EntryValue::Id_ServedDCNs(_) => 247,
                S1SetupResponseProtocolIEs_EntryValue::Id_ServedGUMMEIs(_) => 105,
                S1SetupResponseProtocolIEs_EntryValue::Id_UE_RetentionInformation(_) => 228,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct S1SetupResponseProtocolIEs(pub Vec<S1SetupResponseProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for S1SetupResponseProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(S1SetupResponseProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum SONConfigurationTransferIE_Extensions_EntryExtensionValue {
    #[asn(key = 209)]
    Id_Synchronisation_Information(SynchronisationInformation),
    #[asn(key = 152)]
    Id_x2TNLConfigurationInfo(X2TNLConfigurationInfo),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SONConfigurationTransferIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: SONConfigurationTransferIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for SONConfigurationTransferIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: SONConfigurationTransferIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(SONConfigurationTransferIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                SONConfigurationTransferIE_Extensions_EntryExtensionValue::Id_Synchronisation_Information(_) => 209,
                SONConfigurationTransferIE_Extensions_EntryExtensionValue::Id_x2TNLConfigurationInfo(_) => 152,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SONConfigurationTransferIE_Extensions(
    pub Vec<SONConfigurationTransferIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for SONConfigurationTransferIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(SONConfigurationTransferIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum SONInformation_ExtensionValue {
    #[asn(key = 206)]
    Id_SON_Information_Report(SONInformationReport),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum SONInformationReplyIE_Extensions_EntryExtensionValue {
    #[asn(key = 208)]
    Id_Muting_Pattern_Information(MutingPatternInformation),
    #[asn(key = 149)]
    Id_Time_Synchronisation_Info(TimeSynchronisationInfo),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SONInformationReplyIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: SONInformationReplyIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for SONInformationReplyIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: SONInformationReplyIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(SONInformationReplyIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                SONInformationReplyIE_Extensions_EntryExtensionValue::Id_Muting_Pattern_Information(_) => 208,
                SONInformationReplyIE_Extensions_EntryExtensionValue::Id_Time_Synchronisation_Info(_) => 149,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SONInformationReplyIE_Extensions(pub Vec<SONInformationReplyIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for SONInformationReplyIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(SONInformationReplyIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "NULL")]
pub struct SONtransferRequestContainer_cellLoadReporting;

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "NULL")]
pub struct SONtransferResponseContainer_hOReporting;

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "NULL")]
pub struct SONtransferResponseContainer_energySavingsIndication;

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "NULL")]
pub struct SONtransferResponseContainer_failureEventReporting;

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "BITSTRING", sz_extensible = false, sz_lb = "7", sz_ub = "7")]
pub struct ScheduledCommunicationTimeDayofWeek(pub bitvec::vec::BitVec<u8, bitvec::order::Msb0>);
impl<'a> arbitrary::Arbitrary<'a> for ScheduledCommunicationTimeDayofWeek {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut bv = bitvec::vec::BitVec::EMPTY;
        for _ in 0..7 {
            bv.push(u.arbitrary()?);
        }
        if 7 > 7 {
            for _ in 0..u.int_in_range(0..=7 - 7 - 1)? {
                bv.push(u.arbitrary()?);
            }
        }
        Ok(ScheduledCommunicationTimeDayofWeek(bv))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "86399", extensible = true)]
pub struct ScheduledCommunicationTimeTimeofDayStart(pub u32);
impl<'a> arbitrary::Arbitrary<'a> for ScheduledCommunicationTimeTimeofDayStart {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ScheduledCommunicationTimeTimeofDayStart(
            u.int_in_range(0..=86399)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "86399", extensible = true)]
pub struct ScheduledCommunicationTimeTimeofDayEnd(pub u32);
impl<'a> arbitrary::Arbitrary<'a> for ScheduledCommunicationTimeTimeofDayEnd {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(ScheduledCommunicationTimeTimeofDayEnd(
            u.int_in_range(0..=86399)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ScheduledCommunicationTimeIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ScheduledCommunicationTimeIE_Extensions(
    pub Vec<ScheduledCommunicationTimeIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for ScheduledCommunicationTimeIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ScheduledCommunicationTimeIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum SecondaryRATDataUsageReportProtocolIEs_EntryValue {
    #[asn(key = 266)]
    Id_HandoverFlag(HandoverFlag),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 297)]
    Id_TimeSinceSecondaryNodeRelease(TimeSinceSecondaryNodeRelease),
    #[asn(key = 189)]
    Id_UserLocationInformation(UserLocationInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecondaryRATDataUsageReportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SecondaryRATDataUsageReportProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for SecondaryRATDataUsageReportProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: SecondaryRATDataUsageReportProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(SecondaryRATDataUsageReportProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_HandoverFlag(_) => 266,
                SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_SecondaryRATDataUsageReportList(_) => 264,
                SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_TimeSinceSecondaryNodeRelease(_) => 297,
                SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_UserLocationInformation(_) => 189,
                SecondaryRATDataUsageReportProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct SecondaryRATDataUsageReportProtocolIEs(
    pub Vec<SecondaryRATDataUsageReportProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for SecondaryRATDataUsageReportProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(SecondaryRATDataUsageReportProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecondaryRATDataUsageReportItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecondaryRATDataUsageReportItemIE_Extensions(
    pub Vec<SecondaryRATDataUsageReportItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for SecondaryRATDataUsageReportItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(SecondaryRATDataUsageReportItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum SecondaryRATDataUsageReportList_EntryValue {
    #[asn(key = 265)]
    Id_SecondaryRATDataUsageReportItem(SecondaryRATDataUsageReportItem),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecondaryRATDataUsageReportList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: SecondaryRATDataUsageReportList_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for SecondaryRATDataUsageReportList_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: SecondaryRATDataUsageReportList_EntryValue = u.arbitrary()?;
        Ok(SecondaryRATDataUsageReportList_Entry {
            id: ProtocolIE_ID(match value {
                SecondaryRATDataUsageReportList_EntryValue::Id_SecondaryRATDataUsageReportItem(_) => 265,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "0", ub = "7")]
pub struct SecurityContextNextHopChainingCount(pub u8);
impl<'a> arbitrary::Arbitrary<'a> for SecurityContextNextHopChainingCount {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(SecurityContextNextHopChainingCount(u.int_in_range(0..=7)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SecurityContextIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SecurityContextIE_Extensions(pub Vec<SecurityContextIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for SecurityContextIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(SecurityContextIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedDCNsItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedDCNsItemIE_Extensions(pub Vec<ServedDCNsItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ServedDCNsItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ServedDCNsItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum ServedGUMMEIsItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 170)]
    Id_GUMMEIType(GUMMEIType),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct ServedGUMMEIsItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: ServedGUMMEIsItemIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for ServedGUMMEIsItemIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: ServedGUMMEIsItemIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(ServedGUMMEIsItemIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                ServedGUMMEIsItemIE_Extensions_EntryExtensionValue::Id_GUMMEIType(_) => 170,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct ServedGUMMEIsItemIE_Extensions(pub Vec<ServedGUMMEIsItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for ServedGUMMEIsItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(ServedGUMMEIsItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SourceNgRanNode_IDIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SourceNgRanNode_IDIE_Extensions(pub Vec<SourceNgRanNode_IDIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for SourceNgRanNode_IDIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(SourceNgRanNode_IDIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SourceeNB_IDIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SourceeNB_IDIE_Extensions(pub Vec<SourceeNB_IDIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for SourceeNB_IDIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(SourceeNB_IDIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_EntryExtensionValue {
    #[asn(key = 299)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 300)]
    Id_ContextatSource(ContextatSource),
    #[asn(key = 326)]
    Id_EmergencyIndicator(EmergencyIndicator),
    #[asn(key = 296)]
    Id_IMSvoiceEPSfallbackfrom5G(IMSvoiceEPSfallbackfrom5G),
    #[asn(key = 311)]
    Id_IntersystemMeasurementConfiguration(IntersystemMeasurementConfiguration),
    #[asn(key = 175)]
    Id_MobilityInformation(MobilityInformation),
    #[asn(key = 312)]
    Id_SourceNodeID(SourceNodeID),
    #[asn(key = 194)]
    Id_uE_HistoryInformationFromTheUE(UE_HistoryInformationFromTheUE),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value:
        SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_EntryExtensionValue::Id_AdditionalRRMPriorityIndex(_) => 299, 
                SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_EntryExtensionValue::Id_ContextatSource(_) => 300,
                SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_EntryExtensionValue::Id_EmergencyIndicator(_) => 326,
                SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_EntryExtensionValue::Id_IMSvoiceEPSfallbackfrom5G(_) => 296,
                SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_EntryExtensionValue::Id_IntersystemMeasurementConfiguration(_) => 311,
                SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_EntryExtensionValue::Id_MobilityInformation(_) => 175,
                SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_EntryExtensionValue::Id_SourceNodeID(_) => 312,
                SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_EntryExtensionValue::Id_uE_HistoryInformationFromTheUE(_) => 194,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions(
    pub Vec<SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(SourceeNB_ToTargeteNB_TransparentContainerIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Subscription_Based_UE_DifferentiationInfoPeriodicCommunicationIndicator(pub u8);
impl Subscription_Based_UE_DifferentiationInfoPeriodicCommunicationIndicator {
    pub const PERIODICALLY: u8 = 0u8;
    pub const ONDEMAND: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a>
    for Subscription_Based_UE_DifferentiationInfoPeriodicCommunicationIndicator
{
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(
            Subscription_Based_UE_DifferentiationInfoPeriodicCommunicationIndicator(
                u.int_in_range(0..=1)?,
            ),
        )
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "INTEGER", lb = "1", ub = "3600", extensible = true)]
pub struct Subscription_Based_UE_DifferentiationInfoPeriodicTime(pub u16);
impl<'a> arbitrary::Arbitrary<'a> for Subscription_Based_UE_DifferentiationInfoPeriodicTime {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Subscription_Based_UE_DifferentiationInfoPeriodicTime(
            u.int_in_range(1..=3600)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "1")]
pub struct Subscription_Based_UE_DifferentiationInfoStationaryIndication(pub u8);
impl Subscription_Based_UE_DifferentiationInfoStationaryIndication {
    pub const STATIONARY: u8 = 0u8;
    pub const MOBILE: u8 = 1u8;
}
impl<'a> arbitrary::Arbitrary<'a>
    for Subscription_Based_UE_DifferentiationInfoStationaryIndication
{
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Subscription_Based_UE_DifferentiationInfoStationaryIndication(u.int_in_range(0..=1)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct Subscription_Based_UE_DifferentiationInfoTrafficProfile(pub u8);
impl Subscription_Based_UE_DifferentiationInfoTrafficProfile {
    pub const SINGLE_PACKET: u8 = 0u8;
    pub const DUAL_PACKETS: u8 = 1u8;
    pub const MULTIPLE_PACKETS: u8 = 2u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Subscription_Based_UE_DifferentiationInfoTrafficProfile {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Subscription_Based_UE_DifferentiationInfoTrafficProfile(
            u.int_in_range(0..=2)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "2")]
pub struct Subscription_Based_UE_DifferentiationInfoBatteryIndication(pub u8);
impl Subscription_Based_UE_DifferentiationInfoBatteryIndication {
    pub const BATTERY_POWERED: u8 = 0u8;
    pub const BATTERY_POWERED_NOT_RECHARGEABLE_OR_REPLACEABLE: u8 = 1u8;
    pub const NOT_BATTERY_POWERED: u8 = 2u8;
}
impl<'a> arbitrary::Arbitrary<'a> for Subscription_Based_UE_DifferentiationInfoBatteryIndication {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(Subscription_Based_UE_DifferentiationInfoBatteryIndication(
            u.int_in_range(0..=2)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct Subscription_Based_UE_DifferentiationInfoIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct Subscription_Based_UE_DifferentiationInfoIE_Extensions(
    pub Vec<Subscription_Based_UE_DifferentiationInfoIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for Subscription_Based_UE_DifferentiationInfoIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(Subscription_Based_UE_DifferentiationInfoIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum SuccessfulOutcomeValue {
    #[asn(key = 50)]
    Id_E_RABModificationIndication(E_RABModificationConfirm),
    #[asn(key = 6)]
    Id_E_RABModify(E_RABModifyResponse),
    #[asn(key = 7)]
    Id_E_RABRelease(E_RABReleaseResponse),
    #[asn(key = 5)]
    Id_E_RABSetup(E_RABSetupResponse),
    #[asn(key = 29)]
    Id_ENBConfigurationUpdate(ENBConfigurationUpdateAcknowledge),
    #[asn(key = 4)]
    Id_HandoverCancel(HandoverCancelAcknowledge),
    #[asn(key = 0)]
    Id_HandoverPreparation(HandoverCommand),
    #[asn(key = 1)]
    Id_HandoverResourceAllocation(HandoverRequestAcknowledge),
    #[asn(key = 9)]
    Id_InitialContextSetup(InitialContextSetupResponse),
    #[asn(key = 43)]
    Id_Kill(KillResponse),
    #[asn(key = 30)]
    Id_MMEConfigurationUpdate(MMEConfigurationUpdateAcknowledge),
    #[asn(key = 3)]
    Id_PathSwitchRequest(PathSwitchRequestAcknowledge),
    #[asn(key = 14)]
    Id_Reset(ResetAcknowledge),
    #[asn(key = 17)]
    Id_S1Setup(S1SetupResponse),
    #[asn(key = 21)]
    Id_UEContextModification(UEContextModificationResponse),
    #[asn(key = 53)]
    Id_UEContextModificationIndication(UEContextModificationConfirm),
    #[asn(key = 23)]
    Id_UEContextRelease(UEContextReleaseComplete),
    #[asn(key = 56)]
    Id_UEContextResume(UEContextResumeResponse),
    #[asn(key = 55)]
    Id_UEContextSuspend(UEContextSuspendResponse),
    #[asn(key = 63)]
    Id_UERadioCapabilityIDMapping(UERadioCapabilityIDMappingResponse),
    #[asn(key = 48)]
    Id_UERadioCapabilityMatch(UERadioCapabilityMatchResponse),
    #[asn(key = 36)]
    Id_WriteReplaceWarning(WriteReplaceWarningResponse),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum SupportedTAs_ItemIE_Extensions_EntryExtensionValue {
    #[asn(key = 232)]
    Id_RAT_Type(RAT_Type),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SupportedTAs_ItemIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: SupportedTAs_ItemIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for SupportedTAs_ItemIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: SupportedTAs_ItemIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(SupportedTAs_ItemIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                SupportedTAs_ItemIE_Extensions_EntryExtensionValue::Id_RAT_Type(_) => 232,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SupportedTAs_ItemIE_Extensions(pub Vec<SupportedTAs_ItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for SupportedTAs_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(SupportedTAs_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct SynchronisationInformationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct SynchronisationInformationIE_Extensions(
    pub Vec<SynchronisationInformationIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for SynchronisationInformationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(SynchronisationInformationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TABasedMDTIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TABasedMDTIE_Extensions(pub Vec<TABasedMDTIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TABasedMDTIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TABasedMDTIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TABasedQMCIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TABasedQMCIE_Extensions(pub Vec<TABasedQMCIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TABasedQMCIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TABasedQMCIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIIE_Extensions(pub Vec<TAIIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TAIIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TAIIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAI_Broadcast_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAI_Broadcast_ItemIE_Extensions(pub Vec<TAI_Broadcast_ItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TAI_Broadcast_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TAI_Broadcast_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAI_Cancelled_ItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAI_Cancelled_ItemIE_Extensions(pub Vec<TAI_Cancelled_ItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TAI_Cancelled_ItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TAI_Cancelled_ItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIBasedMDTIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBasedMDTIE_Extensions(pub Vec<TAIBasedMDTIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TAIBasedMDTIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TAIBasedMDTIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIBasedQMCIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIBasedQMCIE_Extensions(pub Vec<TAIBasedQMCIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TAIBasedQMCIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TAIBasedQMCIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TAIItemIE_Extensions(pub Vec<TAIItemIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TAIItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TAIItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum TAIList_EntryValue {
    #[asn(key = 47)]
    Id_TAIItem(TAIItem),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TAIList_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: TAIList_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for TAIList_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: TAIList_EntryValue = u.arbitrary()?;
        Ok(TAIList_Entry {
            id: ProtocolIE_ID(match value {
                TAIList_EntryValue::Id_TAIItem(_) => 47,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargetNgRanNode_IDIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargetNgRanNode_IDIE_Extensions(pub Vec<TargetNgRanNode_IDIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TargetNgRanNode_IDIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TargetNgRanNode_IDIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargetRNC_IDIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargetRNC_IDIE_Extensions(pub Vec<TargetRNC_IDIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TargetRNC_IDIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TargetRNC_IDIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargeteNB_IDIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargeteNB_IDIE_Extensions(pub Vec<TargeteNB_IDIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TargeteNB_IDIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TargeteNB_IDIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_EntryExtensionValue {
    #[asn(key = 318)]
    Id_DAPSResponseInfoList(DAPSResponseInfoList),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value:
        TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_EntryExtensionValue::Id_DAPSResponseInfoList(_) => 318,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions(
    pub Vec<TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TargeteNB_ToSourceeNB_TransparentContainerIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum TimeSynchronisationInfoIE_Extensions_EntryExtensionValue {
    #[asn(key = 207)]
    Id_Muting_Availability_Indication(MutingAvailabilityIndication),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TimeSynchronisationInfoIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: TimeSynchronisationInfoIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for TimeSynchronisationInfoIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: TimeSynchronisationInfoIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(TimeSynchronisationInfoIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                TimeSynchronisationInfoIE_Extensions_EntryExtensionValue::Id_Muting_Availability_Indication(_) => 207,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TimeSynchronisationInfoIE_Extensions(
    pub Vec<TimeSynchronisationInfoIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for TimeSynchronisationInfoIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TimeSynchronisationInfoIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OCTET-STRING")]
pub struct TooEarlyInterRATHOReportReportFromEUTRANUERLFReportContainer(pub Vec<u8>);

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum TraceActivationIE_Extensions_EntryExtensionValue {
    #[asn(key = 162)]
    Id_MDTConfiguration(MDT_Configuration),
    #[asn(key = 316)]
    Id_MDTConfigurationNR(MDT_ConfigurationNR),
    #[asn(key = 325)]
    Id_TraceCollectionEntityURI(URI_Address),
    #[asn(key = 262)]
    Id_UEAppLayerMeasConfig(UEAppLayerMeasConfig),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TraceActivationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: TraceActivationIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for TraceActivationIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: TraceActivationIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(TraceActivationIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                TraceActivationIE_Extensions_EntryExtensionValue::Id_MDTConfiguration(_) => 162,
                TraceActivationIE_Extensions_EntryExtensionValue::Id_MDTConfigurationNR(_) => 316,
                TraceActivationIE_Extensions_EntryExtensionValue::Id_TraceCollectionEntityURI(_) => 325,
                TraceActivationIE_Extensions_EntryExtensionValue::Id_UEAppLayerMeasConfig(_) => 262,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TraceActivationIE_Extensions(pub Vec<TraceActivationIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TraceActivationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TraceActivationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum TraceFailureIndicationProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 86)]
    Id_E_UTRAN_Trace_ID(E_UTRAN_Trace_ID),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TraceFailureIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: TraceFailureIndicationProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for TraceFailureIndicationProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: TraceFailureIndicationProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(TraceFailureIndicationProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                TraceFailureIndicationProtocolIEs_EntryValue::Id_Cause(_) => 2,
                TraceFailureIndicationProtocolIEs_EntryValue::Id_E_UTRAN_Trace_ID(_) => 86,
                TraceFailureIndicationProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                TraceFailureIndicationProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct TraceFailureIndicationProtocolIEs(pub Vec<TraceFailureIndicationProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TraceFailureIndicationProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TraceFailureIndicationProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum TraceStartProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 25)]
    Id_TraceActivation(TraceActivation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TraceStartProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: TraceStartProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for TraceStartProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: TraceStartProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(TraceStartProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                TraceStartProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                TraceStartProtocolIEs_EntryValue::Id_TraceActivation(_) => 25,
                TraceStartProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct TraceStartProtocolIEs(pub Vec<TraceStartProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TraceStartProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TraceStartProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct TunnelInformationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct TunnelInformationIE_Extensions(pub Vec<TunnelInformationIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for TunnelInformationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(TunnelInformationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_S1AP_ID_pairIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_S1AP_ID_pairIE_Extensions(pub Vec<UE_S1AP_ID_pairIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for UE_S1AP_ID_pairIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UE_S1AP_ID_pairIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_associatedLogicalS1_ConnectionItemIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UE_associatedLogicalS1_ConnectionItemIE_Extensions(
    pub Vec<UE_associatedLogicalS1_ConnectionItemIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UE_associatedLogicalS1_ConnectionItemIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UE_associatedLogicalS1_ConnectionItemIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UE_associatedLogicalS1_ConnectionListRes_EntryValue {
    #[asn(key = 91)]
    Id_UE_associatedLogicalS1_ConnectionItem(UE_associatedLogicalS1_ConnectionItem),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_associatedLogicalS1_ConnectionListRes_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UE_associatedLogicalS1_ConnectionListRes_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UE_associatedLogicalS1_ConnectionListRes_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UE_associatedLogicalS1_ConnectionListRes_EntryValue = u.arbitrary()?;
        Ok(UE_associatedLogicalS1_ConnectionListRes_Entry {
            id: ProtocolIE_ID(match value {
                UE_associatedLogicalS1_ConnectionListRes_EntryValue::Id_UE_associatedLogicalS1_ConnectionItem(_) => 91,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UE_associatedLogicalS1_ConnectionListResAck_EntryValue {
    #[asn(key = 91)]
    Id_UE_associatedLogicalS1_ConnectionItem(UE_associatedLogicalS1_ConnectionItem),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UE_associatedLogicalS1_ConnectionListResAck_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UE_associatedLogicalS1_ConnectionListResAck_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UE_associatedLogicalS1_ConnectionListResAck_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UE_associatedLogicalS1_ConnectionListResAck_EntryValue = u.arbitrary()?;
        Ok(UE_associatedLogicalS1_ConnectionListResAck_Entry {
            id: ProtocolIE_ID(match value {
                UE_associatedLogicalS1_ConnectionListResAck_EntryValue::Id_UE_associatedLogicalS1_ConnectionItem(_) => 91,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEAggregateMaximumBitrateIE_Extensions_EntryExtensionValue {
    #[asn(key = 259)]
    Id_extended_uEaggregateMaximumBitRateDL(ExtendedBitRate),
    #[asn(key = 260)]
    Id_extended_uEaggregateMaximumBitRateUL(ExtendedBitRate),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEAggregateMaximumBitrateIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: UEAggregateMaximumBitrateIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEAggregateMaximumBitrateIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: UEAggregateMaximumBitrateIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(UEAggregateMaximumBitrateIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                UEAggregateMaximumBitrateIE_Extensions_EntryExtensionValue::Id_extended_uEaggregateMaximumBitRateDL(_) => 259,
                UEAggregateMaximumBitrateIE_Extensions_EntryExtensionValue::Id_extended_uEaggregateMaximumBitRateUL(_) => 260,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEAggregateMaximumBitrateIE_Extensions(
    pub Vec<UEAggregateMaximumBitrateIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UEAggregateMaximumBitrateIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEAggregateMaximumBitrateIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "OCTET-STRING",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "1000"
)]
pub struct UEAppLayerMeasConfigContainerForAppLayerMeasConfig(pub Vec<u8>);
impl<'a> arbitrary::Arbitrary<'a> for UEAppLayerMeasConfigContainerForAppLayerMeasConfig {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=1)?));
        let mut v = Vec::new();
        v.extend_from_slice(u.bytes(vec_length)?);
        Ok(UEAppLayerMeasConfigContainerForAppLayerMeasConfig(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEAppLayerMeasConfigIE_Extensions_EntryExtensionValue {
    #[asn(key = 276)]
    Id_serviceType(ServiceType),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEAppLayerMeasConfigIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: UEAppLayerMeasConfigIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEAppLayerMeasConfigIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: UEAppLayerMeasConfigIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(UEAppLayerMeasConfigIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                UEAppLayerMeasConfigIE_Extensions_EntryExtensionValue::Id_serviceType(_) => 276,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UEAppLayerMeasConfigIE_Extensions(pub Vec<UEAppLayerMeasConfigIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for UEAppLayerMeasConfigIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEAppLayerMeasConfigIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UECapabilityInfoIndicationProtocolIEs_EntryValue {
    #[asn(key = 272)]
    Id_LTE_M_Indication(LTE_M_Indication),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 263)]
    Id_UE_Application_Layer_Measurement_Capability(UE_Application_Layer_Measurement_Capability),
    #[asn(key = 74)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 315)]
    Id_UERadioCapability_NR_Format(UERadioCapability),
    #[asn(key = 198)]
    Id_UERadioCapabilityForPaging(UERadioCapabilityForPaging),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UECapabilityInfoIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UECapabilityInfoIndicationProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UECapabilityInfoIndicationProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UECapabilityInfoIndicationProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UECapabilityInfoIndicationProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UECapabilityInfoIndicationProtocolIEs_EntryValue::Id_LTE_M_Indication(_) => 272,
                UECapabilityInfoIndicationProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UECapabilityInfoIndicationProtocolIEs_EntryValue::Id_UE_Application_Layer_Measurement_Capability(_) => 263,
                UECapabilityInfoIndicationProtocolIEs_EntryValue::Id_UERadioCapability(_) => 74,
                UECapabilityInfoIndicationProtocolIEs_EntryValue::Id_UERadioCapability_NR_Format(_) => 315,
                UECapabilityInfoIndicationProtocolIEs_EntryValue::Id_UERadioCapabilityForPaging(_) => 198,
                UECapabilityInfoIndicationProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UECapabilityInfoIndicationProtocolIEs(
    pub Vec<UECapabilityInfoIndicationProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UECapabilityInfoIndicationProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UECapabilityInfoIndicationProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEContextModificationConfirmProtocolIEs_EntryValue {
    #[asn(key = 146)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationConfirmProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationConfirmProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEContextModificationConfirmProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UEContextModificationConfirmProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UEContextModificationConfirmProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UEContextModificationConfirmProtocolIEs_EntryValue::Id_CSGMembershipStatus(_) => 146,
                UEContextModificationConfirmProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                UEContextModificationConfirmProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UEContextModificationConfirmProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationConfirmProtocolIEs(
    pub Vec<UEContextModificationConfirmProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UEContextModificationConfirmProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEContextModificationConfirmProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEContextModificationFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationFailureProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEContextModificationFailureProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UEContextModificationFailureProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UEContextModificationFailureProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UEContextModificationFailureProtocolIEs_EntryValue::Id_Cause(_) => 2,
                UEContextModificationFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                UEContextModificationFailureProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UEContextModificationFailureProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationFailureProtocolIEs(
    pub Vec<UEContextModificationFailureProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UEContextModificationFailureProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEContextModificationFailureProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEContextModificationIndicationProtocolIEs_EntryValue {
    #[asn(key = 226)]
    Id_CSGMembershipInfo(CSGMembershipInfo),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationIndicationProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationIndicationProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEContextModificationIndicationProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UEContextModificationIndicationProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UEContextModificationIndicationProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UEContextModificationIndicationProtocolIEs_EntryValue::Id_CSGMembershipInfo(_) => 226,
                UEContextModificationIndicationProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UEContextModificationIndicationProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationIndicationProtocolIEs(
    pub Vec<UEContextModificationIndicationProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UEContextModificationIndicationProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEContextModificationIndicationProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEContextModificationRequestProtocolIEs_EntryValue {
    #[asn(key = 187)]
    Id_AdditionalCSFallbackIndicator(AdditionalCSFallbackIndicator),
    #[asn(key = 299)]
    Id_AdditionalRRMPriorityIndex(AdditionalRRMPriorityIndex),
    #[asn(key = 277)]
    Id_AerialUEsubscriptionInformation(AerialUEsubscriptionInformation),
    #[asn(key = 108)]
    Id_CSFallbackIndicator(CSFallbackIndicator),
    #[asn(key = 146)]
    Id_CSGMembershipStatus(CSGMembershipStatus),
    #[asn(key = 301)]
    Id_IAB_Authorized(IAB_Authorized),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 269)]
    Id_NRUESecurityCapabilities(NRUESecurityCapabilities),
    #[asn(key = 307)]
    Id_NRUESidelinkAggregateMaximumBitrate(NRUESidelinkAggregateMaximumBitrate),
    #[asn(key = 306)]
    Id_NRV2XServicesAuthorized(NRV2XServicesAuthorized),
    #[asn(key = 308)]
    Id_PC5QoSParameters(PC5QoSParameters),
    #[asn(key = 195)]
    Id_ProSeAuthorized(ProSeAuthorized),
    #[asn(key = 159)]
    Id_RegisteredLAI(LAI),
    #[asn(key = 243)]
    Id_SRVCCOperationNotPossible(SRVCCOperationNotPossible),
    #[asn(key = 124)]
    Id_SRVCCOperationPossible(SRVCCOperationPossible),
    #[asn(key = 73)]
    Id_SecurityKey(SecurityKey),
    #[asn(key = 106)]
    Id_SubscriberProfileIDforRFP(SubscriberProfileIDforRFP),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 107)]
    Id_UESecurityCapabilities(UESecurityCapabilities),
    #[asn(key = 248)]
    Id_UESidelinkAggregateMaximumBitrate(UESidelinkAggregateMaximumBitrate),
    #[asn(key = 240)]
    Id_V2XServicesAuthorized(V2XServicesAuthorized),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
    #[asn(key = 66)]
    Id_uEaggregateMaximumBitrate(UEAggregateMaximumBitrate),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationRequestProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEContextModificationRequestProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UEContextModificationRequestProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UEContextModificationRequestProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UEContextModificationRequestProtocolIEs_EntryValue::Id_AdditionalCSFallbackIndicator(_) => 187,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_AdditionalRRMPriorityIndex(_) => 299,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_AerialUEsubscriptionInformation(_) => 277,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_CSFallbackIndicator(_) => 108,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_CSGMembershipStatus(_) => 146,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_IAB_Authorized(_) => 301,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_NRUESecurityCapabilities(_) => 269,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_NRUESidelinkAggregateMaximumBitrate(_) => 307,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_NRV2XServicesAuthorized(_) => 306,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_PC5QoSParameters(_) => 308,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_ProSeAuthorized(_) => 195,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_RegisteredLAI(_) => 159,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_SRVCCOperationNotPossible(_) => 243,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_SRVCCOperationPossible(_) => 124,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_SecurityKey(_) => 73,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_SubscriberProfileIDforRFP(_) => 106,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_UERadioCapabilityID(_) => 314,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_UESecurityCapabilities(_) => 107,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_UESidelinkAggregateMaximumBitrate(_) => 248,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_V2XServicesAuthorized(_) => 240,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
                UEContextModificationRequestProtocolIEs_EntryValue::Id_uEaggregateMaximumBitrate(_) => 66,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationRequestProtocolIEs(
    pub Vec<UEContextModificationRequestProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UEContextModificationRequestProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEContextModificationRequestProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEContextModificationResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextModificationResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextModificationResponseProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEContextModificationResponseProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UEContextModificationResponseProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UEContextModificationResponseProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UEContextModificationResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                UEContextModificationResponseProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UEContextModificationResponseProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextModificationResponseProtocolIEs(
    pub Vec<UEContextModificationResponseProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UEContextModificationResponseProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEContextModificationResponseProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEContextReleaseCommandProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 99)]
    Id_UE_S1AP_IDs(UE_S1AP_IDs),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextReleaseCommandProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextReleaseCommandProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEContextReleaseCommandProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UEContextReleaseCommandProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UEContextReleaseCommandProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UEContextReleaseCommandProtocolIEs_EntryValue::Id_Cause(_) => 2,
                UEContextReleaseCommandProtocolIEs_EntryValue::Id_UE_S1AP_IDs(_) => 99,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextReleaseCommandProtocolIEs(pub Vec<UEContextReleaseCommandProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for UEContextReleaseCommandProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEContextReleaseCommandProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEContextReleaseCompleteProtocolIEs_EntryValue {
    #[asn(key = 212)]
    Id_CellIdentifierAndCELevelForCECapableUEs(CellIdentifierAndCELevelForCECapableUEs),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 213)]
    Id_InformationOnRecommendedCellsAndENBsForPaging(InformationOnRecommendedCellsAndENBsForPaging),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 297)]
    Id_TimeSinceSecondaryNodeRelease(TimeSinceSecondaryNodeRelease),
    #[asn(key = 189)]
    Id_UserLocationInformation(UserLocationInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextReleaseCompleteProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextReleaseCompleteProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEContextReleaseCompleteProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UEContextReleaseCompleteProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UEContextReleaseCompleteProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UEContextReleaseCompleteProtocolIEs_EntryValue::Id_CellIdentifierAndCELevelForCECapableUEs(_) => 212,
                UEContextReleaseCompleteProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                UEContextReleaseCompleteProtocolIEs_EntryValue::Id_InformationOnRecommendedCellsAndENBsForPaging(_) => 213,
                UEContextReleaseCompleteProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UEContextReleaseCompleteProtocolIEs_EntryValue::Id_SecondaryRATDataUsageReportList(_) => 264,
                UEContextReleaseCompleteProtocolIEs_EntryValue::Id_TimeSinceSecondaryNodeRelease(_) => 297,
                UEContextReleaseCompleteProtocolIEs_EntryValue::Id_UserLocationInformation(_) => 189,
                UEContextReleaseCompleteProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextReleaseCompleteProtocolIEs(pub Vec<UEContextReleaseCompleteProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for UEContextReleaseCompleteProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEContextReleaseCompleteProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEContextReleaseRequestProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 164)]
    Id_GWContextReleaseIndication(GWContextReleaseIndication),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextReleaseRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextReleaseRequestProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEContextReleaseRequestProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UEContextReleaseRequestProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UEContextReleaseRequestProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UEContextReleaseRequestProtocolIEs_EntryValue::Id_Cause(_) => 2,
                UEContextReleaseRequestProtocolIEs_EntryValue::Id_GWContextReleaseIndication(_) => 164,
                UEContextReleaseRequestProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UEContextReleaseRequestProtocolIEs_EntryValue::Id_SecondaryRATDataUsageReportList(_) => 264,
                UEContextReleaseRequestProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextReleaseRequestProtocolIEs(pub Vec<UEContextReleaseRequestProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for UEContextReleaseRequestProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEContextReleaseRequestProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEContextResumeFailureProtocolIEs_EntryValue {
    #[asn(key = 2)]
    Id_Cause(Cause),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeFailureProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextResumeFailureProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEContextResumeFailureProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UEContextResumeFailureProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UEContextResumeFailureProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UEContextResumeFailureProtocolIEs_EntryValue::Id_Cause(_) => 2,
                UEContextResumeFailureProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                UEContextResumeFailureProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UEContextResumeFailureProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextResumeFailureProtocolIEs(pub Vec<UEContextResumeFailureProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for UEContextResumeFailureProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEContextResumeFailureProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEContextResumeRequestProtocolIEs_EntryValue {
    #[asn(key = 235)]
    Id_E_RABFailedToResumeListResumeReq(E_RABFailedToResumeListResumeReq),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 245)]
    Id_RRC_Resume_Cause(RRC_Establishment_Cause),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextResumeRequestProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEContextResumeRequestProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UEContextResumeRequestProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UEContextResumeRequestProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UEContextResumeRequestProtocolIEs_EntryValue::Id_E_RABFailedToResumeListResumeReq(_) => 235,
                UEContextResumeRequestProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UEContextResumeRequestProtocolIEs_EntryValue::Id_RRC_Resume_Cause(_) => 245,
                UEContextResumeRequestProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextResumeRequestProtocolIEs(pub Vec<UEContextResumeRequestProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for UEContextResumeRequestProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEContextResumeRequestProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEContextResumeResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 237)]
    Id_E_RABFailedToResumeListResumeRes(E_RABFailedToResumeListResumeRes),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 283)]
    Id_PendingDataIndication(PendingDataIndication),
    #[asn(key = 40)]
    Id_SecurityContext(SecurityContext),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextResumeResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextResumeResponseProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEContextResumeResponseProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UEContextResumeResponseProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UEContextResumeResponseProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UEContextResumeResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                UEContextResumeResponseProtocolIEs_EntryValue::Id_E_RABFailedToResumeListResumeRes(_) => 237,
                UEContextResumeResponseProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UEContextResumeResponseProtocolIEs_EntryValue::Id_PendingDataIndication(_) => 283,
                UEContextResumeResponseProtocolIEs_EntryValue::Id_SecurityContext(_) => 40,
                UEContextResumeResponseProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextResumeResponseProtocolIEs(pub Vec<UEContextResumeResponseProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for UEContextResumeResponseProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEContextResumeResponseProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEContextSuspendRequestProtocolIEs_EntryValue {
    #[asn(key = 212)]
    Id_CellIdentifierAndCELevelForCECapableUEs(CellIdentifierAndCELevelForCECapableUEs),
    #[asn(key = 213)]
    Id_InformationOnRecommendedCellsAndENBsForPaging(InformationOnRecommendedCellsAndENBsForPaging),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 264)]
    Id_SecondaryRATDataUsageReportList(SecondaryRATDataUsageReportList),
    #[asn(key = 297)]
    Id_TimeSinceSecondaryNodeRelease(TimeSinceSecondaryNodeRelease),
    #[asn(key = 189)]
    Id_UserLocationInformation(UserLocationInformation),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextSuspendRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextSuspendRequestProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEContextSuspendRequestProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UEContextSuspendRequestProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UEContextSuspendRequestProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UEContextSuspendRequestProtocolIEs_EntryValue::Id_CellIdentifierAndCELevelForCECapableUEs(_) => 212,
                UEContextSuspendRequestProtocolIEs_EntryValue::Id_InformationOnRecommendedCellsAndENBsForPaging(_) => 213,
                UEContextSuspendRequestProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UEContextSuspendRequestProtocolIEs_EntryValue::Id_SecondaryRATDataUsageReportList(_) => 264,
                UEContextSuspendRequestProtocolIEs_EntryValue::Id_TimeSinceSecondaryNodeRelease(_) => 297,
                UEContextSuspendRequestProtocolIEs_EntryValue::Id_UserLocationInformation(_) => 189,
                UEContextSuspendRequestProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextSuspendRequestProtocolIEs(pub Vec<UEContextSuspendRequestProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for UEContextSuspendRequestProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEContextSuspendRequestProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEContextSuspendResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 40)]
    Id_SecurityContext(SecurityContext),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEContextSuspendResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEContextSuspendResponseProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEContextSuspendResponseProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UEContextSuspendResponseProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UEContextSuspendResponseProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UEContextSuspendResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                UEContextSuspendResponseProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UEContextSuspendResponseProtocolIEs_EntryValue::Id_SecurityContext(_) => 40,
                UEContextSuspendResponseProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEContextSuspendResponseProtocolIEs(pub Vec<UEContextSuspendResponseProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for UEContextSuspendResponseProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEContextSuspendResponseProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UEInformationTransferProtocolIEs_EntryValue {
    #[asn(key = 283)]
    Id_PendingDataIndication(PendingDataIndication),
    #[asn(key = 96)]
    Id_S_TMSI(S_TMSI),
    #[asn(key = 278)]
    Id_Subscription_Based_UE_DifferentiationInfo(Subscription_Based_UE_DifferentiationInfo),
    #[asn(key = 252)]
    Id_UE_Level_QoS_Parameters(E_RABLevelQoSParameters),
    #[asn(key = 74)]
    Id_UERadioCapability(UERadioCapability),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UEInformationTransferProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UEInformationTransferProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UEInformationTransferProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UEInformationTransferProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UEInformationTransferProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UEInformationTransferProtocolIEs_EntryValue::Id_PendingDataIndication(_) => 283,
                UEInformationTransferProtocolIEs_EntryValue::Id_S_TMSI(_) => 96,
                UEInformationTransferProtocolIEs_EntryValue::Id_Subscription_Based_UE_DifferentiationInfo(_) => 278,
                UEInformationTransferProtocolIEs_EntryValue::Id_UE_Level_QoS_Parameters(_) => 252,
                UEInformationTransferProtocolIEs_EntryValue::Id_UERadioCapability(_) => 74,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UEInformationTransferProtocolIEs(pub Vec<UEInformationTransferProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for UEInformationTransferProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UEInformationTransferProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue {
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityIDMappingRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UERadioCapabilityIDMappingRequestProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UERadioCapabilityIDMappingRequestProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UERadioCapabilityIDMappingRequestProtocolIEs_EntryValue::Id_UERadioCapabilityID(_) => 314,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityIDMappingRequestProtocolIEs(
    pub Vec<UERadioCapabilityIDMappingRequestProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UERadioCapabilityIDMappingRequestProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UERadioCapabilityIDMappingRequestProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 74)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityIDMappingResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UERadioCapabilityIDMappingResponseProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UERadioCapabilityIDMappingResponseProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue::Id_UERadioCapability(_) => 74,
                UERadioCapabilityIDMappingResponseProtocolIEs_EntryValue::Id_UERadioCapabilityID(_) => 314,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityIDMappingResponseProtocolIEs(
    pub Vec<UERadioCapabilityIDMappingResponseProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UERadioCapabilityIDMappingResponseProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UERadioCapabilityIDMappingResponseProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityMatchRequestProtocolIEs_EntryValue {
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 74)]
    Id_UERadioCapability(UERadioCapability),
    #[asn(key = 314)]
    Id_UERadioCapabilityID(UERadioCapabilityID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityMatchRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityMatchRequestProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UERadioCapabilityMatchRequestProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UERadioCapabilityMatchRequestProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UERadioCapabilityMatchRequestProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UERadioCapabilityMatchRequestProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UERadioCapabilityMatchRequestProtocolIEs_EntryValue::Id_UERadioCapability(_) => 74,
                UERadioCapabilityMatchRequestProtocolIEs_EntryValue::Id_UERadioCapabilityID(_) => 314,
                UERadioCapabilityMatchRequestProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityMatchRequestProtocolIEs(
    pub Vec<UERadioCapabilityMatchRequestProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UERadioCapabilityMatchRequestProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UERadioCapabilityMatchRequestProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UERadioCapabilityMatchResponseProtocolIEs_EntryValue {
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 169)]
    Id_VoiceSupportMatchIndicator(VoiceSupportMatchIndicator),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UERadioCapabilityMatchResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UERadioCapabilityMatchResponseProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UERadioCapabilityMatchResponseProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UERadioCapabilityMatchResponseProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UERadioCapabilityMatchResponseProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UERadioCapabilityMatchResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                UERadioCapabilityMatchResponseProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UERadioCapabilityMatchResponseProtocolIEs_EntryValue::Id_VoiceSupportMatchIndicator(_) => 169,
                UERadioCapabilityMatchResponseProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UERadioCapabilityMatchResponseProtocolIEs(
    pub Vec<UERadioCapabilityMatchResponseProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UERadioCapabilityMatchResponseProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UERadioCapabilityMatchResponseProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UESecurityCapabilitiesIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UESecurityCapabilitiesIE_Extensions(pub Vec<UESecurityCapabilitiesIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for UESecurityCapabilitiesIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UESecurityCapabilitiesIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UESidelinkAggregateMaximumBitrateIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UESidelinkAggregateMaximumBitrateIE_Extensions(
    pub Vec<UESidelinkAggregateMaximumBitrateIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UESidelinkAggregateMaximumBitrateIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UESidelinkAggregateMaximumBitrateIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UL_CP_SecurityInformationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UL_CP_SecurityInformationIE_Extensions(
    pub Vec<UL_CP_SecurityInformationIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UL_CP_SecurityInformationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UL_CP_SecurityInformationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UnsuccessfulOutcomeValue {
    #[asn(key = 29)]
    Id_ENBConfigurationUpdate(ENBConfigurationUpdateFailure),
    #[asn(key = 0)]
    Id_HandoverPreparation(HandoverPreparationFailure),
    #[asn(key = 1)]
    Id_HandoverResourceAllocation(HandoverFailure),
    #[asn(key = 9)]
    Id_InitialContextSetup(InitialContextSetupFailure),
    #[asn(key = 30)]
    Id_MMEConfigurationUpdate(MMEConfigurationUpdateFailure),
    #[asn(key = 3)]
    Id_PathSwitchRequest(PathSwitchRequestFailure),
    #[asn(key = 17)]
    Id_S1Setup(S1SetupFailure),
    #[asn(key = 21)]
    Id_UEContextModification(UEContextModificationFailure),
    #[asn(key = 56)]
    Id_UEContextResume(UEContextResumeFailure),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UplinkNASTransportProtocolIEs_EntryValue {
    #[asn(key = 100)]
    Id_EUTRAN_CGI(EUTRAN_CGI),
    #[asn(key = 155)]
    Id_GW_TransportLayerAddress(TransportLayerAddress),
    #[asn(key = 186)]
    Id_LHN_ID(LHN_ID),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 26)]
    Id_NAS_PDU(NAS_PDU),
    #[asn(key = 288)]
    Id_PSCellInformation(PSCellInformation),
    #[asn(key = 184)]
    Id_SIPTO_L_GW_TransportLayerAddress(TransportLayerAddress),
    #[asn(key = 67)]
    Id_TAI(TAI),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkNASTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkNASTransportProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UplinkNASTransportProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UplinkNASTransportProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UplinkNASTransportProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UplinkNASTransportProtocolIEs_EntryValue::Id_EUTRAN_CGI(_) => 100,
                UplinkNASTransportProtocolIEs_EntryValue::Id_GW_TransportLayerAddress(_) => 155,
                UplinkNASTransportProtocolIEs_EntryValue::Id_LHN_ID(_) => 186,
                UplinkNASTransportProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UplinkNASTransportProtocolIEs_EntryValue::Id_NAS_PDU(_) => 26,
                UplinkNASTransportProtocolIEs_EntryValue::Id_PSCellInformation(_) => 288,
                UplinkNASTransportProtocolIEs_EntryValue::Id_SIPTO_L_GW_TransportLayerAddress(_) => 184,
                UplinkNASTransportProtocolIEs_EntryValue::Id_TAI(_) => 67,
                UplinkNASTransportProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkNASTransportProtocolIEs(pub Vec<UplinkNASTransportProtocolIEs_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for UplinkNASTransportProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UplinkNASTransportProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UplinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 147)]
    Id_LPPa_PDU(LPPa_PDU),
    #[asn(key = 148)]
    Id_Routing_ID(Routing_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkNonUEAssociatedLPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UplinkNonUEAssociatedLPPaTransportProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UplinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UplinkNonUEAssociatedLPPaTransportProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UplinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue::Id_LPPa_PDU(_) => 147,
                UplinkNonUEAssociatedLPPaTransportProtocolIEs_EntryValue::Id_Routing_ID(_) => 148,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkNonUEAssociatedLPPaTransportProtocolIEs(
    pub Vec<UplinkNonUEAssociatedLPPaTransportProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UplinkNonUEAssociatedLPPaTransportProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UplinkNonUEAssociatedLPPaTransportProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UplinkS1cdma2000tunnellingProtocolIEs_EntryValue {
    #[asn(key = 140)]
    Id_EUTRANRoundTripDelayEstimationInfo(EUTRANRoundTripDelayEstimationInfo),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 84)]
    Id_cdma2000HORequiredIndication(Cdma2000HORequiredIndication),
    #[asn(key = 97)]
    Id_cdma2000OneXRAND(Cdma2000OneXRAND),
    #[asn(key = 102)]
    Id_cdma2000OneXSRVCCInfo(Cdma2000OneXSRVCCInfo),
    #[asn(key = 70)]
    Id_cdma2000PDU(Cdma2000PDU),
    #[asn(key = 71)]
    Id_cdma2000RATType(Cdma2000RATType),
    #[asn(key = 72)]
    Id_cdma2000SectorID(Cdma2000SectorID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkS1cdma2000tunnellingProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkS1cdma2000tunnellingProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UplinkS1cdma2000tunnellingProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UplinkS1cdma2000tunnellingProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UplinkS1cdma2000tunnellingProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UplinkS1cdma2000tunnellingProtocolIEs_EntryValue::Id_EUTRANRoundTripDelayEstimationInfo(_) => 140,
                UplinkS1cdma2000tunnellingProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UplinkS1cdma2000tunnellingProtocolIEs_EntryValue::Id_cdma2000HORequiredIndication(_) => 84,
                UplinkS1cdma2000tunnellingProtocolIEs_EntryValue::Id_cdma2000OneXRAND(_) => 97,
                UplinkS1cdma2000tunnellingProtocolIEs_EntryValue::Id_cdma2000OneXSRVCCInfo(_) => 102,
                UplinkS1cdma2000tunnellingProtocolIEs_EntryValue::Id_cdma2000PDU(_) => 70,
                UplinkS1cdma2000tunnellingProtocolIEs_EntryValue::Id_cdma2000RATType(_) => 71,
                UplinkS1cdma2000tunnellingProtocolIEs_EntryValue::Id_cdma2000SectorID(_) => 72,
                UplinkS1cdma2000tunnellingProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkS1cdma2000tunnellingProtocolIEs(
    pub Vec<UplinkS1cdma2000tunnellingProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UplinkS1cdma2000tunnellingProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UplinkS1cdma2000tunnellingProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UplinkUEAssociatedLPPaTransportProtocolIEs_EntryValue {
    #[asn(key = 147)]
    Id_LPPa_PDU(LPPa_PDU),
    #[asn(key = 0)]
    Id_MME_UE_S1AP_ID(MME_UE_S1AP_ID),
    #[asn(key = 148)]
    Id_Routing_ID(Routing_ID),
    #[asn(key = 8)]
    Id_eNB_UE_S1AP_ID(ENB_UE_S1AP_ID),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UplinkUEAssociatedLPPaTransportProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: UplinkUEAssociatedLPPaTransportProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UplinkUEAssociatedLPPaTransportProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: UplinkUEAssociatedLPPaTransportProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(UplinkUEAssociatedLPPaTransportProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                UplinkUEAssociatedLPPaTransportProtocolIEs_EntryValue::Id_LPPa_PDU(_) => 147,
                UplinkUEAssociatedLPPaTransportProtocolIEs_EntryValue::Id_MME_UE_S1AP_ID(_) => 0,
                UplinkUEAssociatedLPPaTransportProtocolIEs_EntryValue::Id_Routing_ID(_) => 148,
                UplinkUEAssociatedLPPaTransportProtocolIEs_EntryValue::Id_eNB_UE_S1AP_ID(_) => 8,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct UplinkUEAssociatedLPPaTransportProtocolIEs(
    pub Vec<UplinkUEAssociatedLPPaTransportProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UplinkUEAssociatedLPPaTransportProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UplinkUEAssociatedLPPaTransportProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum UserLocationInformationIE_Extensions_EntryExtensionValue {
    #[asn(key = 288)]
    Id_PSCellInformation(PSCellInformation),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct UserLocationInformationIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: UserLocationInformationIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for UserLocationInformationIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: UserLocationInformationIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(UserLocationInformationIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                UserLocationInformationIE_Extensions_EntryExtensionValue::Id_PSCellInformation(_) => 288,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct UserLocationInformationIE_Extensions(
    pub Vec<UserLocationInformationIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for UserLocationInformationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(UserLocationInformationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct V2XServicesAuthorizedIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct V2XServicesAuthorizedIE_Extensions(pub Vec<V2XServicesAuthorizedIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for V2XServicesAuthorizedIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(V2XServicesAuthorizedIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct WLANMeasurementConfigurationWlan_rssi(pub u8);
impl WLANMeasurementConfigurationWlan_rssi {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for WLANMeasurementConfigurationWlan_rssi {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(WLANMeasurementConfigurationWlan_rssi(
            u.int_in_range(0..=0)?,
        ))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "ENUMERATED", extensible = true, lb = "0", ub = "0")]
pub struct WLANMeasurementConfigurationWlan_rtt(pub u8);
impl WLANMeasurementConfigurationWlan_rtt {
    pub const TRUE: u8 = 0u8;
}
impl<'a> arbitrary::Arbitrary<'a> for WLANMeasurementConfigurationWlan_rtt {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(WLANMeasurementConfigurationWlan_rtt(u.int_in_range(0..=0)?))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WLANMeasurementConfigurationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct WLANMeasurementConfigurationIE_Extensions(
    pub Vec<WLANMeasurementConfigurationIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for WLANMeasurementConfigurationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(WLANMeasurementConfigurationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WUS_Assistance_InformationIE_Extensions_Entry {}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct WUS_Assistance_InformationIE_Extensions(
    pub Vec<WUS_Assistance_InformationIE_Extensions_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for WUS_Assistance_InformationIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(WUS_Assistance_InformationIE_Extensions(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum WriteReplaceWarningRequestProtocolIEs_EntryValue {
    #[asn(key = 142)]
    Id_ConcurrentWarningMessageIndicator(ConcurrentWarningMessageIndicator),
    #[asn(key = 118)]
    Id_DataCodingScheme(DataCodingScheme),
    #[asn(key = 144)]
    Id_ExtendedRepetitionPeriod(ExtendedRepetitionPeriod),
    #[asn(key = 111)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 115)]
    Id_NumberofBroadcastRequest(NumberofBroadcastRequest),
    #[asn(key = 114)]
    Id_RepetitionPeriod(RepetitionPeriod),
    #[asn(key = 112)]
    Id_SerialNumber(SerialNumber),
    #[asn(key = 286)]
    Id_WarningAreaCoordinates(WarningAreaCoordinates),
    #[asn(key = 113)]
    Id_WarningAreaList(WarningAreaList),
    #[asn(key = 119)]
    Id_WarningMessageContents(WarningMessageContents),
    #[asn(key = 117)]
    Id_WarningSecurityInfo(WarningSecurityInfo),
    #[asn(key = 116)]
    Id_WarningType(WarningType),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WriteReplaceWarningRequestProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: WriteReplaceWarningRequestProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for WriteReplaceWarningRequestProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: WriteReplaceWarningRequestProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(WriteReplaceWarningRequestProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_ConcurrentWarningMessageIndicator(_) => 142,
                WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_DataCodingScheme(_) => 117,
                WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_ExtendedRepetitionPeriod(_) => 144,
                WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_MessageIdentifier(_) => 111,
                WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_NumberofBroadcastRequest(_) => 115,
                WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_RepetitionPeriod(_) => 114,
                WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_SerialNumber(_) => 112,
                WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_WarningAreaCoordinates(_) => 286,
                WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_WarningAreaList(_) => 113,
                WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_WarningMessageContents(_) => 119,
                WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_WarningSecurityInfo(_) => 117,
                WriteReplaceWarningRequestProtocolIEs_EntryValue::Id_WarningType(_) => 116,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct WriteReplaceWarningRequestProtocolIEs(
    pub Vec<WriteReplaceWarningRequestProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for WriteReplaceWarningRequestProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(WriteReplaceWarningRequestProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum WriteReplaceWarningResponseProtocolIEs_EntryValue {
    #[asn(key = 120)]
    Id_BroadcastCompletedAreaList(BroadcastCompletedAreaList),
    #[asn(key = 58)]
    Id_CriticalityDiagnostics(CriticalityDiagnostics),
    #[asn(key = 111)]
    Id_MessageIdentifier(MessageIdentifier),
    #[asn(key = 112)]
    Id_SerialNumber(SerialNumber),
}

#[derive(
    asn1_codecs_derive :: AperCodec,

    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct WriteReplaceWarningResponseProtocolIEs_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolIE_ID,
    pub criticality: Criticality,
    pub value: WriteReplaceWarningResponseProtocolIEs_EntryValue,
}

impl<'a> arbitrary::Arbitrary<'a> for WriteReplaceWarningResponseProtocolIEs_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let value: WriteReplaceWarningResponseProtocolIEs_EntryValue = u.arbitrary()?;
        Ok(WriteReplaceWarningResponseProtocolIEs_Entry {
            id: ProtocolIE_ID(match value {
                WriteReplaceWarningResponseProtocolIEs_EntryValue::Id_BroadcastCompletedAreaList(_) => 120,
                WriteReplaceWarningResponseProtocolIEs_EntryValue::Id_CriticalityDiagnostics(_) => 58,
                WriteReplaceWarningResponseProtocolIEs_EntryValue::Id_MessageIdentifier(_) => 111,
                WriteReplaceWarningResponseProtocolIEs_EntryValue::Id_SerialNumber(_) => 112,
            }),
            criticality: Criticality(Criticality::IGNORE),
            value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "0",
    sz_ub = "65535"
)]
pub struct WriteReplaceWarningResponseProtocolIEs(
    pub Vec<WriteReplaceWarningResponseProtocolIEs_Entry>,
);
impl<'a> arbitrary::Arbitrary<'a> for WriteReplaceWarningResponseProtocolIEs {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(0, std::cmp::min(10, u.int_in_range(0..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(WriteReplaceWarningResponseProtocolIEs(v))
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    arbitrary :: Arbitrary,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "OPEN")]
pub enum X2TNLConfigurationInfoIE_Extensions_EntryExtensionValue {
    #[asn(key = 193)]
    Id_eNBIndirectX2TransportLayerAddresses(ENBIndirectX2TransportLayerAddresses),
    #[asn(key = 153)]
    Id_eNBX2ExtendedTransportLayerAddresses(ENBX2ExtTLAs),
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(type = "SEQUENCE", extensible = false)]
pub struct X2TNLConfigurationInfoIE_Extensions_Entry {
    #[asn(key_field = true)]
    pub id: ProtocolExtensionID,
    pub criticality: Criticality,
    pub extension_value: X2TNLConfigurationInfoIE_Extensions_EntryExtensionValue,
}

impl<'a> arbitrary::Arbitrary<'a> for X2TNLConfigurationInfoIE_Extensions_Entry {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let extension_value: X2TNLConfigurationInfoIE_Extensions_EntryExtensionValue = u.arbitrary()?;
        Ok(X2TNLConfigurationInfoIE_Extensions_Entry {
            id: ProtocolExtensionID(match extension_value {
                X2TNLConfigurationInfoIE_Extensions_EntryExtensionValue::Id_eNBIndirectX2TransportLayerAddresses(_) => 193,
                X2TNLConfigurationInfoIE_Extensions_EntryExtensionValue::Id_eNBX2ExtendedTransportLayerAddresses(_) => 153,
            }),
            criticality: Criticality(Criticality::IGNORE),
            extension_value,
        })
    }
}

#[derive(
    asn1_codecs_derive :: AperCodec,
    serde :: Serialize,
    serde :: Deserialize,
    Eq,
    PartialEq,
    Debug,
    Clone,
)]
#[asn(
    type = "SEQUENCE-OF",
    sz_extensible = false,
    sz_lb = "1",
    sz_ub = "65535"
)]
pub struct X2TNLConfigurationInfoIE_Extensions(pub Vec<X2TNLConfigurationInfoIE_Extensions_Entry>);
impl<'a> arbitrary::Arbitrary<'a> for X2TNLConfigurationInfoIE_Extensions {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let vec_length = std::cmp::max(1, std::cmp::min(10, u.int_in_range(1..=65535)?));
        let mut v = Vec::new();
        for _ in 0..vec_length {
            v.push(u.arbitrary()?);
        }
        Ok(X2TNLConfigurationInfoIE_Extensions(v))
    }
}
